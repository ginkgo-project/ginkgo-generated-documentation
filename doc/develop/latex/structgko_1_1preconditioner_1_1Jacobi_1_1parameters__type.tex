\hypertarget{structgko_1_1preconditioner_1_1Jacobi_1_1parameters__type}{}\doxysection{gko\+::preconditioner\+::Jacobi$<$ Value\+Type, Index\+Type $>$\+::parameters\+\_\+type Struct Reference}
\label{structgko_1_1preconditioner_1_1Jacobi_1_1parameters__type}\index{gko::preconditioner::Jacobi$<$ ValueType, IndexType $>$::parameters\_type@{gko::preconditioner::Jacobi$<$ ValueType, IndexType $>$::parameters\_type}}


Inheritance diagram for gko\+::preconditioner\+::Jacobi$<$ Value\+Type, Index\+Type $>$\+::parameters\+\_\+type\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=271pt]{structgko_1_1preconditioner_1_1Jacobi_1_1parameters__type__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for gko\+::preconditioner\+::Jacobi$<$ Value\+Type, Index\+Type $>$\+::parameters\+\_\+type\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structgko_1_1preconditioner_1_1Jacobi_1_1parameters__type__coll__graph}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{structgko_1_1preconditioner_1_1Jacobi_1_1parameters__type_a727b962016b129cdeef23c00de036424}\label{structgko_1_1preconditioner_1_1Jacobi_1_1parameters__type_a727b962016b129cdeef23c00de036424}} 
{\footnotesize template$<$typename... Args$>$ }\\auto {\bfseries with\+\_\+max\+\_\+block\+\_\+size} (Args \&\&... \+\_\+value) -\/$>$ std\+::decay\+\_\+t$<$ decltype($\ast$this)$>$ \&
\item 
\mbox{\Hypertarget{structgko_1_1preconditioner_1_1Jacobi_1_1parameters__type_aab57434903149a04df79c50ac0e943da}\label{structgko_1_1preconditioner_1_1Jacobi_1_1parameters__type_aab57434903149a04df79c50ac0e943da}} 
{\footnotesize template$<$typename... Args$>$ }\\auto {\bfseries with\+\_\+max\+\_\+block\+\_\+stride} (Args \&\&... \+\_\+value) -\/$>$ std\+::decay\+\_\+t$<$ decltype($\ast$this)$>$ \&
\item 
\mbox{\Hypertarget{structgko_1_1preconditioner_1_1Jacobi_1_1parameters__type_ade5c7a6a2163ea793f57305aa0d9696d}\label{structgko_1_1preconditioner_1_1Jacobi_1_1parameters__type_ade5c7a6a2163ea793f57305aa0d9696d}} 
{\footnotesize template$<$typename... Args$>$ }\\auto {\bfseries with\+\_\+skip\+\_\+sorting} (Args \&\&... \+\_\+value) -\/$>$ std\+::decay\+\_\+t$<$ decltype($\ast$this)$>$ \&
\item 
\mbox{\Hypertarget{structgko_1_1preconditioner_1_1Jacobi_1_1parameters__type_aad02f4533d7cf93fdfff44bc84e9c98b}\label{structgko_1_1preconditioner_1_1Jacobi_1_1parameters__type_aad02f4533d7cf93fdfff44bc84e9c98b}} 
{\footnotesize template$<$typename... Args$>$ }\\auto {\bfseries with\+\_\+block\+\_\+pointers} (Args \&\&... \+\_\+value) -\/$>$ std\+::decay\+\_\+t$<$ decltype($\ast$this)$>$ \&
\item 
\mbox{\Hypertarget{structgko_1_1preconditioner_1_1Jacobi_1_1parameters__type_adaca3658213e2e807fa822e877809145}\label{structgko_1_1preconditioner_1_1Jacobi_1_1parameters__type_adaca3658213e2e807fa822e877809145}} 
{\footnotesize template$<$typename... Args$>$ }\\auto {\bfseries with\+\_\+storage\+\_\+optimization} (Args \&\&... \+\_\+value) -\/$>$ std\+::decay\+\_\+t$<$ decltype($\ast$this)$>$ \&
\item 
\mbox{\Hypertarget{structgko_1_1preconditioner_1_1Jacobi_1_1parameters__type_abc0dfa37c980606043c0054de63a9c6f}\label{structgko_1_1preconditioner_1_1Jacobi_1_1parameters__type_abc0dfa37c980606043c0054de63a9c6f}} 
{\footnotesize template$<$typename... Args$>$ }\\auto {\bfseries with\+\_\+accuracy} (Args \&\&... \+\_\+value) -\/$>$ std\+::decay\+\_\+t$<$ decltype($\ast$this)$>$ \&
\end{DoxyCompactItemize}
\doxysubsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacegko_a318c831e3fe269ba04c6ed8bf5a71073}{uint32}} \mbox{\hyperlink{structgko_1_1preconditioner_1_1Jacobi_1_1parameters__type_a7d11d10b347b25b64b5b916e6a74364e}{max\+\_\+block\+\_\+size}} \{ 32u \}
\begin{DoxyCompactList}\small\item\em Maximal size of diagonal blocks. \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespacegko_a318c831e3fe269ba04c6ed8bf5a71073}{uint32}} \mbox{\hyperlink{structgko_1_1preconditioner_1_1Jacobi_1_1parameters__type_a042df68c54ea721101c4b064ed450a1f}{max\+\_\+block\+\_\+stride}} \{ 0u \}
\begin{DoxyCompactList}\small\item\em Stride between two columns of a block (as number of elements). \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{structgko_1_1preconditioner_1_1Jacobi_1_1parameters__type_adfc8ea4f7d80b7de39b396dbbc1e5654}{skip\+\_\+sorting}} \{ false \}
\begin{DoxyCompactList}\small\item\em {\ttfamily true} means it is known that the matrix given to this factory will be sorted first by row, then by column index, {\ttfamily false} means it is unknown or not sorted, so an additional sorting step will be performed during the preconditioner generation (it will not change the matrix given). \end{DoxyCompactList}\item 
\mbox{\hyperlink{classgko_1_1array}{gko\+::array}}$<$ index\+\_\+type $>$ \mbox{\hyperlink{structgko_1_1preconditioner_1_1Jacobi_1_1parameters__type_ad90b07202f15b6cd5c649f6b61480053}{block\+\_\+pointers}} \{ nullptr \}
\begin{DoxyCompactList}\small\item\em Starting (row / column) indexes of individual blocks. \end{DoxyCompactList}\item 
storage\+\_\+optimization\+\_\+type \mbox{\hyperlink{structgko_1_1preconditioner_1_1Jacobi_1_1parameters__type_a51d0eec65f99d6dd5b0ebe5ba69390dd}{storage\+\_\+optimization}} \{ \mbox{\hyperlink{classgko_1_1precision__reduction}{precision\+\_\+reduction}}(0, 0) \}
\begin{DoxyCompactList}\small\item\em The precisions to use for the blocks of the matrix. \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespacegko_afd46d554050c4ae90e84ea4fcd9a41f3}{remove\+\_\+complex}}$<$ value\+\_\+type $>$ \mbox{\hyperlink{structgko_1_1preconditioner_1_1Jacobi_1_1parameters__type_ad4fd0de7ce4d390584e947afb6d0ce73}{accuracy}} \{ static\+\_\+cast$<$\mbox{\hyperlink{namespacegko_afd46d554050c4ae90e84ea4fcd9a41f3}{remove\+\_\+complex}}$<$value\+\_\+type$>$$>$(1e-\/1) \}
\begin{DoxyCompactList}\small\item\em The relative accuracy of the adaptive \mbox{\hyperlink{classgko_1_1preconditioner_1_1Jacobi}{Jacobi}} variant. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Additional Inherited Members}


\doxysubsection{Member Data Documentation}
\mbox{\Hypertarget{structgko_1_1preconditioner_1_1Jacobi_1_1parameters__type_ad4fd0de7ce4d390584e947afb6d0ce73}\label{structgko_1_1preconditioner_1_1Jacobi_1_1parameters__type_ad4fd0de7ce4d390584e947afb6d0ce73}} 
\index{gko::preconditioner::Jacobi$<$ ValueType, IndexType $>$::parameters\_type@{gko::preconditioner::Jacobi$<$ ValueType, IndexType $>$::parameters\_type}!accuracy@{accuracy}}
\index{accuracy@{accuracy}!gko::preconditioner::Jacobi$<$ ValueType, IndexType $>$::parameters\_type@{gko::preconditioner::Jacobi$<$ ValueType, IndexType $>$::parameters\_type}}
\doxysubsubsection{\texorpdfstring{accuracy}{accuracy}}
{\footnotesize\ttfamily template$<$typename Value\+Type  = default\+\_\+precision, typename Index\+Type  = int32$>$ \\
\mbox{\hyperlink{namespacegko_afd46d554050c4ae90e84ea4fcd9a41f3}{remove\+\_\+complex}}$<$value\+\_\+type$>$ \mbox{\hyperlink{classgko_1_1preconditioner_1_1Jacobi}{gko\+::preconditioner\+::\+Jacobi}}$<$ Value\+Type, Index\+Type $>$\+::parameters\+\_\+type\+::accuracy \{ static\+\_\+cast$<$\mbox{\hyperlink{namespacegko_afd46d554050c4ae90e84ea4fcd9a41f3}{remove\+\_\+complex}}$<$value\+\_\+type$>$$>$(1e-\/1) \}\hspace{0.3cm}{\ttfamily [mutable]}}



The relative accuracy of the adaptive \mbox{\hyperlink{classgko_1_1preconditioner_1_1Jacobi}{Jacobi}} variant. 

This parameter is only used if the adaptive version of the algorithm is selected (see storage\+\_\+optimization parameter for more details). The parameter is used when detecting the optimal precisions of blocks whose precision has been set to \mbox{\hyperlink{classgko_1_1precision__reduction_a1fde4dd48fab015698c1616408f3ef81}{precision\+\_\+reduction\+::autodetect()}}.

The parameter represents the number of correct digits in the result of Jacobi\+::apply() operation of the adaptive variant, compared to the non-\/adaptive variant. In other words, the total preconditioning error will be\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{|| inv(A)x -\/ inv(M)x|| / || inv(A)x || <= c * (dropout + \mbox{\hyperlink{structgko_1_1preconditioner_1_1Jacobi_1_1parameters__type_ad4fd0de7ce4d390584e947afb6d0ce73}{accuracy}})}
\end{DoxyCode}


where {\ttfamily c} is some constant depending on the problem size and roundoff error and {\ttfamily dropout} the error introduced by disregarding off-\/diagonal elements.

Larger values reduce the volume of memory transfer, but increase the error compared to using full precision storage. Thus, tuning the accuracy to a value as close as possible to {\ttfamily dropout} will result in optimal memory savings, while not degrading the quality of solution. \mbox{\Hypertarget{structgko_1_1preconditioner_1_1Jacobi_1_1parameters__type_ad90b07202f15b6cd5c649f6b61480053}\label{structgko_1_1preconditioner_1_1Jacobi_1_1parameters__type_ad90b07202f15b6cd5c649f6b61480053}} 
\index{gko::preconditioner::Jacobi$<$ ValueType, IndexType $>$::parameters\_type@{gko::preconditioner::Jacobi$<$ ValueType, IndexType $>$::parameters\_type}!block\_pointers@{block\_pointers}}
\index{block\_pointers@{block\_pointers}!gko::preconditioner::Jacobi$<$ ValueType, IndexType $>$::parameters\_type@{gko::preconditioner::Jacobi$<$ ValueType, IndexType $>$::parameters\_type}}
\doxysubsubsection{\texorpdfstring{block\_pointers}{block\_pointers}}
{\footnotesize\ttfamily template$<$typename Value\+Type  = default\+\_\+precision, typename Index\+Type  = int32$>$ \\
\mbox{\hyperlink{classgko_1_1array}{gko\+::array}}$<$index\+\_\+type$>$ \mbox{\hyperlink{classgko_1_1preconditioner_1_1Jacobi}{gko\+::preconditioner\+::\+Jacobi}}$<$ Value\+Type, Index\+Type $>$\+::parameters\+\_\+type\+::block\+\_\+pointers \{ nullptr \}\hspace{0.3cm}{\ttfamily [mutable]}}



Starting (row / column) indexes of individual blocks. 

An index past the last block has to be supplied as the last value. I.\+e. the size of the array has to be the number of blocks plus 1, where the first value is 0, and the last value is the number of rows / columns of the matrix.

\begin{DoxyNote}{Note}
Even if not set explicitly, this parameter will be set to automatically detected values once the preconditioner is generated. 

If the parameter is set automatically, the size of the array does not correlate to the number of blocks, and is implementation defined. To obtain the number of blocks {\ttfamily n} use \mbox{\hyperlink{classgko_1_1preconditioner_1_1Jacobi_afb44d8e560f00f65c46c6813638ce24c}{Jacobi\+::get\+\_\+num\+\_\+blocks()}}. The starting indexes of the blocks are stored in the first {\ttfamily n+1} values of this array. 

If the block-\/diagonal structure can be determined from the problem characteristics, it may be beneficial to pass this information specifically via this parameter, as the autodetection procedure is only a rough approximation of the true block structure. 

The maximum block size set by the max\+\_\+block\+\_\+size parameter has to be respected when setting this parameter. Failure to do so will lead to undefined behavior. 
\end{DoxyNote}
\mbox{\Hypertarget{structgko_1_1preconditioner_1_1Jacobi_1_1parameters__type_a7d11d10b347b25b64b5b916e6a74364e}\label{structgko_1_1preconditioner_1_1Jacobi_1_1parameters__type_a7d11d10b347b25b64b5b916e6a74364e}} 
\index{gko::preconditioner::Jacobi$<$ ValueType, IndexType $>$::parameters\_type@{gko::preconditioner::Jacobi$<$ ValueType, IndexType $>$::parameters\_type}!max\_block\_size@{max\_block\_size}}
\index{max\_block\_size@{max\_block\_size}!gko::preconditioner::Jacobi$<$ ValueType, IndexType $>$::parameters\_type@{gko::preconditioner::Jacobi$<$ ValueType, IndexType $>$::parameters\_type}}
\doxysubsubsection{\texorpdfstring{max\_block\_size}{max\_block\_size}}
{\footnotesize\ttfamily template$<$typename Value\+Type  = default\+\_\+precision, typename Index\+Type  = int32$>$ \\
\mbox{\hyperlink{namespacegko_a318c831e3fe269ba04c6ed8bf5a71073}{uint32}} \mbox{\hyperlink{classgko_1_1preconditioner_1_1Jacobi}{gko\+::preconditioner\+::\+Jacobi}}$<$ Value\+Type, Index\+Type $>$\+::parameters\+\_\+type\+::max\+\_\+block\+\_\+size \{ 32u \}\hspace{0.3cm}{\ttfamily [mutable]}}



Maximal size of diagonal blocks. 

\begin{DoxyNote}{Note}
This value has to be between 1 and 32 (N\+V\+I\+D\+IA)/64 (A\+MD). For efficiency, when the max\+\_\+block\+\_\+size is set to 1, specialized kernels are used and the additional objects (block\+\_\+ptrs etc) are set to null values. 
\end{DoxyNote}
\mbox{\Hypertarget{structgko_1_1preconditioner_1_1Jacobi_1_1parameters__type_a042df68c54ea721101c4b064ed450a1f}\label{structgko_1_1preconditioner_1_1Jacobi_1_1parameters__type_a042df68c54ea721101c4b064ed450a1f}} 
\index{gko::preconditioner::Jacobi$<$ ValueType, IndexType $>$::parameters\_type@{gko::preconditioner::Jacobi$<$ ValueType, IndexType $>$::parameters\_type}!max\_block\_stride@{max\_block\_stride}}
\index{max\_block\_stride@{max\_block\_stride}!gko::preconditioner::Jacobi$<$ ValueType, IndexType $>$::parameters\_type@{gko::preconditioner::Jacobi$<$ ValueType, IndexType $>$::parameters\_type}}
\doxysubsubsection{\texorpdfstring{max\_block\_stride}{max\_block\_stride}}
{\footnotesize\ttfamily template$<$typename Value\+Type  = default\+\_\+precision, typename Index\+Type  = int32$>$ \\
\mbox{\hyperlink{namespacegko_a318c831e3fe269ba04c6ed8bf5a71073}{uint32}} \mbox{\hyperlink{classgko_1_1preconditioner_1_1Jacobi}{gko\+::preconditioner\+::\+Jacobi}}$<$ Value\+Type, Index\+Type $>$\+::parameters\+\_\+type\+::max\+\_\+block\+\_\+stride \{ 0u \}\hspace{0.3cm}{\ttfamily [mutable]}}



Stride between two columns of a block (as number of elements). 

Should be a multiple of cache line size for best performance.

\begin{DoxyNote}{Note}
If this value is 0, it uses 64 in hip A\+MD but 32 in N\+V\+I\+D\+IA or reference executor. The allowed value\+: 0, 64 for A\+MD and 0, 32 for N\+V\+I\+D\+IA 
\end{DoxyNote}
\mbox{\Hypertarget{structgko_1_1preconditioner_1_1Jacobi_1_1parameters__type_adfc8ea4f7d80b7de39b396dbbc1e5654}\label{structgko_1_1preconditioner_1_1Jacobi_1_1parameters__type_adfc8ea4f7d80b7de39b396dbbc1e5654}} 
\index{gko::preconditioner::Jacobi$<$ ValueType, IndexType $>$::parameters\_type@{gko::preconditioner::Jacobi$<$ ValueType, IndexType $>$::parameters\_type}!skip\_sorting@{skip\_sorting}}
\index{skip\_sorting@{skip\_sorting}!gko::preconditioner::Jacobi$<$ ValueType, IndexType $>$::parameters\_type@{gko::preconditioner::Jacobi$<$ ValueType, IndexType $>$::parameters\_type}}
\doxysubsubsection{\texorpdfstring{skip\_sorting}{skip\_sorting}}
{\footnotesize\ttfamily template$<$typename Value\+Type  = default\+\_\+precision, typename Index\+Type  = int32$>$ \\
bool \mbox{\hyperlink{classgko_1_1preconditioner_1_1Jacobi}{gko\+::preconditioner\+::\+Jacobi}}$<$ Value\+Type, Index\+Type $>$\+::parameters\+\_\+type\+::skip\+\_\+sorting \{ false \}\hspace{0.3cm}{\ttfamily [mutable]}}



{\ttfamily true} means it is known that the matrix given to this factory will be sorted first by row, then by column index, {\ttfamily false} means it is unknown or not sorted, so an additional sorting step will be performed during the preconditioner generation (it will not change the matrix given). 

The matrix must be sorted for this preconditioner to work.

The {\ttfamily system\+\_\+matrix}, which will be given to this factory, must be sorted (first by row, then by column) in order for the algorithm to work. If it is known that the matrix will be sorted, this parameter can be set to {\ttfamily true} to skip the sorting (therefore, shortening the runtime). However, if it is unknown or if the matrix is known to be not sorted, it must remain {\ttfamily false}, otherwise, this preconditioner might be incorrect. \mbox{\Hypertarget{structgko_1_1preconditioner_1_1Jacobi_1_1parameters__type_a51d0eec65f99d6dd5b0ebe5ba69390dd}\label{structgko_1_1preconditioner_1_1Jacobi_1_1parameters__type_a51d0eec65f99d6dd5b0ebe5ba69390dd}} 
\index{gko::preconditioner::Jacobi$<$ ValueType, IndexType $>$::parameters\_type@{gko::preconditioner::Jacobi$<$ ValueType, IndexType $>$::parameters\_type}!storage\_optimization@{storage\_optimization}}
\index{storage\_optimization@{storage\_optimization}!gko::preconditioner::Jacobi$<$ ValueType, IndexType $>$::parameters\_type@{gko::preconditioner::Jacobi$<$ ValueType, IndexType $>$::parameters\_type}}
\doxysubsubsection{\texorpdfstring{storage\_optimization}{storage\_optimization}}
{\footnotesize\ttfamily template$<$typename Value\+Type  = default\+\_\+precision, typename Index\+Type  = int32$>$ \\
storage\+\_\+optimization\+\_\+type \mbox{\hyperlink{classgko_1_1preconditioner_1_1Jacobi}{gko\+::preconditioner\+::\+Jacobi}}$<$ Value\+Type, Index\+Type $>$\+::parameters\+\_\+type\+::storage\+\_\+optimization \{ \mbox{\hyperlink{classgko_1_1precision__reduction}{precision\+\_\+reduction}}(0, 0) \}\hspace{0.3cm}{\ttfamily [mutable]}}



The precisions to use for the blocks of the matrix. 

This parameter can either be a single instance of \mbox{\hyperlink{classgko_1_1precision__reduction}{precision\+\_\+reduction}} or an array of \mbox{\hyperlink{classgko_1_1precision__reduction}{precision\+\_\+reduction}} values. If set to {\ttfamily precision\+\_\+reduction(0, 0)} (this is the default), a regular full-\/precision block-\/\+Jacobi will be used. Any other value (or an array of values) will map to the adaptive variant.

The best starting point when evaluating the potential of the adaptive version is to set this parameter to {\ttfamily \mbox{\hyperlink{classgko_1_1precision__reduction_a1fde4dd48fab015698c1616408f3ef81}{precision\+\_\+reduction\+::autodetect()}}}. This option will cause the preconditioner to reduce the memory transfer volume as much as possible, while trying to maintain the quality of the preconditioner similar to that of the full precision block-\/\+Jacobi.

For finer control, specific instances of \mbox{\hyperlink{classgko_1_1precision__reduction}{precision\+\_\+reduction}} can be used. Supported values are {\ttfamily precision\+\_\+reduction(0, 0)}, {\ttfamily precision\+\_\+reduction(0, 1)} and {\ttfamily precision\+\_\+reduction(0, 2)}. Any other value will have the same effect as {\ttfamily precision\+\_\+reduction(0, 0)}.

If the Value\+Type template parameter is set to {\ttfamily double} (or the complex variant {\ttfamily std\+::complex$<$double$>$}), {\ttfamily precision\+\_\+reduction(0, 0)} will use I\+E\+EE double precision for preconditioner storage, {\ttfamily precision\+\_\+reduction(0, 1)} will use I\+E\+EE single precision, and {\ttfamily precision\+\_\+reduction(0, 2)} will use I\+E\+EE half precision.

It Value\+Type is set to {\ttfamily float} (or {\ttfamily std\+::complex$<$float$>$}), {\ttfamily precision\+\_\+reduction(0, 0)} will use I\+E\+EE single precision for preconditioner storage, and both {\ttfamily precision\+\_\+reduction(0, 1)} and {\ttfamily precision\+\_\+reduction(0, 2)} will use I\+E\+EE half precision.

Instead of specifying the same precision for all blocks, the precision of the elements can be specified on per-\/block basis by passing an array of \mbox{\hyperlink{classgko_1_1precision__reduction}{precision\+\_\+reduction}} objects. All values discussed above are supported, with the same meaning. It is worth mentioning that a value of {\ttfamily \mbox{\hyperlink{classgko_1_1precision__reduction_a1fde4dd48fab015698c1616408f3ef81}{precision\+\_\+reduction\+::autodetect()}}} will cause autodetection on the per-\/block basis, so blocks whose precisions are autodetected can end up having different precisions once the preconditioner is generated. The detected precision generally depends on the conditioning of the block.

If the number of diagonal blocks is larger than the number of elements in the passed array, the entire array will be replicated until enough values are available. For example, if the original array contained two precisions {\ttfamily (x, y)} and the preconditioner contains 5 blocks, the array will be transformed into {\ttfamily (x, y, x, y, x)} before generating the preconditioner. As a consequence, specifying a single value for this property is exactly equivalent to specifying an array with a single element set to that value.

Once an instance of the \mbox{\hyperlink{classgko_1_1preconditioner_1_1Jacobi}{Jacobi}} linear operator is generated, the precisions used for the blocks can be obtained by reading this property. Whether the parameter was set to a single value or to an array of values can be queried by reading the {\ttfamily storage\+\_\+optimization.\+is\+\_\+block\+\_\+wise} boolean sub-\/property. If it is set to {\ttfamily false}, the precision used for all blocks can be obtained using {\ttfamily storage\+\_\+optimization.\+of\+\_\+all\+\_\+blocks} or by casting {\ttfamily storage\+\_\+optimization} to {\ttfamily \mbox{\hyperlink{classgko_1_1precision__reduction}{precision\+\_\+reduction}}}. Independently of the value of {\ttfamily storage\+\_\+optimization.\+is\+\_\+block\+\_\+wise}, the {\ttfamily storage\+\_\+optimization.\+block\+\_\+wise} property will return an array of precisions used for each block. All values set to {\ttfamily \mbox{\hyperlink{classgko_1_1precision__reduction_a1fde4dd48fab015698c1616408f3ef81}{precision\+\_\+reduction\+::autodetect()}}} will be replaced with the value representing the precision used for the corresponding block. If the non-\/adaptive version of \mbox{\hyperlink{classgko_1_1preconditioner_1_1Jacobi}{Jacobi}} is used, the {\ttfamily storage\+\_\+optimization.\+block\+\_\+wise} array will be empty. 

The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
ginkgo/core/preconditioner/jacobi.\+hpp\end{DoxyCompactItemize}
