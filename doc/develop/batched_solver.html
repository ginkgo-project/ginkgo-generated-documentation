<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Ginkgo: The batched-solver program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_doc.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Ginkgo
   &#160;<span id="projectnumber">Generated from pipelines/1379542886 branch based on develop. Ginkgo version 1.9.0</span>
   </div>
   <div id="projectbrief">A numerical linear algebra library targeting many-core architectures</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">The batched-solver program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Using and interfacing with a batched solver..</p>
<p> 
<table class="example" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#Typealiasesforconvenience">Type aliases for convenience</a>
        <li><a href="#Conveniencefunctions">Convenience functions</a>
        <li><a href="#Applicationstructuresandfunctions">'Application' structures and functions</a>
        <li><a href="#Wheredoyouwanttorunyoursolver">Where do you want to run your solver ?</a>
        <li><a href="#Generatedata">Generate data</a>
        <li><a href="#Useofapplicationallocatedmemory">Use of application-allocated memory</a>
        <li><a href="#RHSandsolutionvectors">RHS and solution vectors</a>
        <li><a href="#Createthebatchsolverfactory">Create the batch solver factory</a>
        <li><a href="#Batchlogger">Batch logger</a>
        <li><a href="#Generateandsolve">Generate and solve</a>
        <li><a href="#Checkresult">Check result</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Commentsaboutprogramminganddebugging"> Comments about programming and debugging </a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <a class="anchor" id="Batched Solver"></a> <a class="anchor" id="Usingbatchedsolvers"></a></p><h1>Using batched solvers</h1>
<p>This example shows how to use Ginkgo batched solvers with data coming from an application. The "application" in this case is just a function in the example itself; nevertheless, the steps to be taken are shown.</p>
<p>A &lsquo;batch&rsquo; here means a set of small linear systems that can be solved independently, but each system is too small to use an entire computing device. A requirement is that all the systems need to have the same sparsity pattern. <a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputType&gt;</div>
<div class="line"><span class="keyword">auto</span> unbatch(<span class="keyword">const</span> InputType* batch_object)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> unbatched_mats =</div>
<div class="line">        std::vector&lt;std::unique_ptr&lt;typename InputType::unbatch_type&gt;&gt;{};</div>
<div class="line">    <span class="keywordflow">for</span> (size_type b = 0; b &lt; batch_object-&gt;get_num_batch_items(); ++b) {</div>
<div class="line">        unbatched_mats.emplace_back(</div>
<div class="line">            batch_object-&gt;create_const_view_for_item(b)-&gt;clone());</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> unbatched_mats;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">}  <span class="comment">// namespace detail</span></div>
</div><!-- fragment --><p><a class="anchor" id="Applicationstructuresandfunctions"></a> </p><h3>'Application' structures and functions</h3>
<p>Structure to simulate application data related to the linear systems to be solved.</p>
<p>We use raw pointers below to demonstrate how to handle the situation when the application only gives us raw pointers. Ideally, one should use Ginkgo's gko::Array class here. In this example, we assume that the data is in a format that can directly be given to a batch::matrix::Csr object.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ApplSysData {</div>
</div><!-- fragment --><p>Number of small systems in the batch.</p>
<div class="fragment"><div class="line"><a class="code" href="namespacegko.html#a6e5c95df0ae4e47aab2f604a22d98ee7">size_type</a> nsystems;</div>
</div><!-- fragment --><p>Number of rows in each system.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> nrows;</div>
</div><!-- fragment --><p>Number of non-zeros in each system matrix.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> nnz;</div>
</div><!-- fragment --><p>Row pointers for one matrix</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> index_type* row_ptrs;</div>
</div><!-- fragment --><p>Column indices of non-zeros for one matrix</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> index_type* col_idxs;</div>
</div><!-- fragment --><p>Nonzero values for all matrices in the batch, concatenated</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> value_type* all_values;</div>
</div><!-- fragment --><p>RHS vectors for all systems in the batch, concatenated</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> value_type* all_rhs;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">/ *</div>
<div class="line"> * Generates a batch of tridiagonal systems.</div>
<div class="line"> *</div>
<div class="line"> * @param nrows  Number of <a class="code" href="namespacegko_1_1matrix.html#ade1f3cdbf05032c2d681fa151de02972adf347a373b8f92aa0ae3dd920a5ec2f6">rows</a> in each system.</div>
<div class="line"> * @param nsystems  Number of systems in the batch.</div>
<div class="line"> * @param exec  The device executor to use <span class="keywordflow">for</span> the <a class="code" href="namespacegko_1_1log.html#a15f71654c6c4f4defc95f9359343fa27a7cbf673200498a0d1324f4330825202a">solver</a>.</div>
<div class="line"> * @note  Normally, the application may not deal with Ginkgo executors, nor <span class="keywordflow">do</span></div>
<div class="line"> * we need it to. Here, we use the executor <span class="keywordflow">for</span> backend-independent device</div>
<div class="line"> * <a class="code" href="namespacegko_1_1log.html#a15f71654c6c4f4defc95f9359343fa27acd69b4957f06cd818d7bf3d61980e291">memory</a> allocation. The application, <span class="keywordflow">for</span> example, might assume Hip (<span class="keywordflow">for</span> AMD</div>
<div class="line"> * GPUs) and use `hipMalloc` directly.</div>
<div class="line"> * /</div>
<div class="line">ApplSysData appl_generate_system(<span class="keyword">const</span> <span class="keywordtype">int</span> nrows, <span class="keyword">const</span> size_type nsystems,</div>
<div class="line">                                 std::shared_ptr&lt;gko::Executor&gt; exec);</div>
</div><!-- fragment --><p>Deallocate application data.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> appl_clean_up(ApplSysData&amp; appl_data, std::shared_ptr&lt;gko::Executor&gt; exec);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
</div><!-- fragment --><p>Print ginkgo version information</p>
<div class="fragment"><div class="line">std::cout &lt;&lt; <a class="code" href="classgko_1_1version__info.html#a6daeb8a087cfb57fa055526fc133d8eb">gko::version_info::get</a>() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (argc == 2 &amp;&amp; (std::string(argv[1]) == <span class="stringliteral">&quot;--help&quot;</span>)) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Usage: &quot;</span> &lt;&lt; argv[0]</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot; [executor] [num_systems] [num_rows] [print_residuals] &quot;</span></div>
<div class="line">                 <span class="stringliteral">&quot;[num_reps]&quot;</span></div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line">    std::exit(-1);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="Wheredoyouwanttorunyoursolver"></a> </p><h3>Where do you want to run your solver ?</h3>
<p>The <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">gko::Executor</a> class is one of the cornerstones of Ginkgo. Currently, we have support for an <a class="el" href="classgko_1_1OmpExecutor.html" title="This is the Executor subclass which represents the OpenMP device (typically CPU).">gko::OmpExecutor</a>, which uses OpenMP multi-threading in most of its kernels, a <a class="el" href="classgko_1_1ReferenceExecutor.html" title="This is a specialization of the OmpExecutor, which runs the reference implementations of the kernels ...">gko::ReferenceExecutor</a>, a single threaded specialization of the OpenMP executor, <a class="el" href="classgko_1_1CudaExecutor.html" title="This is the Executor subclass which represents the CUDA device.">gko::CudaExecutor</a>, <a class="el" href="classgko_1_1HipExecutor.html" title="This is the Executor subclass which represents the HIP enhanced device.">gko::HipExecutor</a>, <a class="el" href="classgko_1_1DpcppExecutor.html" title="This is the Executor subclass which represents a DPC++ enhanced device.">gko::DpcppExecutor</a> which runs the code on a NVIDIA, AMD and Intel GPUs, respectively. </p><dl class="section note"><dt>Note</dt><dd>With the help of C++, you see that you only ever need to change the executor and all the other functions/ routines within Ginkgo should automatically work and run on the executor with any other changes.</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> executor_string = argc &gt;= 2 ? argv[1] : <span class="stringliteral">&quot;reference&quot;</span>;</div>
<div class="line">std::map&lt;std::string, std::function&lt;std::shared_ptr&lt;gko::Executor&gt;()&gt;&gt;</div>
<div class="line">    exec_map{</div>
<div class="line">        {<span class="stringliteral">&quot;omp&quot;</span>, [] { <span class="keywordflow">return</span> <a class="code" href="classgko_1_1OmpExecutor.html#a8930142a1913bcbcac4fb6c917f930d9">gko::OmpExecutor::create</a>(); }},</div>
<div class="line">        {<span class="stringliteral">&quot;cuda&quot;</span>,</div>
<div class="line">         [] {</div>
<div class="line">             <span class="keywordflow">return</span> <a class="code" href="classgko_1_1CudaExecutor.html#a6c423656c7c0eb53810cb77bb4a66d15">gko::CudaExecutor::create</a>(0,</div>
<div class="line">                                              <a class="code" href="classgko_1_1OmpExecutor.html#a8930142a1913bcbcac4fb6c917f930d9">gko::OmpExecutor::create</a>());</div>
<div class="line">         }},</div>
<div class="line">        {<span class="stringliteral">&quot;hip&quot;</span>,</div>
<div class="line">         [] {</div>
<div class="line">             <span class="keywordflow">return</span> <a class="code" href="classgko_1_1HipExecutor.html#aa0701fe1303e03a8331da7e95008100d">gko::HipExecutor::create</a>(0, <a class="code" href="classgko_1_1OmpExecutor.html#a8930142a1913bcbcac4fb6c917f930d9">gko::OmpExecutor::create</a>());</div>
<div class="line">         }},</div>
<div class="line">        {<span class="stringliteral">&quot;dpcpp&quot;</span>,</div>
<div class="line">         [] {</div>
<div class="line">             <span class="keywordflow">return</span> <a class="code" href="classgko_1_1DpcppExecutor.html#ae9b875dfe3af7f3f3f24071bfb2f895e">gko::DpcppExecutor::create</a>(0,</div>
<div class="line">                                               <a class="code" href="classgko_1_1OmpExecutor.html#a8930142a1913bcbcac4fb6c917f930d9">gko::OmpExecutor::create</a>());</div>
<div class="line">         }},</div>
<div class="line">        {<span class="stringliteral">&quot;reference&quot;</span>, [] { <span class="keywordflow">return</span> gko::ReferenceExecutor::create(); }}};</div>
</div><!-- fragment --><p>executor where Ginkgo will perform the computation</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> exec = exec_map.at(executor_string)();  <span class="comment">// throws if not valid</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <a class="code" href="namespacegko.html#a6e5c95df0ae4e47aab2f604a22d98ee7">size_type</a> num_systems = argc &gt;= 3 ? std::atoi(argv[2]) : 2;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> num_rows = argc &gt;= 4 ? std::atoi(argv[3]) : 32;  <span class="comment">// per system</span></div>
</div><!-- fragment --><p>Whether to print the residuals or not.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">bool</span> print_residuals =</div>
<div class="line">    argc &gt;= 5 ? (std::string(argv[4]) == <span class="stringliteral">&quot;true&quot;</span>) : <span class="keyword">false</span>;</div>
</div><!-- fragment --><p>The number of repetitions for the timing.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> num_reps = argc &gt;= 6 ? std::atoi(argv[5]) : 20;</div>
</div><!-- fragment --><p><a class="anchor" id="Generatedata"></a> </p><h3>Generate data</h3>
<p>The "application" generates the batch of linear systems on the device</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> appl_sys = appl_generate_system(num_rows, num_systems, exec);</div>
</div><!-- fragment --><p>Create batch_dim object to describe the dimensions of the batch matrix.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> batch_mat_size =</div>
<div class="line">    <a class="code" href="structgko_1_1batch__dim.html">gko::batch_dim&lt;2&gt;</a>(num_systems, <a class="code" href="structgko_1_1dim.html">gko::dim&lt;2&gt;</a>(num_rows, num_rows));</div>
<div class="line"><span class="keyword">auto</span> batch_vec_size =</div>
<div class="line">    <a class="code" href="structgko_1_1batch__dim.html">gko::batch_dim&lt;2&gt;</a>(num_systems, <a class="code" href="structgko_1_1dim.html">gko::dim&lt;2&gt;</a>(num_rows, 1));</div>
</div><!-- fragment --><p><a class="anchor" id="Useofapplicationallocatedmemory"></a> </p><h3>Use of application-allocated memory</h3>
<p>We can either work on the existing memory allocated in the application, or we can copy it for the linear solve. Ginkgo expects the nonzero values for all the small matrices to be allocated contiguously, one matrix after the other.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> vals_view = <a class="code" href="classgko_1_1array.html#a4d77553dfcc0c30dd7fff9c20886e94e">gko::array&lt;value_type&gt;::const_view</a>(</div>
<div class="line">    exec, num_systems * appl_sys.nnz, appl_sys.all_values);</div>
<div class="line"><span class="keyword">auto</span> rowptrs_view = <a class="code" href="classgko_1_1array.html#a4d77553dfcc0c30dd7fff9c20886e94e">gko::array&lt;index_type&gt;::const_view</a>(exec, num_rows + 1,</div>
<div class="line">                                                       appl_sys.row_ptrs);</div>
<div class="line"><span class="keyword">auto</span> colidxs_view = <a class="code" href="classgko_1_1array.html#a4d77553dfcc0c30dd7fff9c20886e94e">gko::array&lt;index_type&gt;::const_view</a>(exec, appl_sys.nnz,</div>
<div class="line">                                                       appl_sys.col_idxs);</div>
<div class="line"><span class="keyword">auto</span> A = <a class="code" href="namespacegko.html#a3ce296f73db0ff398bdea6009a3a5c58">gko::share</a>(mtx_type::create_const(</div>
<div class="line">    exec, batch_mat_size, std::move(vals_view), std::move(colidxs_view),</div>
<div class="line">    std::move(rowptrs_view)));</div>
</div><!-- fragment --><p><a class="anchor" id="RHSandsolutionvectors"></a> </p><h3>RHS and solution vectors</h3>
<p>batch_stride object specifies the access stride within the individual matrices (vectors) in the batch. In this case, we specify a stride of 1 as the common value for all the matrices. Create RHS, again reusing application allocation</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> b_view = <a class="code" href="classgko_1_1array.html#a4d77553dfcc0c30dd7fff9c20886e94e">gko::array&lt;value_type&gt;::const_view</a>(</div>
<div class="line">    exec, num_systems * num_rows, appl_sys.all_rhs);</div>
<div class="line"><span class="keyword">auto</span> b = vec_type::create_const(exec, batch_vec_size, std::move(b_view));</div>
</div><!-- fragment --><p>Create initial guess as 0 and copy to device</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> x = vec_type::create(exec);</div>
<div class="line"><span class="keyword">auto</span> host_x = vec_type::create(exec-&gt;get_master(), batch_vec_size);</div>
<div class="line"><span class="keywordflow">for</span> (size_type isys = 0; isys &lt; num_systems; isys++) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> irow = 0; irow &lt; num_rows; irow++) {</div>
<div class="line">        host_x-&gt;at(isys, irow, 0) = gko::zero&lt;value_type&gt;();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line">x-&gt;copy_from(host_x.get());</div>
</div><!-- fragment --><p><a class="anchor" id="Createthebatchsolverfactory"></a> </p><h3>Create the batch solver factory</h3>
<div class="fragment"><div class="line"><span class="keyword">const</span> real_type reduction_factor{1e-10};</div>
</div><!-- fragment --><p>Create a batched solver factory with relevant parameters.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code" href="namespacegko_1_1log.html#a15f71654c6c4f4defc95f9359343fa27a7cbf673200498a0d1324f4330825202a">solver</a> =</div>
<div class="line">    bicgstab::build()</div>
<div class="line">        .with_max_iterations(500)</div>
<div class="line">        .with_tolerance(reduction_factor)</div>
<div class="line">        .with_tolerance_type(gko::batch::stop::tolerance_type::relative)</div>
<div class="line">        .on(exec)</div>
<div class="line">        -&gt;generate(A);</div>
</div><!-- fragment --><p><a class="anchor" id="Batchlogger"></a> </p><h3>Batch logger</h3>
<p>Create a logger to obtain the iteration counts and "implicit" residual norms for every system after the solve.</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;const gko::batch::log::BatchConvergence&lt;value_type&gt;&gt;</div>
<div class="line">    logger = <a class="code" href="classgko_1_1batch_1_1log_1_1BatchConvergence.html#af941edb1eaf97bcb501f7628af27726a">gko::batch::log::BatchConvergence&lt;value_type&gt;::create</a>();</div>
</div><!-- fragment --><p><a class="anchor" id="Generateandsolve"></a> </p><h3>Generate and solve</h3>
<p>add the logger to the solver</p>
<div class="fragment"><div class="line"><a class="code" href="namespacegko_1_1log.html#a15f71654c6c4f4defc95f9359343fa27a7cbf673200498a0d1324f4330825202a">solver</a>-&gt;add_logger(logger);</div>
</div><!-- fragment --><p>Solve the batch system</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> x_clone = <a class="code" href="namespacegko.html#a1beb80750459e4201aa9d882d2d074c3">gko::clone</a>(x);</div>
</div><!-- fragment --><p>Warmup</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i) {</div>
<div class="line">    x_clone-&gt;copy_from(x.get());</div>
<div class="line">    <a class="code" href="namespacegko_1_1log.html#a15f71654c6c4f4defc95f9359343fa27a7cbf673200498a0d1324f4330825202a">solver</a>-&gt;apply(b, x_clone);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span> apply_time = 0.0;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; num_reps; ++i) {</div>
<div class="line">    x_clone-&gt;copy_from(x.get());</div>
<div class="line">    exec-&gt;synchronize();</div>
<div class="line">    std::chrono::steady_clock::time_point t1 =</div>
<div class="line">        std::chrono::steady_clock::now();</div>
<div class="line">    <a class="code" href="namespacegko_1_1log.html#a15f71654c6c4f4defc95f9359343fa27a7cbf673200498a0d1324f4330825202a">solver</a>-&gt;apply(b, x_clone);</div>
<div class="line">    exec-&gt;synchronize();</div>
<div class="line">    std::chrono::steady_clock::time_point t2 =</div>
<div class="line">        std::chrono::steady_clock::now();</div>
<div class="line">    <span class="keyword">auto</span> time_span =</div>
<div class="line">        std::chrono::duration_cast&lt;std::chrono::duration&lt;double&gt;&gt;(t2 - t1);</div>
<div class="line">    apply_time += time_span.count();</div>
<div class="line">}</div>
<div class="line">x-&gt;copy_from(x_clone.get());</div>
</div><!-- fragment --><p>This is not necessary, but one might want to remove the logger before the next solve using the same solver object.</p>
<div class="fragment"><div class="line"><a class="code" href="namespacegko_1_1log.html#a15f71654c6c4f4defc95f9359343fa27a7cbf673200498a0d1324f4330825202a">solver</a>-&gt;remove_logger(logger.get());</div>
</div><!-- fragment --><p><a class="anchor" id="Checkresult"></a> </p><h3>Check result</h3>
<p>Compute norm of RHS on the device and automatically copy to host</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> norm_dim = <a class="code" href="structgko_1_1batch__dim.html">gko::batch_dim&lt;2&gt;</a>(num_systems, <a class="code" href="structgko_1_1dim.html">gko::dim&lt;2&gt;</a>(1, 1));</div>
<div class="line"><span class="keyword">auto</span> host_b_norm = real_vec_type::create(exec-&gt;get_master(), norm_dim);</div>
<div class="line">host_b_norm-&gt;fill(0.0);</div>
<div class="line"> </div>
<div class="line">b-&gt;compute_norm2(host_b_norm);</div>
</div><!-- fragment --><p>we need constants on the device</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code" href="namespacegko.html#a0059e27f8f4bc348ff65c1e60caf47c8">one</a> = vec_type::create(exec, norm_dim);</div>
<div class="line"><a class="code" href="namespacegko.html#a0059e27f8f4bc348ff65c1e60caf47c8">one</a>-&gt;fill(1.0);</div>
<div class="line"><span class="keyword">auto</span> neg_one = vec_type::create(exec, norm_dim);</div>
<div class="line">neg_one-&gt;fill(-1.0);</div>
</div><!-- fragment --><p>allocate and compute the residual</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> res = vec_type::create(exec, batch_vec_size);</div>
<div class="line">res-&gt;copy_from(b);</div>
<div class="line">A-&gt;apply(one, x, neg_one, res);</div>
</div><!-- fragment --><p>allocate and compute residual norm</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> host_res_norm = real_vec_type::create(exec-&gt;get_master(), norm_dim);</div>
<div class="line">host_res_norm-&gt;fill(0.0);</div>
<div class="line">res-&gt;compute_norm2(host_res_norm);</div>
<div class="line"><span class="keyword">auto</span> host_log_resid = <a class="code" href="namespacegko.html#a7e65327b79b773f00f5bf4a480dd2066">gko::make_temporary_clone</a>(</div>
<div class="line">    exec-&gt;get_master(), &amp;logger-&gt;get_residual_norm());</div>
<div class="line"><span class="keyword">auto</span> host_log_iters = <a class="code" href="namespacegko.html#a7e65327b79b773f00f5bf4a480dd2066">gko::make_temporary_clone</a>(</div>
<div class="line">    exec-&gt;get_master(), &amp;logger-&gt;get_num_iterations());</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (print_residuals) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Residual norm sqrt(r^T r):\n&quot;</span>;</div>
</div><!-- fragment --><p>"unbatch" converts a batch object into a vector of objects of the corresponding single type, eg. batch::matrix::Dense --&gt; std::vector&lt;Dense&gt;.</p>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> unb_res = detail::unbatch(host_res_norm.get());</div>
<div class="line">    <span class="keyword">auto</span> unb_bnorm = detail::unbatch(host_b_norm.get());</div>
<div class="line">    <span class="keywordflow">for</span> (size_type i = 0; i &lt; num_systems; ++i) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot; System no. &quot;</span> &lt;&lt; i</div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot;: residual norm = &quot;</span> &lt;&lt; unb_res[i]-&gt;at(0, 0)</div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot;, implicit residual norm = &quot;</span></div>
<div class="line">                  &lt;&lt; host_log_resid-&gt;get_const_data()[i]</div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot;, iterations = &quot;</span></div>
<div class="line">                  &lt;&lt; host_log_iters-&gt;get_const_data()[i] &lt;&lt; std::endl;</div>
<div class="line">        <span class="keyword">const</span> real_type relresnorm =</div>
<div class="line">            unb_res[i]-&gt;at(0, 0) / unb_bnorm[i]-&gt;at(0, 0);</div>
<div class="line">        <span class="keywordflow">if</span> (!(relresnorm &lt;= reduction_factor)) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;System &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; converged only to &quot;</span></div>
<div class="line">                      &lt;&lt; relresnorm &lt;&lt; <span class="stringliteral">&quot; relative residual.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Solver type: &quot;</span></div>
<div class="line">          &lt;&lt; <span class="stringliteral">&quot;batch::bicgstab&quot;</span></div>
<div class="line">          &lt;&lt; <span class="stringliteral">&quot;\nMatrix size: &quot;</span> &lt;&lt; A-&gt;get_common_size()</div>
<div class="line">          &lt;&lt; <span class="stringliteral">&quot;\nNum batch entries: &quot;</span> &lt;&lt; A-&gt;get_num_batch_items()</div>
<div class="line">          &lt;&lt; <span class="stringliteral">&quot;\nEntire solve took: &quot;</span> &lt;&lt; apply_time / num_reps &lt;&lt; <span class="stringliteral">&quot; seconds.&quot;</span></div>
<div class="line">          &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>Ginkgo objects are cleaned up automatically; but the "application" still needs to clean up its data in this case.</p>
<div class="fragment"><div class="line">    appl_clean_up(appl_sys, exec);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Generate the matrix and the vectors. This function emulates the generation of the data from the application.</p>
<div class="fragment"><div class="line">ApplSysData appl_generate_system(<span class="keyword">const</span> <span class="keywordtype">int</span> nrows, <span class="keyword">const</span> size_type nsystems,</div>
<div class="line">                                 std::shared_ptr&lt;gko::Executor&gt; exec)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> nnz = nrows * 3 - 2;</div>
<div class="line">    std::default_random_engine rgen(15);</div>
<div class="line">    std::normal_distribution&lt;real_type&gt; distb(0.5, 0.1);</div>
<div class="line">    std::vector&lt;real_type&gt; spacings(nsystems * nrows);</div>
<div class="line">    std::generate(spacings.begin(), spacings.end(),</div>
<div class="line">                  [&amp;]() { <span class="keywordflow">return</span> distb(rgen); });</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;value_type&gt; allvalues(nnz * nsystems);</div>
<div class="line">    <span class="keywordflow">for</span> (size_type isys = 0; isys &lt; nsystems; isys++) {</div>
<div class="line">        allvalues.at(isys * nnz) = 2.0 / spacings.at(isys * nrows);</div>
<div class="line">        allvalues.at(isys * nnz + 1) = -1.0;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> irow = 0; irow &lt; nrows - 2; irow++) {</div>
<div class="line">            allvalues.at(isys * nnz + 2 + irow * 3) = -1.0;</div>
<div class="line">            allvalues.at(isys * nnz + 2 + irow * 3 + 1) =</div>
<div class="line">                2.0 / spacings.at(isys * nrows + irow + 1);</div>
<div class="line">            allvalues.at(isys * nnz + 2 + irow * 3 + 2) = -1.0;</div>
<div class="line">        }</div>
<div class="line">        allvalues.at(isys * nnz + 2 + (nrows - 2) * 3) = -1.0;</div>
<div class="line">        allvalues.at(isys * nnz + 2 + (nrows - 2) * 3 + 1) =</div>
<div class="line">            2.0 / spacings.at((isys + 1) * nrows - 1);</div>
<div class="line">        assert(isys * nnz + 2 + (nrows - 2) * 3 + 2 == (isys + 1) * nnz);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;index_type&gt; rowptrs(nrows + 1);</div>
<div class="line">    rowptrs.at(0) = 0;</div>
<div class="line">    rowptrs.at(1) = 2;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 2; i &lt; nrows; i++) {</div>
<div class="line">        rowptrs.at(i) = rowptrs.at(i - 1) + 3;</div>
<div class="line">    }</div>
<div class="line">    rowptrs.at(nrows) = rowptrs.at(nrows - 1) + 2;</div>
<div class="line">    assert(rowptrs.at(nrows) == nnz);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;index_type&gt; colidxs(nnz);</div>
<div class="line">    colidxs.at(0) = 0;</div>
<div class="line">    colidxs.at(1) = 1;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> nnz_per_row = 3;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> irow = 1; irow &lt; nrows - 1; irow++) {</div>
<div class="line">        colidxs.at(2 + (irow - 1) * nnz_per_row) = irow - 1;</div>
<div class="line">        colidxs.at(2 + (irow - 1) * nnz_per_row + 1) = irow;</div>
<div class="line">        colidxs.at(2 + (irow - 1) * nnz_per_row + 2) = irow + 1;</div>
<div class="line">    }</div>
<div class="line">    colidxs.at(2 + (nrows - 2) * nnz_per_row) = nrows - 2;</div>
<div class="line">    colidxs.at(2 + (nrows - 2) * nnz_per_row + 1) = nrows - 1;</div>
<div class="line">    assert(2 + (nrows - 2) * nnz_per_row + 1 == nnz - 1);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;value_type&gt; allb(nrows * nsystems);</div>
<div class="line">    <span class="keywordflow">for</span> (size_type isys = 0; isys &lt; nsystems; isys++) {</div>
<div class="line">        <span class="keyword">const</span> value_type bval = distb(rgen);</div>
<div class="line">        std::fill(allb.begin() + isys * nrows,</div>
<div class="line">                  allb.begin() + (isys + 1) * nrows, bval);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    index_type* <span class="keyword">const</span> row_ptrs = exec-&gt;alloc&lt;index_type&gt;(nrows + 1);</div>
<div class="line">    exec-&gt;copy_from(exec-&gt;get_master().get(), static_cast&lt;size_type&gt;(nrows + 1),</div>
<div class="line">                    rowptrs.data(), row_ptrs);</div>
<div class="line">    index_type* <span class="keyword">const</span> col_idxs = exec-&gt;alloc&lt;index_type&gt;(nnz);</div>
<div class="line">    exec-&gt;copy_from(exec-&gt;get_master().get(), static_cast&lt;size_type&gt;(nnz),</div>
<div class="line">                    colidxs.data(), col_idxs);</div>
<div class="line">    value_type* <span class="keyword">const</span> all_values = exec-&gt;alloc&lt;value_type&gt;(nsystems * nnz);</div>
<div class="line">    exec-&gt;copy_from(exec-&gt;get_master().get(), nsystems * nnz, allvalues.data(),</div>
<div class="line">                    all_values);</div>
<div class="line">    value_type* <span class="keyword">const</span> all_b = exec-&gt;alloc&lt;value_type&gt;(nsystems * nrows);</div>
<div class="line">    exec-&gt;copy_from(exec-&gt;get_master().get(), nsystems * nrows, allb.data(),</div>
<div class="line">                    all_b);</div>
<div class="line">    <span class="keywordflow">return</span> {nsystems, nrows, nnz, row_ptrs, col_idxs, all_values, all_b};</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> appl_clean_up(ApplSysData&amp; appl_data, std::shared_ptr&lt;gko::Executor&gt; exec)</div>
<div class="line">{</div>
</div><!-- fragment --><p>In general, the application would control non-const pointers; the const casts below would not be needed.</p>
<div class="fragment"><div class="line">    exec-&gt;free(const_cast&lt;index_type*&gt;(appl_data.row_ptrs));</div>
<div class="line">    exec-&gt;free(const_cast&lt;index_type*&gt;(appl_data.col_idxs));</div>
<div class="line">    exec-&gt;free(const_cast&lt;value_type*&gt;(appl_data.all_values));</div>
<div class="line">    exec-&gt;free(const_cast&lt;value_type*&gt;(appl_data.all_rhs));</div>
<div class="line">}</div>
</div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The following is the expected result on the reference executor:</p>
<div class="fragment"><div class="line">Solver type: batch::bicgstab</div>
<div class="line">Matrix size: (32, 32)</div>
<div class="line">Num batch entries: 2</div>
<div class="line">Entire solve took: 2.18558e-05 seconds.</div>
</div><!-- fragment --><p><a class="anchor" id="Commentsaboutprogramminganddebugging"></a></p><h3>Comments about programming and debugging </h3>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;random&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;ginkgo/ginkgo.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> value_type = double;</div>
<div class="line"><span class="keyword">using</span> real_type = <a class="code" href="namespacegko.html#afd46d554050c4ae90e84ea4fcd9a41f3">gko::remove_complex&lt;value_type&gt;</a>;</div>
<div class="line"><span class="keyword">using</span> index_type = int;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="namespacegko.html#a6e5c95df0ae4e47aab2f604a22d98ee7">size_type</a> = <a class="code" href="namespacegko.html#a6e5c95df0ae4e47aab2f604a22d98ee7">gko::size_type</a>;</div>
<div class="line"><span class="keyword">using</span> vec_type = <a class="code" href="classgko_1_1batch_1_1MultiVector.html">gko::batch::MultiVector&lt;value_type&gt;</a>;</div>
<div class="line"><span class="keyword">using</span> real_vec_type = <a class="code" href="classgko_1_1batch_1_1MultiVector.html">gko::batch::MultiVector&lt;real_type&gt;</a>;</div>
<div class="line"><span class="keyword">using</span> mtx_type = <a class="code" href="classgko_1_1batch_1_1matrix_1_1Csr.html">gko::batch::matrix::Csr&lt;value_type, index_type&gt;</a>;</div>
<div class="line"><span class="keyword">using</span> bicgstab = <a class="code" href="classgko_1_1batch_1_1solver_1_1Bicgstab.html">gko::batch::solver::Bicgstab&lt;value_type&gt;</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>detail {</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputType&gt;</div>
<div class="line"><span class="keyword">auto</span> unbatch(<span class="keyword">const</span> InputType* batch_object)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> unbatched_mats =</div>
<div class="line">        std::vector&lt;std::unique_ptr&lt;typename InputType::unbatch_type&gt;&gt;{};</div>
<div class="line">    <span class="keywordflow">for</span> (size_type b = 0; b &lt; batch_object-&gt;get_num_batch_items(); ++b) {</div>
<div class="line">        unbatched_mats.emplace_back(</div>
<div class="line">            batch_object-&gt;create_const_view_for_item(b)-&gt;clone());</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> unbatched_mats;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">}  <span class="comment">// namespace detail</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>ApplSysData {</div>
<div class="line">    <a class="code" href="namespacegko.html#a6e5c95df0ae4e47aab2f604a22d98ee7">size_type</a> nsystems;</div>
<div class="line">    <span class="keywordtype">int</span> nrows;</div>
<div class="line">    <span class="keywordtype">int</span> nnz;</div>
<div class="line">    <span class="keyword">const</span> index_type* row_ptrs;</div>
<div class="line">    <span class="keyword">const</span> index_type* col_idxs;</div>
<div class="line">    <span class="keyword">const</span> value_type* all_values;</div>
<div class="line">    <span class="keyword">const</span> value_type* all_rhs;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * Generates a batch of tridiagonal systems.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * @param nrows  Number of rows in each system.</span></div>
<div class="line"><span class="comment"> * @param nsystems  Number of systems in the batch.</span></div>
<div class="line"><span class="comment"> * @param exec  The device executor to use for the solver.</span></div>
<div class="line"><span class="comment"> * @note  Normally, the application may not deal with Ginkgo executors, nor do</span></div>
<div class="line"><span class="comment"> * we need it to. Here, we use the executor for backend-independent device</span></div>
<div class="line"><span class="comment"> * memory allocation. The application, for example, might assume Hip (for AMD</span></div>
<div class="line"><span class="comment"> * GPUs) and use `hipMalloc` directly.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">ApplSysData appl_generate_system(<span class="keyword">const</span> <span class="keywordtype">int</span> nrows, <span class="keyword">const</span> size_type nsystems,</div>
<div class="line">                                 std::shared_ptr&lt;gko::Executor&gt; exec);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> appl_clean_up(ApplSysData&amp; appl_data, std::shared_ptr&lt;gko::Executor&gt; exec);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; <a class="code" href="classgko_1_1version__info.html#a6daeb8a087cfb57fa055526fc133d8eb">gko::version_info::get</a>() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (argc == 2 &amp;&amp; (std::string(argv[1]) == <span class="stringliteral">&quot;--help&quot;</span>)) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Usage: &quot;</span> &lt;&lt; argv[0]</div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot; [executor] [num_systems] [num_rows] [print_residuals] &quot;</span></div>
<div class="line">                     <span class="stringliteral">&quot;[num_reps]&quot;</span></div>
<div class="line">                  &lt;&lt; std::endl;</div>
<div class="line">        std::exit(-1);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> executor_string = argc &gt;= 2 ? argv[1] : <span class="stringliteral">&quot;reference&quot;</span>;</div>
<div class="line">    std::map&lt;std::string, std::function&lt;std::shared_ptr&lt;gko::Executor&gt;()&gt;&gt;</div>
<div class="line">        exec_map{</div>
<div class="line">            {<span class="stringliteral">&quot;omp&quot;</span>, [] { <span class="keywordflow">return</span> <a class="code" href="classgko_1_1OmpExecutor.html#a8930142a1913bcbcac4fb6c917f930d9">gko::OmpExecutor::create</a>(); }},</div>
<div class="line">            {<span class="stringliteral">&quot;cuda&quot;</span>,</div>
<div class="line">             [] {</div>
<div class="line">                 <span class="keywordflow">return</span> <a class="code" href="classgko_1_1CudaExecutor.html#a6c423656c7c0eb53810cb77bb4a66d15">gko::CudaExecutor::create</a>(0,</div>
<div class="line">                                                  <a class="code" href="classgko_1_1OmpExecutor.html#a8930142a1913bcbcac4fb6c917f930d9">gko::OmpExecutor::create</a>());</div>
<div class="line">             }},</div>
<div class="line">            {<span class="stringliteral">&quot;hip&quot;</span>,</div>
<div class="line">             [] {</div>
<div class="line">                 <span class="keywordflow">return</span> <a class="code" href="classgko_1_1HipExecutor.html#aa0701fe1303e03a8331da7e95008100d">gko::HipExecutor::create</a>(0, <a class="code" href="classgko_1_1OmpExecutor.html#a8930142a1913bcbcac4fb6c917f930d9">gko::OmpExecutor::create</a>());</div>
<div class="line">             }},</div>
<div class="line">            {<span class="stringliteral">&quot;dpcpp&quot;</span>,</div>
<div class="line">             [] {</div>
<div class="line">                 <span class="keywordflow">return</span> <a class="code" href="classgko_1_1DpcppExecutor.html#ae9b875dfe3af7f3f3f24071bfb2f895e">gko::DpcppExecutor::create</a>(0,</div>
<div class="line">                                                   <a class="code" href="classgko_1_1OmpExecutor.html#a8930142a1913bcbcac4fb6c917f930d9">gko::OmpExecutor::create</a>());</div>
<div class="line">             }},</div>
<div class="line">            {<span class="stringliteral">&quot;reference&quot;</span>, [] { <span class="keywordflow">return</span> gko::ReferenceExecutor::create(); }}};</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> exec = exec_map.at(executor_string)();  <span class="comment">// throws if not valid</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="namespacegko.html#a6e5c95df0ae4e47aab2f604a22d98ee7">size_type</a> num_systems = argc &gt;= 3 ? std::atoi(argv[2]) : 2;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> num_rows = argc &gt;= 4 ? std::atoi(argv[3]) : 32;  <span class="comment">// per system</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> print_residuals =</div>
<div class="line">        argc &gt;= 5 ? (std::string(argv[4]) == <span class="stringliteral">&quot;true&quot;</span>) : <span class="keyword">false</span>;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> num_reps = argc &gt;= 6 ? std::atoi(argv[5]) : 20;</div>
<div class="line">    <span class="keyword">auto</span> appl_sys = appl_generate_system(num_rows, num_systems, exec);</div>
<div class="line">    <span class="keyword">auto</span> batch_mat_size =</div>
<div class="line">        <a class="code" href="structgko_1_1batch__dim.html">gko::batch_dim&lt;2&gt;</a>(num_systems, <a class="code" href="structgko_1_1dim.html">gko::dim&lt;2&gt;</a>(num_rows, num_rows));</div>
<div class="line">    <span class="keyword">auto</span> batch_vec_size =</div>
<div class="line">        <a class="code" href="structgko_1_1batch__dim.html">gko::batch_dim&lt;2&gt;</a>(num_systems, <a class="code" href="structgko_1_1dim.html">gko::dim&lt;2&gt;</a>(num_rows, 1));</div>
<div class="line">    <span class="keyword">auto</span> vals_view = <a class="code" href="classgko_1_1array.html#a4d77553dfcc0c30dd7fff9c20886e94e">gko::array&lt;value_type&gt;::const_view</a>(</div>
<div class="line">        exec, num_systems * appl_sys.nnz, appl_sys.all_values);</div>
<div class="line">    <span class="keyword">auto</span> rowptrs_view = <a class="code" href="classgko_1_1array.html#a4d77553dfcc0c30dd7fff9c20886e94e">gko::array&lt;index_type&gt;::const_view</a>(exec, num_rows + 1,</div>
<div class="line">                                                           appl_sys.row_ptrs);</div>
<div class="line">    <span class="keyword">auto</span> colidxs_view = <a class="code" href="classgko_1_1array.html#a4d77553dfcc0c30dd7fff9c20886e94e">gko::array&lt;index_type&gt;::const_view</a>(exec, appl_sys.nnz,</div>
<div class="line">                                                           appl_sys.col_idxs);</div>
<div class="line">    <span class="keyword">auto</span> A = <a class="code" href="namespacegko.html#a3ce296f73db0ff398bdea6009a3a5c58">gko::share</a>(mtx_type::create_const(</div>
<div class="line">        exec, batch_mat_size, std::move(vals_view), std::move(colidxs_view),</div>
<div class="line">        std::move(rowptrs_view)));</div>
<div class="line">    <span class="keyword">auto</span> b_view = <a class="code" href="classgko_1_1array.html#a4d77553dfcc0c30dd7fff9c20886e94e">gko::array&lt;value_type&gt;::const_view</a>(</div>
<div class="line">        exec, num_systems * num_rows, appl_sys.all_rhs);</div>
<div class="line">    <span class="keyword">auto</span> b = vec_type::create_const(exec, batch_vec_size, std::move(b_view));</div>
<div class="line">    <span class="keyword">auto</span> x = vec_type::create(exec);</div>
<div class="line">    <span class="keyword">auto</span> host_x = vec_type::create(exec-&gt;get_master(), batch_vec_size);</div>
<div class="line">    <span class="keywordflow">for</span> (size_type isys = 0; isys &lt; num_systems; isys++) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> irow = 0; irow &lt; num_rows; irow++) {</div>
<div class="line">            host_x-&gt;at(isys, irow, 0) = gko::zero&lt;value_type&gt;();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    x-&gt;copy_from(host_x.get());</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> real_type reduction_factor{1e-10};</div>
<div class="line">    <span class="keyword">auto</span> <a class="code" href="namespacegko_1_1log.html#a15f71654c6c4f4defc95f9359343fa27a7cbf673200498a0d1324f4330825202a">solver</a> =</div>
<div class="line">        bicgstab::build()</div>
<div class="line">            .with_max_iterations(500)</div>
<div class="line">            .with_tolerance(reduction_factor)</div>
<div class="line">            .with_tolerance_type(gko::batch::stop::tolerance_type::relative)</div>
<div class="line">            .on(exec)</div>
<div class="line">            -&gt;generate(A);</div>
<div class="line"> </div>
<div class="line">    std::shared_ptr&lt;const gko::batch::log::BatchConvergence&lt;value_type&gt;&gt;</div>
<div class="line">        logger = <a class="code" href="classgko_1_1batch_1_1log_1_1BatchConvergence.html#af941edb1eaf97bcb501f7628af27726a">gko::batch::log::BatchConvergence&lt;value_type&gt;::create</a>();</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="namespacegko_1_1log.html#a15f71654c6c4f4defc95f9359343fa27a7cbf673200498a0d1324f4330825202a">solver</a>-&gt;add_logger(logger);</div>
<div class="line">    <span class="keyword">auto</span> x_clone = <a class="code" href="namespacegko.html#a1beb80750459e4201aa9d882d2d074c3">gko::clone</a>(x);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i) {</div>
<div class="line">        x_clone-&gt;copy_from(x.get());</div>
<div class="line">        <a class="code" href="namespacegko_1_1log.html#a15f71654c6c4f4defc95f9359343fa27a7cbf673200498a0d1324f4330825202a">solver</a>-&gt;apply(b, x_clone);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> apply_time = 0.0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; num_reps; ++i) {</div>
<div class="line">        x_clone-&gt;copy_from(x.get());</div>
<div class="line">        exec-&gt;synchronize();</div>
<div class="line">        std::chrono::steady_clock::time_point t1 =</div>
<div class="line">            std::chrono::steady_clock::now();</div>
<div class="line">        <a class="code" href="namespacegko_1_1log.html#a15f71654c6c4f4defc95f9359343fa27a7cbf673200498a0d1324f4330825202a">solver</a>-&gt;apply(b, x_clone);</div>
<div class="line">        exec-&gt;synchronize();</div>
<div class="line">        std::chrono::steady_clock::time_point t2 =</div>
<div class="line">            std::chrono::steady_clock::now();</div>
<div class="line">        <span class="keyword">auto</span> time_span =</div>
<div class="line">            std::chrono::duration_cast&lt;std::chrono::duration&lt;double&gt;&gt;(t2 - t1);</div>
<div class="line">        apply_time += time_span.count();</div>
<div class="line">    }</div>
<div class="line">    x-&gt;copy_from(x_clone.get());</div>
<div class="line">    <a class="code" href="namespacegko_1_1log.html#a15f71654c6c4f4defc95f9359343fa27a7cbf673200498a0d1324f4330825202a">solver</a>-&gt;remove_logger(logger.get());</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> norm_dim = <a class="code" href="structgko_1_1batch__dim.html">gko::batch_dim&lt;2&gt;</a>(num_systems, <a class="code" href="structgko_1_1dim.html">gko::dim&lt;2&gt;</a>(1, 1));</div>
<div class="line">    <span class="keyword">auto</span> host_b_norm = real_vec_type::create(exec-&gt;get_master(), norm_dim);</div>
<div class="line">    host_b_norm-&gt;fill(0.0);</div>
<div class="line"> </div>
<div class="line">    b-&gt;compute_norm2(host_b_norm);</div>
<div class="line">    <span class="keyword">auto</span> <a class="code" href="namespacegko.html#a0059e27f8f4bc348ff65c1e60caf47c8">one</a> = vec_type::create(exec, norm_dim);</div>
<div class="line">    <a class="code" href="namespacegko.html#a0059e27f8f4bc348ff65c1e60caf47c8">one</a>-&gt;fill(1.0);</div>
<div class="line">    <span class="keyword">auto</span> neg_one = vec_type::create(exec, norm_dim);</div>
<div class="line">    neg_one-&gt;fill(-1.0);</div>
<div class="line">    <span class="keyword">auto</span> res = vec_type::create(exec, batch_vec_size);</div>
<div class="line">    res-&gt;copy_from(b);</div>
<div class="line">    A-&gt;apply(one, x, neg_one, res);</div>
<div class="line">    <span class="keyword">auto</span> host_res_norm = real_vec_type::create(exec-&gt;get_master(), norm_dim);</div>
<div class="line">    host_res_norm-&gt;fill(0.0);</div>
<div class="line">    res-&gt;compute_norm2(host_res_norm);</div>
<div class="line">    <span class="keyword">auto</span> host_log_resid = <a class="code" href="namespacegko.html#a7e65327b79b773f00f5bf4a480dd2066">gko::make_temporary_clone</a>(</div>
<div class="line">        exec-&gt;get_master(), &amp;logger-&gt;get_residual_norm());</div>
<div class="line">    <span class="keyword">auto</span> host_log_iters = <a class="code" href="namespacegko.html#a7e65327b79b773f00f5bf4a480dd2066">gko::make_temporary_clone</a>(</div>
<div class="line">        exec-&gt;get_master(), &amp;logger-&gt;get_num_iterations());</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (print_residuals) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Residual norm sqrt(r^T r):\n&quot;</span>;</div>
<div class="line">        <span class="keyword">auto</span> unb_res = detail::unbatch(host_res_norm.get());</div>
<div class="line">        <span class="keyword">auto</span> unb_bnorm = detail::unbatch(host_b_norm.get());</div>
<div class="line">        <span class="keywordflow">for</span> (size_type i = 0; i &lt; num_systems; ++i) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot; System no. &quot;</span> &lt;&lt; i</div>
<div class="line">                      &lt;&lt; <span class="stringliteral">&quot;: residual norm = &quot;</span> &lt;&lt; unb_res[i]-&gt;at(0, 0)</div>
<div class="line">                      &lt;&lt; <span class="stringliteral">&quot;, implicit residual norm = &quot;</span></div>
<div class="line">                      &lt;&lt; host_log_resid-&gt;get_const_data()[i]</div>
<div class="line">                      &lt;&lt; <span class="stringliteral">&quot;, iterations = &quot;</span></div>
<div class="line">                      &lt;&lt; host_log_iters-&gt;get_const_data()[i] &lt;&lt; std::endl;</div>
<div class="line">            <span class="keyword">const</span> real_type relresnorm =</div>
<div class="line">                unb_res[i]-&gt;at(0, 0) / unb_bnorm[i]-&gt;at(0, 0);</div>
<div class="line">            <span class="keywordflow">if</span> (!(relresnorm &lt;= reduction_factor)) {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;System &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; converged only to &quot;</span></div>
<div class="line">                          &lt;&lt; relresnorm &lt;&lt; <span class="stringliteral">&quot; relative residual.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Solver type: &quot;</span></div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;batch::bicgstab&quot;</span></div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;\nMatrix size: &quot;</span> &lt;&lt; A-&gt;get_common_size()</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;\nNum batch entries: &quot;</span> &lt;&lt; A-&gt;get_num_batch_items()</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;\nEntire solve took: &quot;</span> &lt;&lt; apply_time / num_reps &lt;&lt; <span class="stringliteral">&quot; seconds.&quot;</span></div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    appl_clean_up(appl_sys, exec);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">ApplSysData appl_generate_system(<span class="keyword">const</span> <span class="keywordtype">int</span> nrows, <span class="keyword">const</span> size_type nsystems,</div>
<div class="line">                                 std::shared_ptr&lt;gko::Executor&gt; exec)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> nnz = nrows * 3 - 2;</div>
<div class="line">    std::default_random_engine rgen(15);</div>
<div class="line">    std::normal_distribution&lt;real_type&gt; distb(0.5, 0.1);</div>
<div class="line">    std::vector&lt;real_type&gt; spacings(nsystems * nrows);</div>
<div class="line">    std::generate(spacings.begin(), spacings.end(),</div>
<div class="line">                  [&amp;]() { <span class="keywordflow">return</span> distb(rgen); });</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;value_type&gt; allvalues(nnz * nsystems);</div>
<div class="line">    <span class="keywordflow">for</span> (size_type isys = 0; isys &lt; nsystems; isys++) {</div>
<div class="line">        allvalues.at(isys * nnz) = 2.0 / spacings.at(isys * nrows);</div>
<div class="line">        allvalues.at(isys * nnz + 1) = -1.0;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> irow = 0; irow &lt; nrows - 2; irow++) {</div>
<div class="line">            allvalues.at(isys * nnz + 2 + irow * 3) = -1.0;</div>
<div class="line">            allvalues.at(isys * nnz + 2 + irow * 3 + 1) =</div>
<div class="line">                2.0 / spacings.at(isys * nrows + irow + 1);</div>
<div class="line">            allvalues.at(isys * nnz + 2 + irow * 3 + 2) = -1.0;</div>
<div class="line">        }</div>
<div class="line">        allvalues.at(isys * nnz + 2 + (nrows - 2) * 3) = -1.0;</div>
<div class="line">        allvalues.at(isys * nnz + 2 + (nrows - 2) * 3 + 1) =</div>
<div class="line">            2.0 / spacings.at((isys + 1) * nrows - 1);</div>
<div class="line">        assert(isys * nnz + 2 + (nrows - 2) * 3 + 2 == (isys + 1) * nnz);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;index_type&gt; rowptrs(nrows + 1);</div>
<div class="line">    rowptrs.at(0) = 0;</div>
<div class="line">    rowptrs.at(1) = 2;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 2; i &lt; nrows; i++) {</div>
<div class="line">        rowptrs.at(i) = rowptrs.at(i - 1) + 3;</div>
<div class="line">    }</div>
<div class="line">    rowptrs.at(nrows) = rowptrs.at(nrows - 1) + 2;</div>
<div class="line">    assert(rowptrs.at(nrows) == nnz);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;index_type&gt; colidxs(nnz);</div>
<div class="line">    colidxs.at(0) = 0;</div>
<div class="line">    colidxs.at(1) = 1;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> nnz_per_row = 3;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> irow = 1; irow &lt; nrows - 1; irow++) {</div>
<div class="line">        colidxs.at(2 + (irow - 1) * nnz_per_row) = irow - 1;</div>
<div class="line">        colidxs.at(2 + (irow - 1) * nnz_per_row + 1) = irow;</div>
<div class="line">        colidxs.at(2 + (irow - 1) * nnz_per_row + 2) = irow + 1;</div>
<div class="line">    }</div>
<div class="line">    colidxs.at(2 + (nrows - 2) * nnz_per_row) = nrows - 2;</div>
<div class="line">    colidxs.at(2 + (nrows - 2) * nnz_per_row + 1) = nrows - 1;</div>
<div class="line">    assert(2 + (nrows - 2) * nnz_per_row + 1 == nnz - 1);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;value_type&gt; allb(nrows * nsystems);</div>
<div class="line">    <span class="keywordflow">for</span> (size_type isys = 0; isys &lt; nsystems; isys++) {</div>
<div class="line">        <span class="keyword">const</span> value_type bval = distb(rgen);</div>
<div class="line">        std::fill(allb.begin() + isys * nrows,</div>
<div class="line">                  allb.begin() + (isys + 1) * nrows, bval);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    index_type* <span class="keyword">const</span> row_ptrs = exec-&gt;alloc&lt;index_type&gt;(nrows + 1);</div>
<div class="line">    exec-&gt;copy_from(exec-&gt;get_master().get(), static_cast&lt;size_type&gt;(nrows + 1),</div>
<div class="line">                    rowptrs.data(), row_ptrs);</div>
<div class="line">    index_type* <span class="keyword">const</span> col_idxs = exec-&gt;alloc&lt;index_type&gt;(nnz);</div>
<div class="line">    exec-&gt;copy_from(exec-&gt;get_master().get(), static_cast&lt;size_type&gt;(nnz),</div>
<div class="line">                    colidxs.data(), col_idxs);</div>
<div class="line">    value_type* <span class="keyword">const</span> all_values = exec-&gt;alloc&lt;value_type&gt;(nsystems * nnz);</div>
<div class="line">    exec-&gt;copy_from(exec-&gt;get_master().get(), nsystems * nnz, allvalues.data(),</div>
<div class="line">                    all_values);</div>
<div class="line">    value_type* <span class="keyword">const</span> all_b = exec-&gt;alloc&lt;value_type&gt;(nsystems * nrows);</div>
<div class="line">    exec-&gt;copy_from(exec-&gt;get_master().get(), nsystems * nrows, allb.data(),</div>
<div class="line">                    all_b);</div>
<div class="line">    <span class="keywordflow">return</span> {nsystems, nrows, nnz, row_ptrs, col_idxs, all_values, all_b};</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> appl_clean_up(ApplSysData&amp; appl_data, std::shared_ptr&lt;gko::Executor&gt; exec)</div>
<div class="line">{</div>
<div class="line">    exec-&gt;free(const_cast&lt;index_type*&gt;(appl_data.row_ptrs));</div>
<div class="line">    exec-&gt;free(const_cast&lt;index_type*&gt;(appl_data.col_idxs));</div>
<div class="line">    exec-&gt;free(const_cast&lt;value_type*&gt;(appl_data.all_values));</div>
<div class="line">    exec-&gt;free(const_cast&lt;value_type*&gt;(appl_data.all_rhs));</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="anamespacegko_1_1log_html_a15f71654c6c4f4defc95f9359343fa27a7cbf673200498a0d1324f4330825202a"><div class="ttname"><a href="namespacegko_1_1log.html#a15f71654c6c4f4defc95f9359343fa27a7cbf673200498a0d1324f4330825202a">gko::log::profile_event_category::solver</a></div><div class="ttdoc">Solver events.</div></div>
<div class="ttc" id="anamespacegko_1_1matrix_html_ade1f3cdbf05032c2d681fa151de02972adf347a373b8f92aa0ae3dd920a5ec2f6"><div class="ttname"><a href="namespacegko_1_1matrix.html#ade1f3cdbf05032c2d681fa151de02972adf347a373b8f92aa0ae3dd920a5ec2f6">gko::matrix::permute_mode::rows</a></div><div class="ttdoc">The rows will be permuted.</div></div>
<div class="ttc" id="anamespacegko_html_a6e5c95df0ae4e47aab2f604a22d98ee7"><div class="ttname"><a href="namespacegko.html#a6e5c95df0ae4e47aab2f604a22d98ee7">gko::size_type</a></div><div class="ttdeci">std::size_t size_type</div><div class="ttdoc">Integral type used for allocation quantities.</div><div class="ttdef"><b>Definition:</b> types.hpp:108</div></div>
<div class="ttc" id="aclassgko_1_1batch_1_1log_1_1BatchConvergence_html_af941edb1eaf97bcb501f7628af27726a"><div class="ttname"><a href="classgko_1_1batch_1_1log_1_1BatchConvergence.html#af941edb1eaf97bcb501f7628af27726a">gko::batch::log::BatchConvergence::create</a></div><div class="ttdeci">static std::unique_ptr&lt; BatchConvergence &gt; create(const mask_type &amp;enabled_events=gko::log::Logger::batch_solver_completed_mask)</div><div class="ttdoc">Creates a convergence logger.</div><div class="ttdef"><b>Definition:</b> batch_logger.hpp:92</div></div>
<div class="ttc" id="aclassgko_1_1batch_1_1matrix_1_1Csr_html"><div class="ttname"><a href="classgko_1_1batch_1_1matrix_1_1Csr.html">gko::batch::matrix::Csr</a></div><div class="ttdoc">Csr is a general sparse matrix format that stores the column indices for each nonzero entry and a cum...</div><div class="ttdef"><b>Definition:</b> batch_csr.hpp:47</div></div>
<div class="ttc" id="aclassgko_1_1batch_1_1MultiVector_html"><div class="ttname"><a href="classgko_1_1batch_1_1MultiVector.html">gko::batch::MultiVector</a></div><div class="ttdoc">MultiVector stores multiple vectors in a batched fashion and is useful for batched operations.</div><div class="ttdef"><b>Definition:</b> batch_multi_vector.hpp:52</div></div>
<div class="ttc" id="anamespacegko_1_1log_html_a15f71654c6c4f4defc95f9359343fa27acd69b4957f06cd818d7bf3d61980e291"><div class="ttname"><a href="namespacegko_1_1log.html#a15f71654c6c4f4defc95f9359343fa27acd69b4957f06cd818d7bf3d61980e291">gko::log::profile_event_category::memory</a></div><div class="ttdoc">Memory allocation.</div></div>
<div class="ttc" id="anamespacegko_html_a1beb80750459e4201aa9d882d2d074c3"><div class="ttname"><a href="namespacegko.html#a1beb80750459e4201aa9d882d2d074c3">gko::clone</a></div><div class="ttdeci">detail::cloned_type&lt; Pointer &gt; clone(const Pointer &amp;p)</div><div class="ttdoc">Creates a unique clone of the object pointed to by p.</div><div class="ttdef"><b>Definition:</b> utils_helper.hpp:173</div></div>
<div class="ttc" id="aclassgko_1_1HipExecutor_html_aa0701fe1303e03a8331da7e95008100d"><div class="ttname"><a href="classgko_1_1HipExecutor.html#aa0701fe1303e03a8331da7e95008100d">gko::HipExecutor::create</a></div><div class="ttdeci">static std::shared_ptr&lt; HipExecutor &gt; create(int device_id, std::shared_ptr&lt; Executor &gt; master, bool device_reset, allocation_mode alloc_mode=default_hip_alloc_mode, CUstream_st *stream=nullptr)</div><div class="ttdoc">Creates a new HipExecutor.</div></div>
<div class="ttc" id="aclassgko_1_1version__info_html_a6daeb8a087cfb57fa055526fc133d8eb"><div class="ttname"><a href="classgko_1_1version__info.html#a6daeb8a087cfb57fa055526fc133d8eb">gko::version_info::get</a></div><div class="ttdeci">static const version_info &amp; get()</div><div class="ttdoc">Returns an instance of version_info.</div><div class="ttdef"><b>Definition:</b> version.hpp:139</div></div>
<div class="ttc" id="astructgko_1_1dim_html"><div class="ttname"><a href="structgko_1_1dim.html">gko::dim&lt; 2 &gt;</a></div></div>
<div class="ttc" id="astructgko_1_1batch__dim_html"><div class="ttname"><a href="structgko_1_1batch__dim.html">gko::batch_dim&lt; 2 &gt;</a></div></div>
<div class="ttc" id="anamespacegko_html_a3ce296f73db0ff398bdea6009a3a5c58"><div class="ttname"><a href="namespacegko.html#a3ce296f73db0ff398bdea6009a3a5c58">gko::share</a></div><div class="ttdeci">detail::shared_type&lt; OwningPointer &gt; share(OwningPointer &amp;&amp;p)</div><div class="ttdoc">Marks the object pointed to by p as shared.</div><div class="ttdef"><b>Definition:</b> utils_helper.hpp:224</div></div>
<div class="ttc" id="aclassgko_1_1batch_1_1solver_1_1Bicgstab_html"><div class="ttname"><a href="classgko_1_1batch_1_1solver_1_1Bicgstab.html">gko::batch::solver::Bicgstab</a></div><div class="ttdoc">BiCGSTAB or the Bi-Conjugate Gradient-Stabilized is a Krylov subspace solver.</div><div class="ttdef"><b>Definition:</b> batch_bicgstab.hpp:50</div></div>
<div class="ttc" id="aclassgko_1_1CudaExecutor_html_a6c423656c7c0eb53810cb77bb4a66d15"><div class="ttname"><a href="classgko_1_1CudaExecutor.html#a6c423656c7c0eb53810cb77bb4a66d15">gko::CudaExecutor::create</a></div><div class="ttdeci">static std::shared_ptr&lt; CudaExecutor &gt; create(int device_id, std::shared_ptr&lt; Executor &gt; master, bool device_reset, allocation_mode alloc_mode=default_cuda_alloc_mode, CUstream_st *stream=nullptr)</div><div class="ttdoc">Creates a new CudaExecutor.</div></div>
<div class="ttc" id="aclassgko_1_1OmpExecutor_html_a8930142a1913bcbcac4fb6c917f930d9"><div class="ttname"><a href="classgko_1_1OmpExecutor.html#a8930142a1913bcbcac4fb6c917f930d9">gko::OmpExecutor::create</a></div><div class="ttdeci">static std::shared_ptr&lt; OmpExecutor &gt; create(std::shared_ptr&lt; CpuAllocatorBase &gt; alloc=std::make_shared&lt; CpuAllocator &gt;())</div><div class="ttdoc">Creates a new OmpExecutor.</div><div class="ttdef"><b>Definition:</b> executor.hpp:1347</div></div>
<div class="ttc" id="aclassgko_1_1array_html_a4d77553dfcc0c30dd7fff9c20886e94e"><div class="ttname"><a href="classgko_1_1array.html#a4d77553dfcc0c30dd7fff9c20886e94e">gko::array::const_view</a></div><div class="ttdeci">static detail::const_array_view&lt; ValueType &gt; const_view(std::shared_ptr&lt; const Executor &gt; exec, size_type size, const value_type *data)</div><div class="ttdoc">Creates a constant (immutable) array from existing memory.</div><div class="ttdef"><b>Definition:</b> array.hpp:384</div></div>
<div class="ttc" id="anamespacegko_html_a7e65327b79b773f00f5bf4a480dd2066"><div class="ttname"><a href="namespacegko.html#a7e65327b79b773f00f5bf4a480dd2066">gko::make_temporary_clone</a></div><div class="ttdeci">detail::temporary_clone&lt; detail::pointee&lt; Ptr &gt; &gt; make_temporary_clone(std::shared_ptr&lt; const Executor &gt; exec, Ptr &amp;&amp;ptr)</div><div class="ttdoc">Creates a temporary_clone.</div><div class="ttdef"><b>Definition:</b> temporary_clone.hpp:208</div></div>
<div class="ttc" id="anamespacegko_html_afd46d554050c4ae90e84ea4fcd9a41f3"><div class="ttname"><a href="namespacegko.html#afd46d554050c4ae90e84ea4fcd9a41f3">gko::remove_complex</a></div><div class="ttdeci">typename detail::remove_complex_s&lt; T &gt;::type remove_complex</div><div class="ttdoc">Obtain the type which removed the complex of complex/scalar type or the template parameter of class b...</div><div class="ttdef"><b>Definition:</b> math.hpp:325</div></div>
<div class="ttc" id="aclassgko_1_1DpcppExecutor_html_ae9b875dfe3af7f3f3f24071bfb2f895e"><div class="ttname"><a href="classgko_1_1DpcppExecutor.html#ae9b875dfe3af7f3f3f24071bfb2f895e">gko::DpcppExecutor::create</a></div><div class="ttdeci">static std::shared_ptr&lt; DpcppExecutor &gt; create(int device_id, std::shared_ptr&lt; Executor &gt; master, std::string device_type=&quot;all&quot;, dpcpp_queue_property property=dpcpp_queue_property::in_order)</div><div class="ttdoc">Creates a new DpcppExecutor.</div></div>
<div class="ttc" id="anamespacegko_html_a0059e27f8f4bc348ff65c1e60caf47c8"><div class="ttname"><a href="namespacegko.html#a0059e27f8f4bc348ff65c1e60caf47c8">gko::one</a></div><div class="ttdeci">constexpr T one()</div><div class="ttdoc">Returns the multiplicative identity for T.</div><div class="ttdef"><b>Definition:</b> math.hpp:774</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
