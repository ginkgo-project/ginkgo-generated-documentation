Using and interfacing with a batched solver..

 \label{_Batched Solver}%
 \label{_Usingbatchedsolvers}%
\doxysection*{Using batched solvers}

This example shows how to use Ginkgo batched solvers with data coming from an application. The \char`\"{}application\char`\"{} in this case is just a function in the example itself; nevertheless, the steps to be taken are shown.

A `batch' here means a set of small linear systems that can be solved independently, but each system is too small to use an entire computing device. For now, a batch of sparse matrices is required to have a common sparsity pattern for all the matrices. \label{_CommProg}%
 \doxysection*{The commented program}

\label{_Includefiles}%
 \doxysubsubsection*{Include files}

This is the main ginkgo header file.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <ginkgo/ginkgo.hpp>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <fstream>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <map>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <random>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <string>}}
\end{DoxyCode}


\label{_Typealiasesforconvenience}%
 \doxysubsubsection*{Type aliases for convenience}

Use some shortcuts. In Ginkgo, vectors are seen as a \mbox{\hyperlink{classgko_1_1matrix_1_1Dense}{gko\+::matrix\+::\+Dense}} with one column/one row. The advantage of this concept is that using multiple vectors is a now a natural extension of adding columns/rows are necessary.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{using} value\_type = double;}
\DoxyCodeLine{\textcolor{keyword}{using} real\_type = \mbox{\hyperlink{namespacegko_afd46d554050c4ae90e84ea4fcd9a41f3}{gko::remove\_complex<value\_type>}};}
\DoxyCodeLine{\textcolor{keyword}{using} index\_type = int;}
\DoxyCodeLine{\textcolor{keyword}{using} \mbox{\hyperlink{namespacegko_a6e5c95df0ae4e47aab2f604a22d98ee7}{size\_type}} = \mbox{\hyperlink{namespacegko_a6e5c95df0ae4e47aab2f604a22d98ee7}{gko::size\_type}};}
\DoxyCodeLine{\textcolor{keyword}{using} vec\_type = \mbox{\hyperlink{classgko_1_1matrix_1_1BatchDense}{gko::matrix::BatchDense<value\_type>}};}
\DoxyCodeLine{\textcolor{keyword}{using} real\_vec\_type = \mbox{\hyperlink{classgko_1_1matrix_1_1BatchDense}{gko::matrix::BatchDense<real\_type>}};}
\DoxyCodeLine{\textcolor{keyword}{using} mtx\_type = \mbox{\hyperlink{classgko_1_1matrix_1_1BatchCsr}{gko::matrix::BatchCsr<value\_type, index\_type>}};}
\DoxyCodeLine{\textcolor{keyword}{using} solver\_type = \mbox{\hyperlink{classgko_1_1solver_1_1BatchBicgstab}{gko::solver::BatchBicgstab<value\_type>}};}
\end{DoxyCode}


\label{_Applicationstructuresandfunctions}%
 \doxysubsubsection*{\textquotesingle{}Application\textquotesingle{} structures and functions}

Structure to simulate application data related to the linear systems to be solved.

We use raw pointers below to demonstrate how to handle the situation when the application only gives us raw pointers. Ideally, one should use Ginkgo\textquotesingle{}s \mbox{\hyperlink{classgko_1_1Array}{gko\+::\+Array}} class here.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct }ApplSysData \{}
\end{DoxyCode}


Number of small systems in the batch.


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{namespacegko_a6e5c95df0ae4e47aab2f604a22d98ee7}{size\_type}} nsystems;}
\end{DoxyCode}


Number of rows in each system.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{int} nrows;}
\end{DoxyCode}


Number of non-\/zeros in each system matrix.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{int} nnz;}
\end{DoxyCode}


Row pointers for one matrix


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{const} index\_type* row\_ptrs;}
\end{DoxyCode}


Column indices of non-\/zeros for one matrix


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{const} index\_type* col\_idxs;}
\end{DoxyCode}


Nonzero values for all matrices in the batch, concatenated


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{const} value\_type* all\_values;}
\end{DoxyCode}


R\+HS vectors for all systems in the batch, concatenated


\begin{DoxyCode}{0}
\DoxyCodeLine{    \textcolor{keyword}{const} value\_type* all\_rhs;}
\DoxyCodeLine{\};}
\end{DoxyCode}


Generates a batch of tridiagonal systems.


\begin{DoxyParams}{Parameters}
{\em nrows} & Number of rows in each system. \\
\hline
{\em nsystems} & Number of systems in the batch. \\
\hline
{\em exec} & The device executor to use for the solver. Normally, the application may not deal with Ginkgo executors, nor do we need it to. Here, we use the executor for backend-\/independent device memory allocation. The application, for example, might assume Hip (for A\+MD G\+P\+Us) and use {\ttfamily hip\+Malloc} directly.\\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{ApplSysData appl\_generate\_system(\textcolor{keyword}{const} \textcolor{keywordtype}{int} nrows, \textcolor{keyword}{const} size\_type nsystems,}
\DoxyCodeLine{                                 std::shared\_ptr<gko::Executor> exec);}
\end{DoxyCode}


Deallocate application data.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{void} appl\_clean\_up(ApplSysData\& appl\_data, std::shared\_ptr<gko::Executor> exec);}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}* argv[])}
\DoxyCodeLine{\{}
\end{DoxyCode}


Print the ginkgo version information.


\begin{DoxyCode}{0}
\DoxyCodeLine{std::cout << \mbox{\hyperlink{classgko_1_1version__info_a6daeb8a087cfb57fa055526fc133d8eb}{gko::version\_info::get}}() << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordflow}{if} (argc == 2 \&\& (std::string(argv[1]) == \textcolor{stringliteral}{"-\/-\/help"})) \{}
\DoxyCodeLine{    std::cerr << \textcolor{stringliteral}{"Usage: "} << argv[0] << \textcolor{stringliteral}{" [executor] "} << std::endl;}
\DoxyCodeLine{    std::exit(-\/1);}
\DoxyCodeLine{\}}
\end{DoxyCode}


\label{_Wheredoyouwanttorunyoursolver}%
 \doxysubsubsection*{Where do you want to run your solver ?}

The \mbox{\hyperlink{classgko_1_1Executor}{gko\+::\+Executor}} class is one of the cornerstones of Ginkgo. Currently, we have support for an \mbox{\hyperlink{classgko_1_1OmpExecutor}{gko\+::\+Omp\+Executor}}, which uses Open\+MP multi-\/threading in most of its kernels, a \mbox{\hyperlink{classgko_1_1ReferenceExecutor}{gko\+::\+Reference\+Executor}}, a single threaded specialization of the Open\+MP executor and a \mbox{\hyperlink{classgko_1_1CudaExecutor}{gko\+::\+Cuda\+Executor}} which runs the code on a N\+V\+I\+D\+IA G\+PU if available. \begin{DoxyNote}{Note}
With the help of C++, you see that you only ever need to change the executor and all the other functions/ routines within Ginkgo should automatically work and run on the executor with any other changes.
\end{DoxyNote}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{const} \textcolor{keyword}{auto} executor\_string = argc >= 2 ? argv[1] : \textcolor{stringliteral}{"reference"};}
\DoxyCodeLine{std::map<std::string, std::function<std::shared\_ptr<gko::Executor>()>>}
\DoxyCodeLine{    exec\_map\{}
\DoxyCodeLine{        \{\textcolor{stringliteral}{"omp"}, [] \{ \textcolor{keywordflow}{return} \mbox{\hyperlink{classgko_1_1OmpExecutor_a33ca05fdd0fc928ee262fc9425304874}{gko::OmpExecutor::create}}(); \}\},}
\DoxyCodeLine{        \{\textcolor{stringliteral}{"cuda"},}
\DoxyCodeLine{         [] \{}
\DoxyCodeLine{             \textcolor{keywordflow}{return} \mbox{\hyperlink{classgko_1_1CudaExecutor_a5dcec3ca1c458382e01191b727959a81}{gko::CudaExecutor::create}}(0, \mbox{\hyperlink{classgko_1_1OmpExecutor_a33ca05fdd0fc928ee262fc9425304874}{gko::OmpExecutor::create}}(),}
\DoxyCodeLine{                                              \textcolor{keyword}{true});}
\DoxyCodeLine{         \}\},}
\DoxyCodeLine{        \{\textcolor{stringliteral}{"hip"},}
\DoxyCodeLine{         [] \{}
\DoxyCodeLine{             \textcolor{keywordflow}{return} \mbox{\hyperlink{classgko_1_1HipExecutor_ad3a72bc42254fb8730bc2090147447d9}{gko::HipExecutor::create}}(0, \mbox{\hyperlink{classgko_1_1OmpExecutor_a33ca05fdd0fc928ee262fc9425304874}{gko::OmpExecutor::create}}(),}
\DoxyCodeLine{                                             \textcolor{keyword}{true});}
\DoxyCodeLine{         \}\},}
\DoxyCodeLine{        \{\textcolor{stringliteral}{"dpcpp"},}
\DoxyCodeLine{         [] \{}
\DoxyCodeLine{             \textcolor{keywordflow}{return} \mbox{\hyperlink{classgko_1_1DpcppExecutor_ac46044fcb00b2d224b45d93eaf8c579d}{gko::DpcppExecutor::create}}(0,}
\DoxyCodeLine{                                               \mbox{\hyperlink{classgko_1_1OmpExecutor_a33ca05fdd0fc928ee262fc9425304874}{gko::OmpExecutor::create}}());}
\DoxyCodeLine{         \}\},}
\DoxyCodeLine{        \{\textcolor{stringliteral}{"reference"}, [] \{ \textcolor{keywordflow}{return} gko::ReferenceExecutor::create(); \}\}\};}
\end{DoxyCode}


executor where Ginkgo will perform the computation


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{const} \textcolor{keyword}{auto} exec = exec\_map.at(executor\_string)();  \textcolor{comment}{// throws if not valid}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{const} \mbox{\hyperlink{namespacegko_a6e5c95df0ae4e47aab2f604a22d98ee7}{size\_type}} num\_systems = argc >= 3 ? std::atoi(argv[2]) : 2;}
\DoxyCodeLine{\textcolor{keyword}{const} \textcolor{keywordtype}{int} num\_rows = 35;  \textcolor{comment}{// per system}}
\end{DoxyCode}


\label{_Generatedata}%
 \doxysubsubsection*{Generate data}

The \char`\"{}application\char`\"{} generates the batch of linear systems on the device


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto} appl\_sys = appl\_generate\_system(num\_rows, num\_systems, exec);}
\end{DoxyCode}


Create batch\+\_\+dim object to describe the dimensions of the batch matrix.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto} batch\_mat\_size =}
\DoxyCodeLine{    \mbox{\hyperlink{structgko_1_1batch__dim}{gko::batch\_dim<>}}(num\_systems, \mbox{\hyperlink{structgko_1_1dim}{gko::dim<2>}}(num\_rows, num\_rows));}
\DoxyCodeLine{\textcolor{keyword}{auto} batch\_vec\_size =}
\DoxyCodeLine{    \mbox{\hyperlink{structgko_1_1batch__dim}{gko::batch\_dim<>}}(num\_systems, \mbox{\hyperlink{structgko_1_1dim}{gko::dim<2>}}(num\_rows, 1));}
\end{DoxyCode}


\label{_Useofapplicationallocatedmemory}%
 \doxysubsubsection*{Use of application-\/allocated memory}

We can either work on the existing memory allocated in the application, or we can copy it for the linear solve. Note\+: it is not possible to use data through a const pointer directly. Because our pointers are not const, we can just \textquotesingle{}wrap\textquotesingle{} the given pointers into Ginkgo Array views so that we can create a Ginkgo matrix out of them. Ginkgo expects the nonzero values for all the small matrices to be allocated contiguously, one matrix after the other.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto} vals\_view = \mbox{\hyperlink{classgko_1_1Array_aeb8bbb4b363042f909941dd3a1966b70}{gko::Array<value\_type>::const\_view}}(}
\DoxyCodeLine{    exec, num\_systems * appl\_sys.nnz, appl\_sys.all\_values);}
\DoxyCodeLine{\textcolor{keyword}{auto} rowptrs\_view = \mbox{\hyperlink{classgko_1_1Array_aeb8bbb4b363042f909941dd3a1966b70}{gko::Array<index\_type>::const\_view}}(exec, num\_rows + 1,}
\DoxyCodeLine{                                                       appl\_sys.row\_ptrs);}
\DoxyCodeLine{\textcolor{keyword}{auto} colidxs\_view = \mbox{\hyperlink{classgko_1_1Array_aeb8bbb4b363042f909941dd3a1966b70}{gko::Array<index\_type>::const\_view}}(exec, appl\_sys.nnz,}
\DoxyCodeLine{                                                       appl\_sys.col\_idxs);}
\DoxyCodeLine{\textcolor{keyword}{auto} A = \mbox{\hyperlink{namespacegko_a3ce296f73db0ff398bdea6009a3a5c58}{gko::share}}(mtx\_type::create\_const(}
\DoxyCodeLine{    exec, batch\_mat\_size, std::move(vals\_view), std::move(colidxs\_view),}
\DoxyCodeLine{    std::move(rowptrs\_view)));}
\end{DoxyCode}


\label{_RHSandsolutionvectors}%
 \doxysubsubsection*{R\+HS and solution vectors}

batch\+\_\+stride object specifies the access stride within the individual matrices (vectors) in the batch. In this case, we specify a stride of 1 as the common value for all the matrices.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto} batch\_vec\_stride = \mbox{\hyperlink{classgko_1_1batch__stride}{gko::batch\_stride}}(num\_systems, 1);}
\end{DoxyCode}


Create R\+HS, again reusing application allocation


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto} b\_view = \mbox{\hyperlink{classgko_1_1Array_aeb8bbb4b363042f909941dd3a1966b70}{gko::Array<value\_type>::const\_view}}(}
\DoxyCodeLine{    exec, num\_systems * num\_rows, appl\_sys.all\_rhs);}
\DoxyCodeLine{\textcolor{keyword}{auto} b = vec\_type::create\_const(exec, batch\_vec\_size, std::move(b\_view),}
\DoxyCodeLine{                                batch\_vec\_stride);}
\end{DoxyCode}


Create initial guess as 0 and copy to device


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto} x = vec\_type::create(exec);}
\DoxyCodeLine{\textcolor{keyword}{auto} host\_x =}
\DoxyCodeLine{    vec\_type::create(exec-\/>get\_master(), batch\_vec\_size, batch\_vec\_stride);}
\DoxyCodeLine{\textcolor{keywordflow}{for} (size\_type isys = 0; isys < num\_systems; isys++) \{}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} irow = 0; irow < num\_rows; irow++) \{}
\DoxyCodeLine{        host\_x-\/>at(isys, irow, 0) = gko::zero<value\_type>();}
\DoxyCodeLine{    \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{x-\/>copy\_from(host\_x.get());}
\end{DoxyCode}


\label{_Createthebatchsolverfactory}%
 \doxysubsubsection*{Create the batch solver factory}


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{const} real\_type reduction\_factor\{1e-\/6\};}
\end{DoxyCode}


Create a batched solver factory with relevant parameters.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto} solver\_gen =}
\DoxyCodeLine{    solver\_type::build()}
\DoxyCodeLine{        .with\_max\_iterations(500)}
\DoxyCodeLine{        .with\_residual\_tol(reduction\_factor)}
\DoxyCodeLine{        .with\_tolerance\_type(gko::stop::batch::ToleranceType::relative)}
\DoxyCodeLine{        .with\_preconditioner(gko::preconditioner::batch::type::jacobi)}
\DoxyCodeLine{        .on(exec);}
\end{DoxyCode}


\label{_Batchlogger}%
 \doxysubsubsection*{Batch logger}

Create a logger to obtain the iteration counts and \char`\"{}implicit\char`\"{} residual norms for every system after the solve.


\begin{DoxyCode}{0}
\DoxyCodeLine{std::shared\_ptr<const gko::log::BatchConvergence<value\_type>> logger =}
\DoxyCodeLine{    \mbox{\hyperlink{classgko_1_1log_1_1BatchConvergence_ad5908d7498e0c03641267b8c81f80313}{gko::log::BatchConvergence<value\_type>::create}}(exec);}
\end{DoxyCode}


\label{_Generateandsolve}%
 \doxysubsubsection*{Generate and solve}

Generate the batch solver from the batch matrix


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto} solver = solver\_gen-\/>generate(A);}
\end{DoxyCode}


add the logger to the solver


\begin{DoxyCode}{0}
\DoxyCodeLine{solver-\/>add\_logger(logger);}
\end{DoxyCode}


Solve the batch system


\begin{DoxyCode}{0}
\DoxyCodeLine{solver-\/>apply(\mbox{\hyperlink{namespacegko_a014ec51e675c425bb83908361f630450}{lend}}(b), \mbox{\hyperlink{namespacegko_a014ec51e675c425bb83908361f630450}{lend}}(x));}
\end{DoxyCode}


This is not necessary, but one might want to remove the logger before the next solve using the same solver object.


\begin{DoxyCode}{0}
\DoxyCodeLine{solver-\/>remove\_logger(logger.get());}
\end{DoxyCode}


\label{_Checkresult}%
 \doxysubsubsection*{Check result}

Compute norm of R\+HS on the device and automatically copy to host


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto} b\_norm = gko::batch\_initialize<real\_vec\_type>(num\_systems, \{0.0\},}
\DoxyCodeLine{                                                   exec-\/>get\_master());}
\DoxyCodeLine{b-\/>compute\_norm2(\mbox{\hyperlink{namespacegko_a014ec51e675c425bb83908361f630450}{lend}}(b\_norm));}
\end{DoxyCode}


we need constants on the device


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto} \mbox{\hyperlink{namespacegko_a0059e27f8f4bc348ff65c1e60caf47c8}{one}} = gko::batch\_initialize<vec\_type>(num\_systems, \{1.0\}, exec);}
\DoxyCodeLine{\textcolor{keyword}{auto} neg\_one = gko::batch\_initialize<vec\_type>(num\_systems, \{-\/1.0\}, exec);}
\end{DoxyCode}


allocate and compute the residual


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto} res = vec\_type::create(exec, batch\_vec\_size);}
\DoxyCodeLine{res-\/>copy\_from(\mbox{\hyperlink{namespacegko_a014ec51e675c425bb83908361f630450}{lend}}(b));}
\DoxyCodeLine{A-\/>apply(\mbox{\hyperlink{namespacegko_a014ec51e675c425bb83908361f630450}{lend}}(one), \mbox{\hyperlink{namespacegko_a014ec51e675c425bb83908361f630450}{lend}}(x), \mbox{\hyperlink{namespacegko_a014ec51e675c425bb83908361f630450}{lend}}(neg\_one), \mbox{\hyperlink{namespacegko_a014ec51e675c425bb83908361f630450}{lend}}(res));}
\end{DoxyCode}


allocate and compute residual norm


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto} res\_norm = gko::batch\_initialize<real\_vec\_type>(num\_systems, \{0.0\},}
\DoxyCodeLine{                                                     exec-\/>get\_master());}
\DoxyCodeLine{res-\/>compute\_norm2(\mbox{\hyperlink{namespacegko_a014ec51e675c425bb83908361f630450}{lend}}(res\_norm));}
\DoxyCodeLine{}
\DoxyCodeLine{std::cout << \textcolor{stringliteral}{"Residual norm sqrt(r\string^T r):\(\backslash\)n"};}
\end{DoxyCode}


\char`\"{}unbatch\char`\"{} converts a batch object into a vector of objects of the corresponding single type, eg. Batch\+Dense -\/-\/$>$ vector$<$\+Dense$>$.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto} unb\_res = res\_norm-\/>unbatch();}
\DoxyCodeLine{\textcolor{keyword}{auto} unb\_bnorm = b\_norm-\/>unbatch();}
\DoxyCodeLine{\textcolor{keywordflow}{for} (size\_type i = 0; i < num\_systems; ++i) \{}
\DoxyCodeLine{    std::cout << \textcolor{stringliteral}{" System no. "} << i}
\DoxyCodeLine{              << \textcolor{stringliteral}{": residual norm = "} << unb\_res[i]-\/>at(0, 0)}
\DoxyCodeLine{              << \textcolor{stringliteral}{", internal residual norm = "}}
\DoxyCodeLine{              << logger-\/>get\_residual\_norm()-\/>at(i, 0, 0)}
\DoxyCodeLine{              << \textcolor{stringliteral}{", iterations = "}}
\DoxyCodeLine{              << logger-\/>get\_num\_iterations().get\_const\_data()[i]}
\DoxyCodeLine{              << std::endl;}
\DoxyCodeLine{    \textcolor{keyword}{const} real\_type relresnorm =}
\DoxyCodeLine{        unb\_res[i]-\/>at(0, 0) / unb\_bnorm[i]-\/>at(0, 0);}
\DoxyCodeLine{    \textcolor{keywordflow}{if} (!(relresnorm <= reduction\_factor)) \{}
\DoxyCodeLine{        std::cout << \textcolor{stringliteral}{"System "} << i << \textcolor{stringliteral}{" converged only to "} << relresnorm}
\DoxyCodeLine{                  << \textcolor{stringliteral}{" relative residual."} << std::endl;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{\}}
\end{DoxyCode}


Ginkgo objects are cleaned up automatically; but the \char`\"{}application\char`\"{} still needs to clean up its data in this case.


\begin{DoxyCode}{0}
\DoxyCodeLine{    appl\_clean\_up(appl\_sys, exec);}
\DoxyCodeLine{    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{ApplSysData appl\_generate\_system(\textcolor{keyword}{const} \textcolor{keywordtype}{int} nrows, \textcolor{keyword}{const} size\_type nsystems,}
\DoxyCodeLine{                                 std::shared\_ptr<gko::Executor> exec)}
\DoxyCodeLine{\{}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keywordtype}{int} nnz = nrows * 3 -\/ 2;}
\DoxyCodeLine{    std::ranlux48 rgen(15);}
\DoxyCodeLine{    std::normal\_distribution<real\_type> distb(0.5, 0.1);}
\DoxyCodeLine{    std::vector<real\_type> spacings(nsystems * nrows);}
\DoxyCodeLine{    std::generate(spacings.begin(), spacings.end(),}
\DoxyCodeLine{                  [\&]() \{ \textcolor{keywordflow}{return} distb(rgen); \});}
\DoxyCodeLine{}
\DoxyCodeLine{    std::vector<value\_type> allvalues(nnz * nsystems);}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (size\_type isys = 0; isys < nsystems; isys++) \{}
\DoxyCodeLine{        allvalues[isys * nnz] = 2.0 / spacings[isys * nrows];}
\DoxyCodeLine{        allvalues[isys * nnz + 1] = -\/1.0;}
\DoxyCodeLine{        \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} irow = 0; irow < nrows -\/ 2; irow++) \{}
\DoxyCodeLine{            allvalues[isys * nnz + 2 + irow * 3] = -\/1.0;}
\DoxyCodeLine{            allvalues[isys * nnz + 2 + irow * 3 + 1] =}
\DoxyCodeLine{                2.0 / spacings[isys * nrows + irow + 1];}
\DoxyCodeLine{            allvalues[isys * nnz + 2 + irow * 3 + 2] = -\/1.0;}
\DoxyCodeLine{        \}}
\DoxyCodeLine{        allvalues[isys * nnz + 2 + (nrows -\/ 2) * 3] = -\/1.0;}
\DoxyCodeLine{        allvalues[isys * nnz + 2 + (nrows -\/ 2) * 3 + 1] =}
\DoxyCodeLine{            2.0 / spacings[(isys + 1) * nrows -\/ 1];}
\DoxyCodeLine{        assert(isys * nnz + 2 + (nrows -\/ 2) * 3 + 2 == (isys + 1) * nnz);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    std::vector<index\_type> rowptrs(nrows + 1);}
\DoxyCodeLine{    rowptrs[0] = 0;}
\DoxyCodeLine{    rowptrs[1] = 2;}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 2; i < nrows; i++) \{}
\DoxyCodeLine{        rowptrs[i] = rowptrs[i -\/ 1] + 3;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{    rowptrs[nrows] = rowptrs[nrows -\/ 1] + 2;}
\DoxyCodeLine{    assert(rowptrs[nrows] == nnz);}
\DoxyCodeLine{}
\DoxyCodeLine{    std::vector<index\_type> colidxs(nnz);}
\DoxyCodeLine{    colidxs[0] = 0;}
\DoxyCodeLine{    colidxs[1] = 1;}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keywordtype}{int} nnz\_per\_row = 3;}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} irow = 1; irow < nrows -\/ 1; irow++) \{}
\DoxyCodeLine{        colidxs[2 + (irow -\/ 1) * nnz\_per\_row] = irow -\/ 1;}
\DoxyCodeLine{        colidxs[2 + (irow -\/ 1) * nnz\_per\_row + 1] = irow;}
\DoxyCodeLine{        colidxs[2 + (irow -\/ 1) * nnz\_per\_row + 2] = irow + 1;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{    colidxs[2 + (nrows -\/ 2) * nnz\_per\_row] = nrows -\/ 2;}
\DoxyCodeLine{    colidxs[2 + (nrows -\/ 2) * nnz\_per\_row + 1] = nrows -\/ 1;}
\DoxyCodeLine{    assert(2 + (nrows -\/ 2) * nnz\_per\_row + 1 == nnz -\/ 1);}
\DoxyCodeLine{}
\DoxyCodeLine{    std::vector<value\_type> allb(nrows * nsystems);}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (size\_type isys = 0; isys < nsystems; isys++) \{}
\DoxyCodeLine{        \textcolor{keyword}{const} value\_type bval = distb(rgen);}
\DoxyCodeLine{        std::fill(allb.begin() + isys * nrows,}
\DoxyCodeLine{                  allb.begin() + (isys + 1) * nrows, bval);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    index\_type* \textcolor{keyword}{const} row\_ptrs = exec-\/>alloc<index\_type>(nrows + 1);}
\DoxyCodeLine{    exec-\/>copy\_from(exec-\/>get\_master().get(), static\_cast<size\_type>(nrows + 1),}
\DoxyCodeLine{                    rowptrs.data(), row\_ptrs);}
\DoxyCodeLine{    index\_type* \textcolor{keyword}{const} col\_idxs = exec-\/>alloc<index\_type>(nnz);}
\DoxyCodeLine{    exec-\/>copy\_from(exec-\/>get\_master().get(), static\_cast<size\_type>(nnz),}
\DoxyCodeLine{                    colidxs.data(), col\_idxs);}
\DoxyCodeLine{    value\_type* \textcolor{keyword}{const} all\_values = exec-\/>alloc<value\_type>(nsystems * nnz);}
\DoxyCodeLine{    exec-\/>copy\_from(exec-\/>get\_master().get(), nsystems * nnz, allvalues.data(),}
\DoxyCodeLine{                    all\_values);}
\DoxyCodeLine{    value\_type* \textcolor{keyword}{const} all\_b = exec-\/>alloc<value\_type>(nsystems * nrows);}
\DoxyCodeLine{    exec-\/>copy\_from(exec-\/>get\_master().get(), nsystems * nrows, allb.data(),}
\DoxyCodeLine{                    all\_b);}
\DoxyCodeLine{    \textcolor{keywordflow}{return} \{nsystems, nrows, nnz, row\_ptrs, col\_idxs, all\_values, all\_b\};}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{void} appl\_clean\_up(ApplSysData\& appl\_data, std::shared\_ptr<gko::Executor> exec)}
\DoxyCodeLine{\{}
\end{DoxyCode}


In general, the application would control non-\/const pointers; the const casts below would not be needed.


\begin{DoxyCode}{0}
\DoxyCodeLine{    exec-\/>free(const\_cast<index\_type*>(appl\_data.row\_ptrs));}
\DoxyCodeLine{    exec-\/>free(const\_cast<index\_type*>(appl\_data.col\_idxs));}
\DoxyCodeLine{    exec-\/>free(const\_cast<value\_type*>(appl\_data.all\_values));}
\DoxyCodeLine{    exec-\/>free(const\_cast<value\_type*>(appl\_data.all\_rhs));}
\DoxyCodeLine{\}}
\end{DoxyCode}
 \label{_Results}%
\doxysection*{Results}

The following is the expected result on the reference executor\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{Residual norm sqrt(r\string^T r):}
\DoxyCodeLine{ System no. 0: residual norm = 2.16283e-\/06, internal residual norm = 2.16283e-\/06, iterations = 6}
\DoxyCodeLine{ System no. 1: residual norm = 1.07502e-\/06, internal residual norm = 1.07502e-\/06, iterations = 6}
\end{DoxyCode}


\label{_Commentsaboutprogramminganddebugging}%
\doxysubsubsection*{Comments about programming and debugging }

\label{_PlainProg}%
 \doxysection*{The plain program}


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{comment}{/*******************************<GINKGO LICENSE>******************************}}
\DoxyCodeLine{\textcolor{comment}{Copyright (c) 2017-\/2022, the Ginkgo authors}}
\DoxyCodeLine{\textcolor{comment}{All rights reserved.}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{Redistribution and use in source and binary forms, with or without}}
\DoxyCodeLine{\textcolor{comment}{modification, are permitted provided that the following conditions}}
\DoxyCodeLine{\textcolor{comment}{are met:}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{1. Redistributions of source code must retain the above copyright}}
\DoxyCodeLine{\textcolor{comment}{notice, this list of conditions and the following disclaimer.}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{2. Redistributions in binary form must reproduce the above copyright}}
\DoxyCodeLine{\textcolor{comment}{notice, this list of conditions and the following disclaimer in the}}
\DoxyCodeLine{\textcolor{comment}{documentation and/or other materials provided with the distribution.}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{3. Neither the name of the copyright holder nor the names of its}}
\DoxyCodeLine{\textcolor{comment}{contributors may be used to endorse or promote products derived from}}
\DoxyCodeLine{\textcolor{comment}{this software without specific prior written permission.}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS}}
\DoxyCodeLine{\textcolor{comment}{IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED}}
\DoxyCodeLine{\textcolor{comment}{TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A}}
\DoxyCodeLine{\textcolor{comment}{PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}}
\DoxyCodeLine{\textcolor{comment}{HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}}
\DoxyCodeLine{\textcolor{comment}{SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}}
\DoxyCodeLine{\textcolor{comment}{LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}}
\DoxyCodeLine{\textcolor{comment}{DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}}
\DoxyCodeLine{\textcolor{comment}{THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}}
\DoxyCodeLine{\textcolor{comment}{(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}}
\DoxyCodeLine{\textcolor{comment}{OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}}
\DoxyCodeLine{\textcolor{comment}{******************************<GINKGO LICENSE>*******************************/}}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <ginkgo/ginkgo.hpp>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <fstream>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <map>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <random>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{using} value\_type = double;}
\DoxyCodeLine{\textcolor{keyword}{using} real\_type = \mbox{\hyperlink{namespacegko_afd46d554050c4ae90e84ea4fcd9a41f3}{gko::remove\_complex<value\_type>}};}
\DoxyCodeLine{\textcolor{keyword}{using} index\_type = int;}
\DoxyCodeLine{\textcolor{keyword}{using} \mbox{\hyperlink{namespacegko_a6e5c95df0ae4e47aab2f604a22d98ee7}{size\_type}} = \mbox{\hyperlink{namespacegko_a6e5c95df0ae4e47aab2f604a22d98ee7}{gko::size\_type}};}
\DoxyCodeLine{\textcolor{keyword}{using} vec\_type = \mbox{\hyperlink{classgko_1_1matrix_1_1BatchDense}{gko::matrix::BatchDense<value\_type>}};}
\DoxyCodeLine{\textcolor{keyword}{using} real\_vec\_type = \mbox{\hyperlink{classgko_1_1matrix_1_1BatchDense}{gko::matrix::BatchDense<real\_type>}};}
\DoxyCodeLine{\textcolor{keyword}{using} mtx\_type = \mbox{\hyperlink{classgko_1_1matrix_1_1BatchCsr}{gko::matrix::BatchCsr<value\_type, index\_type>}};}
\DoxyCodeLine{\textcolor{keyword}{using} solver\_type = \mbox{\hyperlink{classgko_1_1solver_1_1BatchBicgstab}{gko::solver::BatchBicgstab<value\_type>}};}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{struct }ApplSysData \{}
\DoxyCodeLine{    \mbox{\hyperlink{namespacegko_a6e5c95df0ae4e47aab2f604a22d98ee7}{size\_type}} nsystems;}
\DoxyCodeLine{    \textcolor{keywordtype}{int} nrows;}
\DoxyCodeLine{    \textcolor{keywordtype}{int} nnz;}
\DoxyCodeLine{    \textcolor{keyword}{const} index\_type* row\_ptrs;}
\DoxyCodeLine{    \textcolor{keyword}{const} index\_type* col\_idxs;}
\DoxyCodeLine{    \textcolor{keyword}{const} value\_type* all\_values;}
\DoxyCodeLine{    \textcolor{keyword}{const} value\_type* all\_rhs;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{ApplSysData appl\_generate\_system(\textcolor{keyword}{const} \textcolor{keywordtype}{int} nrows, \textcolor{keyword}{const} size\_type nsystems,}
\DoxyCodeLine{                                 std::shared\_ptr<gko::Executor> exec);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{void} appl\_clean\_up(ApplSysData\& appl\_data, std::shared\_ptr<gko::Executor> exec);}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}* argv[])}
\DoxyCodeLine{\{}
\DoxyCodeLine{    std::cout << \mbox{\hyperlink{classgko_1_1version__info_a6daeb8a087cfb57fa055526fc133d8eb}{gko::version\_info::get}}() << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordflow}{if} (argc == 2 \&\& (std::string(argv[1]) == \textcolor{stringliteral}{"-\/-\/help"})) \{}
\DoxyCodeLine{        std::cerr << \textcolor{stringliteral}{"Usage: "} << argv[0] << \textcolor{stringliteral}{" [executor] "} << std::endl;}
\DoxyCodeLine{        std::exit(-\/1);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keyword}{auto} executor\_string = argc >= 2 ? argv[1] : \textcolor{stringliteral}{"reference"};}
\DoxyCodeLine{    std::map<std::string, std::function<std::shared\_ptr<gko::Executor>()>>}
\DoxyCodeLine{        exec\_map\{}
\DoxyCodeLine{            \{\textcolor{stringliteral}{"omp"}, [] \{ \textcolor{keywordflow}{return} \mbox{\hyperlink{classgko_1_1OmpExecutor_a33ca05fdd0fc928ee262fc9425304874}{gko::OmpExecutor::create}}(); \}\},}
\DoxyCodeLine{            \{\textcolor{stringliteral}{"cuda"},}
\DoxyCodeLine{             [] \{}
\DoxyCodeLine{                 \textcolor{keywordflow}{return} \mbox{\hyperlink{classgko_1_1CudaExecutor_a5dcec3ca1c458382e01191b727959a81}{gko::CudaExecutor::create}}(0, \mbox{\hyperlink{classgko_1_1OmpExecutor_a33ca05fdd0fc928ee262fc9425304874}{gko::OmpExecutor::create}}(),}
\DoxyCodeLine{                                                  \textcolor{keyword}{true});}
\DoxyCodeLine{             \}\},}
\DoxyCodeLine{            \{\textcolor{stringliteral}{"hip"},}
\DoxyCodeLine{             [] \{}
\DoxyCodeLine{                 \textcolor{keywordflow}{return} \mbox{\hyperlink{classgko_1_1HipExecutor_ad3a72bc42254fb8730bc2090147447d9}{gko::HipExecutor::create}}(0, \mbox{\hyperlink{classgko_1_1OmpExecutor_a33ca05fdd0fc928ee262fc9425304874}{gko::OmpExecutor::create}}(),}
\DoxyCodeLine{                                                 \textcolor{keyword}{true});}
\DoxyCodeLine{             \}\},}
\DoxyCodeLine{            \{\textcolor{stringliteral}{"dpcpp"},}
\DoxyCodeLine{             [] \{}
\DoxyCodeLine{                 \textcolor{keywordflow}{return} \mbox{\hyperlink{classgko_1_1DpcppExecutor_ac46044fcb00b2d224b45d93eaf8c579d}{gko::DpcppExecutor::create}}(0,}
\DoxyCodeLine{                                                   \mbox{\hyperlink{classgko_1_1OmpExecutor_a33ca05fdd0fc928ee262fc9425304874}{gko::OmpExecutor::create}}());}
\DoxyCodeLine{             \}\},}
\DoxyCodeLine{            \{\textcolor{stringliteral}{"reference"}, [] \{ \textcolor{keywordflow}{return} gko::ReferenceExecutor::create(); \}\}\};}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keyword}{auto} exec = exec\_map.at(executor\_string)();  \textcolor{comment}{// throws if not valid}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{const} \mbox{\hyperlink{namespacegko_a6e5c95df0ae4e47aab2f604a22d98ee7}{size\_type}} num\_systems = argc >= 3 ? std::atoi(argv[2]) : 2;}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keywordtype}{int} num\_rows = 35;  \textcolor{comment}{// per system}}
\DoxyCodeLine{    \textcolor{keyword}{auto} appl\_sys = appl\_generate\_system(num\_rows, num\_systems, exec);}
\DoxyCodeLine{    \textcolor{keyword}{auto} batch\_mat\_size =}
\DoxyCodeLine{        \mbox{\hyperlink{structgko_1_1batch__dim}{gko::batch\_dim<>}}(num\_systems, \mbox{\hyperlink{structgko_1_1dim}{gko::dim<2>}}(num\_rows, num\_rows));}
\DoxyCodeLine{    \textcolor{keyword}{auto} batch\_vec\_size =}
\DoxyCodeLine{        \mbox{\hyperlink{structgko_1_1batch__dim}{gko::batch\_dim<>}}(num\_systems, \mbox{\hyperlink{structgko_1_1dim}{gko::dim<2>}}(num\_rows, 1));}
\DoxyCodeLine{    \textcolor{keyword}{auto} vals\_view = \mbox{\hyperlink{classgko_1_1Array_aeb8bbb4b363042f909941dd3a1966b70}{gko::Array<value\_type>::const\_view}}(}
\DoxyCodeLine{        exec, num\_systems * appl\_sys.nnz, appl\_sys.all\_values);}
\DoxyCodeLine{    \textcolor{keyword}{auto} rowptrs\_view = \mbox{\hyperlink{classgko_1_1Array_aeb8bbb4b363042f909941dd3a1966b70}{gko::Array<index\_type>::const\_view}}(exec, num\_rows + 1,}
\DoxyCodeLine{                                                           appl\_sys.row\_ptrs);}
\DoxyCodeLine{    \textcolor{keyword}{auto} colidxs\_view = \mbox{\hyperlink{classgko_1_1Array_aeb8bbb4b363042f909941dd3a1966b70}{gko::Array<index\_type>::const\_view}}(exec, appl\_sys.nnz,}
\DoxyCodeLine{                                                           appl\_sys.col\_idxs);}
\DoxyCodeLine{    \textcolor{keyword}{auto} A = \mbox{\hyperlink{namespacegko_a3ce296f73db0ff398bdea6009a3a5c58}{gko::share}}(mtx\_type::create\_const(}
\DoxyCodeLine{        exec, batch\_mat\_size, std::move(vals\_view), std::move(colidxs\_view),}
\DoxyCodeLine{        std::move(rowptrs\_view)));}
\DoxyCodeLine{    \textcolor{keyword}{auto} batch\_vec\_stride = \mbox{\hyperlink{classgko_1_1batch__stride}{gko::batch\_stride}}(num\_systems, 1);}
\DoxyCodeLine{    \textcolor{keyword}{auto} b\_view = \mbox{\hyperlink{classgko_1_1Array_aeb8bbb4b363042f909941dd3a1966b70}{gko::Array<value\_type>::const\_view}}(}
\DoxyCodeLine{        exec, num\_systems * num\_rows, appl\_sys.all\_rhs);}
\DoxyCodeLine{    \textcolor{keyword}{auto} b = vec\_type::create\_const(exec, batch\_vec\_size, std::move(b\_view),}
\DoxyCodeLine{                                    batch\_vec\_stride);}
\DoxyCodeLine{    \textcolor{keyword}{auto} x = vec\_type::create(exec);}
\DoxyCodeLine{    \textcolor{keyword}{auto} host\_x =}
\DoxyCodeLine{        vec\_type::create(exec-\/>get\_master(), batch\_vec\_size, batch\_vec\_stride);}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (size\_type isys = 0; isys < num\_systems; isys++) \{}
\DoxyCodeLine{        \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} irow = 0; irow < num\_rows; irow++) \{}
\DoxyCodeLine{            host\_x-\/>at(isys, irow, 0) = gko::zero<value\_type>();}
\DoxyCodeLine{        \}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{    x-\/>copy\_from(host\_x.get());}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{const} real\_type reduction\_factor\{1e-\/6\};}
\DoxyCodeLine{    \textcolor{keyword}{auto} solver\_gen =}
\DoxyCodeLine{        solver\_type::build()}
\DoxyCodeLine{            .with\_max\_iterations(500)}
\DoxyCodeLine{            .with\_residual\_tol(reduction\_factor)}
\DoxyCodeLine{            .with\_tolerance\_type(gko::stop::batch::ToleranceType::relative)}
\DoxyCodeLine{            .with\_preconditioner(gko::preconditioner::batch::type::jacobi)}
\DoxyCodeLine{            .on(exec);}
\DoxyCodeLine{}
\DoxyCodeLine{    std::shared\_ptr<const gko::log::BatchConvergence<value\_type>> logger =}
\DoxyCodeLine{        \mbox{\hyperlink{classgko_1_1log_1_1BatchConvergence_ad5908d7498e0c03641267b8c81f80313}{gko::log::BatchConvergence<value\_type>::create}}(exec);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{auto} solver = solver\_gen-\/>generate(A);}
\DoxyCodeLine{    solver-\/>add\_logger(logger);}
\DoxyCodeLine{    solver-\/>apply(\mbox{\hyperlink{namespacegko_a014ec51e675c425bb83908361f630450}{lend}}(b), \mbox{\hyperlink{namespacegko_a014ec51e675c425bb83908361f630450}{lend}}(x));}
\DoxyCodeLine{    solver-\/>remove\_logger(logger.get());}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{auto} b\_norm = gko::batch\_initialize<real\_vec\_type>(num\_systems, \{0.0\},}
\DoxyCodeLine{                                                       exec-\/>get\_master());}
\DoxyCodeLine{    b-\/>compute\_norm2(\mbox{\hyperlink{namespacegko_a014ec51e675c425bb83908361f630450}{lend}}(b\_norm));}
\DoxyCodeLine{    \textcolor{keyword}{auto} \mbox{\hyperlink{namespacegko_a0059e27f8f4bc348ff65c1e60caf47c8}{one}} = gko::batch\_initialize<vec\_type>(num\_systems, \{1.0\}, exec);}
\DoxyCodeLine{    \textcolor{keyword}{auto} neg\_one = gko::batch\_initialize<vec\_type>(num\_systems, \{-\/1.0\}, exec);}
\DoxyCodeLine{    \textcolor{keyword}{auto} res = vec\_type::create(exec, batch\_vec\_size);}
\DoxyCodeLine{    res-\/>copy\_from(\mbox{\hyperlink{namespacegko_a014ec51e675c425bb83908361f630450}{lend}}(b));}
\DoxyCodeLine{    A-\/>apply(\mbox{\hyperlink{namespacegko_a014ec51e675c425bb83908361f630450}{lend}}(one), \mbox{\hyperlink{namespacegko_a014ec51e675c425bb83908361f630450}{lend}}(x), \mbox{\hyperlink{namespacegko_a014ec51e675c425bb83908361f630450}{lend}}(neg\_one), \mbox{\hyperlink{namespacegko_a014ec51e675c425bb83908361f630450}{lend}}(res));}
\DoxyCodeLine{    \textcolor{keyword}{auto} res\_norm = gko::batch\_initialize<real\_vec\_type>(num\_systems, \{0.0\},}
\DoxyCodeLine{                                                         exec-\/>get\_master());}
\DoxyCodeLine{    res-\/>compute\_norm2(\mbox{\hyperlink{namespacegko_a014ec51e675c425bb83908361f630450}{lend}}(res\_norm));}
\DoxyCodeLine{}
\DoxyCodeLine{    std::cout << \textcolor{stringliteral}{"Residual norm sqrt(r\string^T r):\(\backslash\)n"};}
\DoxyCodeLine{    \textcolor{keyword}{auto} unb\_res = res\_norm-\/>unbatch();}
\DoxyCodeLine{    \textcolor{keyword}{auto} unb\_bnorm = b\_norm-\/>unbatch();}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (size\_type i = 0; i < num\_systems; ++i) \{}
\DoxyCodeLine{        std::cout << \textcolor{stringliteral}{" System no. "} << i}
\DoxyCodeLine{                  << \textcolor{stringliteral}{": residual norm = "} << unb\_res[i]-\/>at(0, 0)}
\DoxyCodeLine{                  << \textcolor{stringliteral}{", internal residual norm = "}}
\DoxyCodeLine{                  << logger-\/>get\_residual\_norm()-\/>at(i, 0, 0)}
\DoxyCodeLine{                  << \textcolor{stringliteral}{", iterations = "}}
\DoxyCodeLine{                  << logger-\/>get\_num\_iterations().get\_const\_data()[i]}
\DoxyCodeLine{                  << std::endl;}
\DoxyCodeLine{        \textcolor{keyword}{const} real\_type relresnorm =}
\DoxyCodeLine{            unb\_res[i]-\/>at(0, 0) / unb\_bnorm[i]-\/>at(0, 0);}
\DoxyCodeLine{        \textcolor{keywordflow}{if} (!(relresnorm <= reduction\_factor)) \{}
\DoxyCodeLine{            std::cout << \textcolor{stringliteral}{"System "} << i << \textcolor{stringliteral}{" converged only to "} << relresnorm}
\DoxyCodeLine{                      << \textcolor{stringliteral}{" relative residual."} << std::endl;}
\DoxyCodeLine{        \}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    appl\_clean\_up(appl\_sys, exec);}
\DoxyCodeLine{    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{ApplSysData appl\_generate\_system(\textcolor{keyword}{const} \textcolor{keywordtype}{int} nrows, \textcolor{keyword}{const} size\_type nsystems,}
\DoxyCodeLine{                                 std::shared\_ptr<gko::Executor> exec)}
\DoxyCodeLine{\{}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keywordtype}{int} nnz = nrows * 3 -\/ 2;}
\DoxyCodeLine{    std::ranlux48 rgen(15);}
\DoxyCodeLine{    std::normal\_distribution<real\_type> distb(0.5, 0.1);}
\DoxyCodeLine{    std::vector<real\_type> spacings(nsystems * nrows);}
\DoxyCodeLine{    std::generate(spacings.begin(), spacings.end(),}
\DoxyCodeLine{                  [\&]() \{ \textcolor{keywordflow}{return} distb(rgen); \});}
\DoxyCodeLine{}
\DoxyCodeLine{    std::vector<value\_type> allvalues(nnz * nsystems);}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (size\_type isys = 0; isys < nsystems; isys++) \{}
\DoxyCodeLine{        allvalues[isys * nnz] = 2.0 / spacings[isys * nrows];}
\DoxyCodeLine{        allvalues[isys * nnz + 1] = -\/1.0;}
\DoxyCodeLine{        \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} irow = 0; irow < nrows -\/ 2; irow++) \{}
\DoxyCodeLine{            allvalues[isys * nnz + 2 + irow * 3] = -\/1.0;}
\DoxyCodeLine{            allvalues[isys * nnz + 2 + irow * 3 + 1] =}
\DoxyCodeLine{                2.0 / spacings[isys * nrows + irow + 1];}
\DoxyCodeLine{            allvalues[isys * nnz + 2 + irow * 3 + 2] = -\/1.0;}
\DoxyCodeLine{        \}}
\DoxyCodeLine{        allvalues[isys * nnz + 2 + (nrows -\/ 2) * 3] = -\/1.0;}
\DoxyCodeLine{        allvalues[isys * nnz + 2 + (nrows -\/ 2) * 3 + 1] =}
\DoxyCodeLine{            2.0 / spacings[(isys + 1) * nrows -\/ 1];}
\DoxyCodeLine{        assert(isys * nnz + 2 + (nrows -\/ 2) * 3 + 2 == (isys + 1) * nnz);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    std::vector<index\_type> rowptrs(nrows + 1);}
\DoxyCodeLine{    rowptrs[0] = 0;}
\DoxyCodeLine{    rowptrs[1] = 2;}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 2; i < nrows; i++) \{}
\DoxyCodeLine{        rowptrs[i] = rowptrs[i -\/ 1] + 3;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{    rowptrs[nrows] = rowptrs[nrows -\/ 1] + 2;}
\DoxyCodeLine{    assert(rowptrs[nrows] == nnz);}
\DoxyCodeLine{}
\DoxyCodeLine{    std::vector<index\_type> colidxs(nnz);}
\DoxyCodeLine{    colidxs[0] = 0;}
\DoxyCodeLine{    colidxs[1] = 1;}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keywordtype}{int} nnz\_per\_row = 3;}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} irow = 1; irow < nrows -\/ 1; irow++) \{}
\DoxyCodeLine{        colidxs[2 + (irow -\/ 1) * nnz\_per\_row] = irow -\/ 1;}
\DoxyCodeLine{        colidxs[2 + (irow -\/ 1) * nnz\_per\_row + 1] = irow;}
\DoxyCodeLine{        colidxs[2 + (irow -\/ 1) * nnz\_per\_row + 2] = irow + 1;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{    colidxs[2 + (nrows -\/ 2) * nnz\_per\_row] = nrows -\/ 2;}
\DoxyCodeLine{    colidxs[2 + (nrows -\/ 2) * nnz\_per\_row + 1] = nrows -\/ 1;}
\DoxyCodeLine{    assert(2 + (nrows -\/ 2) * nnz\_per\_row + 1 == nnz -\/ 1);}
\DoxyCodeLine{}
\DoxyCodeLine{    std::vector<value\_type> allb(nrows * nsystems);}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (size\_type isys = 0; isys < nsystems; isys++) \{}
\DoxyCodeLine{        \textcolor{keyword}{const} value\_type bval = distb(rgen);}
\DoxyCodeLine{        std::fill(allb.begin() + isys * nrows,}
\DoxyCodeLine{                  allb.begin() + (isys + 1) * nrows, bval);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    index\_type* \textcolor{keyword}{const} row\_ptrs = exec-\/>alloc<index\_type>(nrows + 1);}
\DoxyCodeLine{    exec-\/>copy\_from(exec-\/>get\_master().get(), static\_cast<size\_type>(nrows + 1),}
\DoxyCodeLine{                    rowptrs.data(), row\_ptrs);}
\DoxyCodeLine{    index\_type* \textcolor{keyword}{const} col\_idxs = exec-\/>alloc<index\_type>(nnz);}
\DoxyCodeLine{    exec-\/>copy\_from(exec-\/>get\_master().get(), static\_cast<size\_type>(nnz),}
\DoxyCodeLine{                    colidxs.data(), col\_idxs);}
\DoxyCodeLine{    value\_type* \textcolor{keyword}{const} all\_values = exec-\/>alloc<value\_type>(nsystems * nnz);}
\DoxyCodeLine{    exec-\/>copy\_from(exec-\/>get\_master().get(), nsystems * nnz, allvalues.data(),}
\DoxyCodeLine{                    all\_values);}
\DoxyCodeLine{    value\_type* \textcolor{keyword}{const} all\_b = exec-\/>alloc<value\_type>(nsystems * nrows);}
\DoxyCodeLine{    exec-\/>copy\_from(exec-\/>get\_master().get(), nsystems * nrows, allb.data(),}
\DoxyCodeLine{                    all\_b);}
\DoxyCodeLine{    \textcolor{keywordflow}{return} \{nsystems, nrows, nnz, row\_ptrs, col\_idxs, all\_values, all\_b\};}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{void} appl\_clean\_up(ApplSysData\& appl\_data, std::shared\_ptr<gko::Executor> exec)}
\DoxyCodeLine{\{}
\DoxyCodeLine{    exec-\/>free(const\_cast<index\_type*>(appl\_data.row\_ptrs));}
\DoxyCodeLine{    exec-\/>free(const\_cast<index\_type*>(appl\_data.col\_idxs));}
\DoxyCodeLine{    exec-\/>free(const\_cast<value\_type*>(appl\_data.all\_values));}
\DoxyCodeLine{    exec-\/>free(const\_cast<value\_type*>(appl\_data.all\_rhs));}
\DoxyCodeLine{\}}
\end{DoxyCodeInclude}
 