<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Ginkgo: gko Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_doc.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Ginkgo
   &#160;<span id="projectnumber">Generated from pipelines/718394428 branch based on develop. Ginkgo version 1.5.0</span>
   </div>
   <div id="projectbrief">A numerical linear algebra library targeting many-core architectures</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">gko Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The Ginkgo namespace.  
<a href="namespacegko.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacegko_1_1accessor"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko_1_1accessor.html">accessor</a></td></tr>
<tr class="memdesc:namespacegko_1_1accessor"><td class="mdescLeft">&#160;</td><td class="mdescRight">The accessor namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacegko_1_1factorization"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko_1_1factorization.html">factorization</a></td></tr>
<tr class="memdesc:namespacegko_1_1factorization"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Factorization namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacegko_1_1log"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko_1_1log.html">log</a></td></tr>
<tr class="memdesc:namespacegko_1_1log"><td class="mdescLeft">&#160;</td><td class="mdescRight">The logger namespace . <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacegko_1_1matrix"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko_1_1matrix.html">matrix</a></td></tr>
<tr class="memdesc:namespacegko_1_1matrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matrix namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacegko_1_1multigrid"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko_1_1multigrid.html">multigrid</a></td></tr>
<tr class="memdesc:namespacegko_1_1multigrid"><td class="mdescLeft">&#160;</td><td class="mdescRight">The multigrid components namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacegko_1_1name__demangling"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko_1_1name__demangling.html">name_demangling</a></td></tr>
<tr class="memdesc:namespacegko_1_1name__demangling"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name demangling namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacegko_1_1preconditioner"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko_1_1preconditioner.html">preconditioner</a></td></tr>
<tr class="memdesc:namespacegko_1_1preconditioner"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Preconditioner namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacegko_1_1reorder"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko_1_1reorder.html">reorder</a></td></tr>
<tr class="memdesc:namespacegko_1_1reorder"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Reorder namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacegko_1_1solver"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko_1_1solver.html">solver</a></td></tr>
<tr class="memdesc:namespacegko_1_1solver"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ginkgo Solve namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacegko_1_1stop"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko_1_1stop.html">stop</a></td></tr>
<tr class="memdesc:namespacegko_1_1stop"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Stopping criterion namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacegko_1_1syn"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko_1_1syn.html">syn</a></td></tr>
<tr class="memdesc:namespacegko_1_1syn"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Synthesizer namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacegko_1_1xstd"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko_1_1xstd.html">xstd</a></td></tr>
<tr class="memdesc:namespacegko_1_1xstd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The namespace for functionalities after C++14 standard. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1AbsoluteComputable.html">AbsoluteComputable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classgko_1_1AbsoluteComputable.html" title="The AbsoluteComputable is an interface that allows to get the component wise absolute of a LinOp.">AbsoluteComputable</a> is an interface that allows to get the component wise absolute of a <a class="el" href="classgko_1_1LinOp.html">LinOp</a>.  <a href="classgko_1_1AbsoluteComputable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1AbstractFactory.html">AbstractFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classgko_1_1AbstractFactory.html" title="The AbstractFactory is a generic interface template that enables easy implementation of the abstract ...">AbstractFactory</a> is a generic interface template that enables easy implementation of the abstract factory design pattern.  <a href="classgko_1_1AbstractFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1AllocationError.html">AllocationError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1AllocationError.html" title="AllocationError is thrown if a memory allocation fails.">AllocationError</a> is thrown if a memory allocation fails.  <a href="classgko_1_1AllocationError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1amd__device.html">amd_device</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1amd__device.html" title="amd_device handles the number of executor on Amd devices and have the corresponding recursive_mutex.">amd_device</a> handles the number of executor on Amd devices and have the corresponding recursive_mutex.  <a href="classgko_1_1amd__device.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgko_1_1are__all__integral.html">are_all_integral</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates if all template arguments Args fulfill std::is_integral.  <a href="structgko_1_1are__all__integral.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgko_1_1are__all__integral_3_01First_00_01Args_8_8_8_01_4.html">are_all_integral&lt; First, Args... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1array.html">array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An array is a container which encapsulates fixed-sized arrays, stored on the <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a> tied to the array.  <a href="classgko_1_1array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1BadDimension.html">BadDimension</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1BadDimension.html" title="BadDimension is thrown if an operation is being applied to a LinOp with bad dimensions.">BadDimension</a> is thrown if an operation is being applied to a <a class="el" href="classgko_1_1LinOp.html">LinOp</a> with bad dimensions.  <a href="classgko_1_1BadDimension.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1BlockSizeError.html">BlockSizeError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1Error.html" title="The Error class is used to report exceptional behaviour in library functions.">Error</a> that denotes issues between block sizes and matrix dimensions.  <a href="classgko_1_1BlockSizeError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1Combination.html">Combination</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classgko_1_1Combination.html" title="The Combination class can be used to construct a linear combination of multiple linear operators c1 *...">Combination</a> class can be used to construct a linear combination of multiple linear operators <code>c1 * op1 + c2 * op2 + ... </code> <a href="classgko_1_1Combination.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1Composition.html">Composition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classgko_1_1Composition.html" title="The Composition class can be used to compose linear operators op1, op2, ..., opn and obtain the opera...">Composition</a> class can be used to compose linear operators <code>op1, op2, ..., opn</code> and obtain the operator <code>op1 * op2 * ... </code> <a href="classgko_1_1Composition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1ConvertibleTo.html">ConvertibleTo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1ConvertibleTo.html" title="ConvertibleTo interface is used to mark that the implementer can be converted to the object of Result...">ConvertibleTo</a> interface is used to mark that the implementer can be converted to the object of ResultType.  <a href="classgko_1_1ConvertibleTo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgko_1_1cpx__real__type.html">cpx_real_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the underlying real type of a complex number.  <a href="structgko_1_1cpx__real__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>cpx_real_type&lt; std::complex&lt; T &gt; &gt;</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for complex types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1CublasError.html">CublasError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1CublasError.html" title="CublasError is thrown when a cuBLAS routine throws a non-zero error code.">CublasError</a> is thrown when a cuBLAS routine throws a non-zero error code.  <a href="classgko_1_1CublasError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1CudaError.html">CudaError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1CudaError.html" title="CudaError is thrown when a CUDA routine throws a non-zero error code.">CudaError</a> is thrown when a CUDA routine throws a non-zero error code.  <a href="classgko_1_1CudaError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1CudaExecutor.html">CudaExecutor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a> subclass which represents the CUDA device.  <a href="classgko_1_1CudaExecutor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1CufftError.html">CufftError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1CufftError.html" title="CufftError is thrown when a cuFFT routine throws a non-zero error code.">CufftError</a> is thrown when a cuFFT routine throws a non-zero error code.  <a href="classgko_1_1CufftError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1CurandError.html">CurandError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1CurandError.html" title="CurandError is thrown when a cuRAND routine throws a non-zero error code.">CurandError</a> is thrown when a cuRAND routine throws a non-zero error code.  <a href="classgko_1_1CurandError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1CusparseError.html">CusparseError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1CusparseError.html" title="CusparseError is thrown when a cuSPARSE routine throws a non-zero error code.">CusparseError</a> is thrown when a cuSPARSE routine throws a non-zero error code.  <a href="classgko_1_1CusparseError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgko_1_1default__converter.html">default_converter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to convert objects of type <code>S</code> to objects of type <code>R</code> using static_cast.  <a href="structgko_1_1default__converter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1device__matrix__data.html">device_matrix_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This type is a device-side equivalent to <a class="el" href="structgko_1_1matrix__data.html" title="This structure is used as an intermediate data type to store a sparse matrix.">matrix_data</a>.  <a href="classgko_1_1device__matrix__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1DiagonalExtractable.html">DiagonalExtractable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The diagonal of a <a class="el" href="classgko_1_1LinOp.html">LinOp</a> implementing this interface can be extracted.  <a href="classgko_1_1DiagonalExtractable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1DiagonalLinOpExtractable.html">DiagonalLinOpExtractable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The diagonal of a <a class="el" href="classgko_1_1LinOp.html">LinOp</a> can be extracted.  <a href="classgko_1_1DiagonalLinOpExtractable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgko_1_1dim.html">dim</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type representing the dimensions of a multidimensional object.  <a href="structgko_1_1dim.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgko_1_1dim_3_011u_00_01DimensionType_01_4.html">dim&lt; 1u, DimensionType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1DimensionMismatch.html">DimensionMismatch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1DimensionMismatch.html" title="DimensionMismatch is thrown if an operation is being applied to LinOps of incompatible size.">DimensionMismatch</a> is thrown if an operation is being applied to LinOps of incompatible size.  <a href="classgko_1_1DimensionMismatch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1DpcppExecutor.html">DpcppExecutor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a> subclass which represents a DPC++ enhanced device.  <a href="classgko_1_1DpcppExecutor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1enable__parameters__type.html">enable_parameters_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classgko_1_1enable__parameters__type.html" title="The enable_parameters_type mixin is used to create a base implementation of the factory parameters st...">enable_parameters_type</a> mixin is used to create a base implementation of the factory parameters structure.  <a href="classgko_1_1enable__parameters__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1EnableAbsoluteComputation.html">EnableAbsoluteComputation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classgko_1_1EnableAbsoluteComputation.html" title="The EnableAbsoluteComputation mixin provides the default implementations of compute_absolute_linop an...">EnableAbsoluteComputation</a> mixin provides the default implementations of <code>compute_absolute_linop</code> and the absolute interface.  <a href="classgko_1_1EnableAbsoluteComputation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1EnableAbstractPolymorphicObject.html">EnableAbstractPolymorphicObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This mixin inherits from (a subclass of) <a class="el" href="classgko_1_1PolymorphicObject.html" title="A PolymorphicObject is the abstract base for all &quot;heavy&quot; objects in Ginkgo that behave polymorphicall...">PolymorphicObject</a> and provides a base implementation of a new abstract object.  <a href="classgko_1_1EnableAbstractPolymorphicObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1EnableCreateMethod.html">EnableCreateMethod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This mixin implements a static <code>create()</code> method on <code>ConcreteType</code> that dynamically allocates the memory, uses the passed-in arguments to construct the object, and returns an std::unique_ptr to such an object.  <a href="classgko_1_1EnableCreateMethod.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1EnableDefaultFactory.html">EnableDefaultFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This mixin provides a default implementation of a concrete factory.  <a href="classgko_1_1EnableDefaultFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1EnableLinOp.html">EnableLinOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classgko_1_1EnableLinOp.html" title="The EnableLinOp mixin can be used to provide sensible default implementations of the majority of the ...">EnableLinOp</a> mixin can be used to provide sensible default implementations of the majority of the <a class="el" href="classgko_1_1LinOp.html">LinOp</a> and <a class="el" href="classgko_1_1PolymorphicObject.html" title="A PolymorphicObject is the abstract base for all &quot;heavy&quot; objects in Ginkgo that behave polymorphicall...">PolymorphicObject</a> interface.  <a href="classgko_1_1EnableLinOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1EnablePolymorphicAssignment.html">EnablePolymorphicAssignment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This mixin is used to enable a default <a class="el" href="classgko_1_1PolymorphicObject.html#a5e6f713938293cfbe788d00480eb4d81" title="Copies another object into this object.">PolymorphicObject::copy_from()</a> implementation for objects that have implemented conversions between them.  <a href="classgko_1_1EnablePolymorphicAssignment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1EnablePolymorphicObject.html">EnablePolymorphicObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This mixin inherits from (a subclass of) <a class="el" href="classgko_1_1PolymorphicObject.html" title="A PolymorphicObject is the abstract base for all &quot;heavy&quot; objects in Ginkgo that behave polymorphicall...">PolymorphicObject</a> and provides a base implementation of a new concrete polymorphic object.  <a href="classgko_1_1EnablePolymorphicObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1Error.html">Error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classgko_1_1Error.html" title="The Error class is used to report exceptional behaviour in library functions.">Error</a> class is used to report exceptional behaviour in library functions.  <a href="classgko_1_1Error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1Executor.html">Executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first step in using the Ginkgo library consists of creating an executor.  <a href="classgko_1_1Executor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1executor__deleter.html">executor_deleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a deleter that uses an executor's <code>free</code> method to deallocate the data.  <a href="classgko_1_1executor__deleter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1executor__deleter_3_01T_0f_0e_4.html">executor_deleter&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1HipblasError.html">HipblasError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1HipblasError.html" title="HipblasError is thrown when a hipBLAS routine throws a non-zero error code.">HipblasError</a> is thrown when a hipBLAS routine throws a non-zero error code.  <a href="classgko_1_1HipblasError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1HipError.html">HipError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1HipError.html" title="HipError is thrown when a HIP routine throws a non-zero error code.">HipError</a> is thrown when a HIP routine throws a non-zero error code.  <a href="classgko_1_1HipError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1HipExecutor.html">HipExecutor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a> subclass which represents the HIP enhanced device.  <a href="classgko_1_1HipExecutor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1HipfftError.html">HipfftError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1HipfftError.html" title="HipfftError is thrown when a hipFFT routine throws a non-zero error code.">HipfftError</a> is thrown when a hipFFT routine throws a non-zero error code.  <a href="classgko_1_1HipfftError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1HiprandError.html">HiprandError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1HiprandError.html" title="HiprandError is thrown when a hipRAND routine throws a non-zero error code.">HiprandError</a> is thrown when a hipRAND routine throws a non-zero error code.  <a href="classgko_1_1HiprandError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1HipsparseError.html">HipsparseError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1HipsparseError.html" title="HipsparseError is thrown when a hipSPARSE routine throws a non-zero error code.">HipsparseError</a> is thrown when a hipSPARSE routine throws a non-zero error code.  <a href="classgko_1_1HipsparseError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1index__set.html">index_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An index set class represents an ordered set of intervals.  <a href="classgko_1_1index__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1KernelNotFound.html">KernelNotFound</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1KernelNotFound.html" title="KernelNotFound is thrown if Ginkgo cannot find a kernel which satisfies the criteria imposed by the i...">KernelNotFound</a> is thrown if Ginkgo cannot find a kernel which satisfies the criteria imposed by the input arguments.  <a href="classgko_1_1KernelNotFound.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1LinOp.html">LinOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1LinOpFactory.html">LinOpFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classgko_1_1LinOpFactory.html" title="A LinOpFactory represents a higher order mapping which transforms one linear operator into another.">LinOpFactory</a> represents a higher order mapping which transforms one linear operator into another.  <a href="classgko_1_1LinOpFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1machine__topology.html">machine_topology</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The machine topology class represents the hierarchical topology of a machine, including NUMA nodes, cores and PCI Devices.  <a href="classgko_1_1machine__topology.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1matrix__assembly__data.html">matrix_assembly_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure is used as an intermediate type to assemble a sparse matrix.  <a href="classgko_1_1matrix__assembly__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgko_1_1matrix__data.html">matrix_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure is used as an intermediate data type to store a sparse matrix.  <a href="structgko_1_1matrix__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgko_1_1matrix__data__entry.html">matrix_data_entry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to store nonzeros.  <a href="structgko_1_1matrix__data__entry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1MpiError.html">MpiError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1MpiError.html" title="MpiError is thrown when a MPI routine throws a non-zero error code.">MpiError</a> is thrown when a MPI routine throws a non-zero error code.  <a href="classgko_1_1MpiError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1NotCompiled.html">NotCompiled</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1NotCompiled.html" title="NotCompiled is thrown when attempting to call an operation which is a part of a module that was not c...">NotCompiled</a> is thrown when attempting to call an operation which is a part of a module that was not compiled on the system.  <a href="classgko_1_1NotCompiled.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1NotImplemented.html">NotImplemented</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1NotImplemented.html" title="NotImplemented is thrown in case an operation has not yet been implemented (but will be implemented i...">NotImplemented</a> is thrown in case an operation has not yet been implemented (but will be implemented in the future).  <a href="classgko_1_1NotImplemented.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1NotSupported.html">NotSupported</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1NotSupported.html" title="NotSupported is thrown in case it is not possible to perform the requested operation on the given obj...">NotSupported</a> is thrown in case it is not possible to perform the requested operation on the given object type.  <a href="classgko_1_1NotSupported.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1null__deleter.html">null_deleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a deleter that does not delete the object.  <a href="classgko_1_1null__deleter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1null__deleter_3_01T_0f_0e_4.html">null_deleter&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1nvidia__device.html">nvidia_device</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1nvidia__device.html" title="nvidia_device handles the number of executor on Nvidia devices and have the corresponding recursive_m...">nvidia_device</a> handles the number of executor on Nvidia devices and have the corresponding recursive_mutex.  <a href="classgko_1_1nvidia__device.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1OmpExecutor.html">OmpExecutor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a> subclass which represents the OpenMP device (typically CPU).  <a href="classgko_1_1OmpExecutor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1Operation.html">Operation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operations can be used to define functionalities whose implementations differ among devices.  <a href="classgko_1_1Operation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1OutOfBoundsError.html">OutOfBoundsError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1OutOfBoundsError.html" title="OutOfBoundsError is thrown if a memory access is detected to be out-of-bounds.">OutOfBoundsError</a> is thrown if a memory access is detected to be out-of-bounds.  <a href="classgko_1_1OutOfBoundsError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1Permutable.html">Permutable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear operators which support permutation should implement the <a class="el" href="classgko_1_1Permutable.html" title="Linear operators which support permutation should implement the Permutable interface.">Permutable</a> interface.  <a href="classgko_1_1Permutable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1Perturbation.html">Perturbation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classgko_1_1Perturbation.html" title="The Perturbation class can be used to construct a LinOp to represent the operation (identity + scalar...">Perturbation</a> class can be used to construct a <a class="el" href="classgko_1_1LinOp.html">LinOp</a> to represent the operation <code>(identity + scalar * basis * projector)</code>.  <a href="classgko_1_1Perturbation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1PolymorphicObject.html">PolymorphicObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classgko_1_1PolymorphicObject.html" title="A PolymorphicObject is the abstract base for all &quot;heavy&quot; objects in Ginkgo that behave polymorphicall...">PolymorphicObject</a> is the abstract base for all "heavy" objects in Ginkgo that behave polymorphically.  <a href="classgko_1_1PolymorphicObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1precision__reduction.html">precision_reduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to encode storage precisions of low precision algorithms.  <a href="classgko_1_1precision__reduction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1Preconditionable.html">Preconditionable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classgko_1_1LinOp.html">LinOp</a> implementing this interface can be preconditioned.  <a href="classgko_1_1Preconditionable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1range.html">range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A range is a multidimensional view of the memory.  <a href="classgko_1_1range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1ReadableFromMatrixData.html">ReadableFromMatrixData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classgko_1_1LinOp.html">LinOp</a> implementing this interface can read its data from a <a class="el" href="structgko_1_1matrix__data.html" title="This structure is used as an intermediate data type to store a sparse matrix.">matrix_data</a> structure.  <a href="classgko_1_1ReadableFromMatrixData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1ReferenceExecutor.html">ReferenceExecutor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a specialization of the <a class="el" href="classgko_1_1OmpExecutor.html" title="This is the Executor subclass which represents the OpenMP device (typically CPU).">OmpExecutor</a>, which runs the reference implementations of the kernels used for debugging purposes.  <a href="classgko_1_1ReferenceExecutor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1ScaledIdentityAddable.html">ScaledIdentityAddable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the operation M &lt;- a I + b M for matrix M, identity operator I and scalars a and b, where M is the calling object.  <a href="classgko_1_1ScaledIdentityAddable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1scoped__device__id__guard.html">scoped_device_id_guard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This move-only class uses RAII to set the device id within a scoped block, if necessary.  <a href="classgko_1_1scoped__device__id__guard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgko_1_1span.html">span</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A span is a lightweight structure used to create sub-ranges from other ranges.  <a href="structgko_1_1span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1stopping__status.html">stopping_status</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to keep track of the stopping status of one vector.  <a href="classgko_1_1stopping__status.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1StreamError.html">StreamError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1StreamError.html" title="StreamError is thrown if accessing a stream failed.">StreamError</a> is thrown if accessing a stream failed.  <a href="classgko_1_1StreamError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1Transposable.html">Transposable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear operators which support transposition should implement the <a class="el" href="classgko_1_1Transposable.html" title="Linear operators which support transposition should implement the Transposable interface.">Transposable</a> interface.  <a href="classgko_1_1Transposable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1truncated.html">truncated</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1UnsupportedMatrixProperty.html">UnsupportedMatrixProperty</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception throws if a matrix does not have a property required by a numerical method.  <a href="classgko_1_1UnsupportedMatrixProperty.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1UseComposition.html">UseComposition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classgko_1_1UseComposition.html" title="The UseComposition class can be used to store the composition information in LinOp.">UseComposition</a> class can be used to store the composition information in <a class="el" href="classgko_1_1LinOp.html">LinOp</a>.  <a href="classgko_1_1UseComposition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1ValueMismatch.html">ValueMismatch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1ValueMismatch.html" title="ValueMismatch is thrown if two values are not equal.">ValueMismatch</a> is thrown if two values are not equal.  <a href="classgko_1_1ValueMismatch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgko_1_1version.html">version</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure is used to represent versions of various Ginkgo modules.  <a href="structgko_1_1version.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1version__info.html">version_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ginkgo uses version numbers to label new features and to communicate backward compatibility guarantees:  <a href="classgko_1_1version__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1WritableToMatrixData.html">WritableToMatrixData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classgko_1_1LinOp.html">LinOp</a> implementing this interface can write its data to a <a class="el" href="structgko_1_1matrix__data.html" title="This structure is used as an intermediate data type to store a sparse matrix.">matrix_data</a> structure.  <a href="classgko_1_1WritableToMatrixData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aaf5744398f2a3ea78dc84cd854c2931d"><td class="memTemplParams" colspan="2"><a id="aaf5744398f2a3ea78dc84cd854c2931d"></a>
template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:aaf5744398f2a3ea78dc84cd854c2931d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Array</b> = <a class="el" href="classgko_1_1array.html">array</a>&lt; ValueType &gt;</td></tr>
<tr class="separator:aaf5744398f2a3ea78dc84cd854c2931d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24628d477cba68b31cea690572c51912"><td class="memTemplParams" colspan="2">template&lt;typename ConcreteFactory , typename ConcreteLinOp , typename ParametersType , typename PolymorphicBase  = LinOpFactory&gt; </td></tr>
<tr class="memitem:ga24628d477cba68b31cea690572c51912"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LinOp.html#ga24628d477cba68b31cea690572c51912">EnableDefaultLinOpFactory</a> = <a class="el" href="classgko_1_1EnableDefaultFactory.html">EnableDefaultFactory</a>&lt; ConcreteFactory, ConcreteLinOp, ParametersType, PolymorphicBase &gt;</td></tr>
<tr class="memdesc:ga24628d477cba68b31cea690572c51912"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an alias for the <a class="el" href="classgko_1_1EnableDefaultFactory.html" title="This mixin provides a default implementation of a concrete factory.">EnableDefaultFactory</a> mixin, which correctly sets the template parameters to enable a subclass of <a class="el" href="classgko_1_1LinOpFactory.html" title="A LinOpFactory represents a higher order mapping which transforms one linear operator into another.">LinOpFactory</a>.  <a href="group__LinOp.html#ga24628d477cba68b31cea690572c51912">More...</a><br /></td></tr>
<tr class="separator:ga24628d477cba68b31cea690572c51912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade83b7036a9f46ed97c750b7b67e9ecf"><td class="memItemLeft" align="right" valign="top"><a id="ade83b7036a9f46ed97c750b7b67e9ecf"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MachineTopology</b> = <a class="el" href="classgko_1_1machine__topology.html">machine_topology</a></td></tr>
<tr class="separator:ade83b7036a9f46ed97c750b7b67e9ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeede19206954d5c8ebd04c95cf63bb88"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeede19206954d5c8ebd04c95cf63bb88"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#aeede19206954d5c8ebd04c95cf63bb88">is_complex_s</a> = detail::is_complex_impl&lt; T &gt;</td></tr>
<tr class="memdesc:aeede19206954d5c8ebd04c95cf63bb88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to check if T is a complex value during compile time by accessing the <code>value</code> attribute of this struct.  <a href="namespacegko.html#aeede19206954d5c8ebd04c95cf63bb88">More...</a><br /></td></tr>
<tr class="separator:aeede19206954d5c8ebd04c95cf63bb88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3f195040a356643b3e8659554c7a48"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7a3f195040a356643b3e8659554c7a48"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a7a3f195040a356643b3e8659554c7a48">is_complex_or_scalar_s</a> = detail::is_complex_or_scalar_impl&lt; T &gt;</td></tr>
<tr class="memdesc:a7a3f195040a356643b3e8659554c7a48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to check if T is a complex or scalar value during compile time by accessing the <code>value</code> attribute of this struct.  <a href="namespacegko.html#a7a3f195040a356643b3e8659554c7a48">More...</a><br /></td></tr>
<tr class="separator:a7a3f195040a356643b3e8659554c7a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd46d554050c4ae90e84ea4fcd9a41f3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afd46d554050c4ae90e84ea4fcd9a41f3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#afd46d554050c4ae90e84ea4fcd9a41f3">remove_complex</a> = typename detail::remove_complex_s&lt; T &gt;::type</td></tr>
<tr class="memdesc:afd46d554050c4ae90e84ea4fcd9a41f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the type which removed the complex of complex/scalar type or the template parameter of class by accessing the <code>type</code> attribute of this struct.  <a href="namespacegko.html#afd46d554050c4ae90e84ea4fcd9a41f3">More...</a><br /></td></tr>
<tr class="separator:afd46d554050c4ae90e84ea4fcd9a41f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc281c8ff5bfa4fd6f25afcce466b1af"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acc281c8ff5bfa4fd6f25afcce466b1af"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#acc281c8ff5bfa4fd6f25afcce466b1af">to_complex</a> = typename detail::to_complex_s&lt; T &gt;::type</td></tr>
<tr class="memdesc:acc281c8ff5bfa4fd6f25afcce466b1af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the type which adds the complex of complex/scalar type or the template parameter of class by accessing the <code>type</code> attribute of this struct.  <a href="namespacegko.html#acc281c8ff5bfa4fd6f25afcce466b1af">More...</a><br /></td></tr>
<tr class="separator:acc281c8ff5bfa4fd6f25afcce466b1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1eb45b2e5273be609ca5746089d18d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ace1eb45b2e5273be609ca5746089d18d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#ace1eb45b2e5273be609ca5746089d18d">to_real</a> = <a class="el" href="namespacegko.html#afd46d554050c4ae90e84ea4fcd9a41f3">remove_complex</a>&lt; T &gt;</td></tr>
<tr class="memdesc:ace1eb45b2e5273be609ca5746089d18d"><td class="mdescLeft">&#160;</td><td class="mdescRight">to_real is alias of remove_complex  <a href="namespacegko.html#ace1eb45b2e5273be609ca5746089d18d">More...</a><br /></td></tr>
<tr class="separator:ace1eb45b2e5273be609ca5746089d18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6362f751c7753cf4fa0a4771d56e8ede"><td class="memTemplParams" colspan="2"><a id="a6362f751c7753cf4fa0a4771d56e8ede"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6362f751c7753cf4fa0a4771d56e8ede"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a6362f751c7753cf4fa0a4771d56e8ede">next_precision</a> = typename detail::next_precision_impl&lt; T &gt;::type</td></tr>
<tr class="memdesc:a6362f751c7753cf4fa0a4771d56e8ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the next type in the singly-linked precision list. <br /></td></tr>
<tr class="separator:a6362f751c7753cf4fa0a4771d56e8ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71559818fee20b97bc6ea6712ec75034"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a71559818fee20b97bc6ea6712ec75034"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a71559818fee20b97bc6ea6712ec75034">previous_precision</a> = <a class="el" href="namespacegko.html#a6362f751c7753cf4fa0a4771d56e8ede">next_precision</a>&lt; T &gt;</td></tr>
<tr class="memdesc:a71559818fee20b97bc6ea6712ec75034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the previous type in the singly-linked precision list.  <a href="namespacegko.html#a71559818fee20b97bc6ea6712ec75034">More...</a><br /></td></tr>
<tr class="separator:a71559818fee20b97bc6ea6712ec75034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d71c1f4bd1b654df1e561ea7a811f2"><td class="memTemplParams" colspan="2"><a id="ab5d71c1f4bd1b654df1e561ea7a811f2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab5d71c1f4bd1b654df1e561ea7a811f2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#ab5d71c1f4bd1b654df1e561ea7a811f2">reduce_precision</a> = typename detail::reduce_precision_impl&lt; T &gt;::type</td></tr>
<tr class="memdesc:ab5d71c1f4bd1b654df1e561ea7a811f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the next type in the hierarchy with lower precision than T. <br /></td></tr>
<tr class="separator:ab5d71c1f4bd1b654df1e561ea7a811f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373c2b4782d95e675d7e91a75bab101d"><td class="memTemplParams" colspan="2"><a id="a373c2b4782d95e675d7e91a75bab101d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a373c2b4782d95e675d7e91a75bab101d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a373c2b4782d95e675d7e91a75bab101d">increase_precision</a> = typename detail::increase_precision_impl&lt; T &gt;::type</td></tr>
<tr class="memdesc:a373c2b4782d95e675d7e91a75bab101d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the next type in the hierarchy with higher precision than T. <br /></td></tr>
<tr class="separator:a373c2b4782d95e675d7e91a75bab101d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6837b759dc528737540a83c79fbdda29"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a6837b759dc528737540a83c79fbdda29"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a6837b759dc528737540a83c79fbdda29">highest_precision</a> = typename detail::highest_precision_variadic&lt; Ts... &gt;::type</td></tr>
<tr class="memdesc:a6837b759dc528737540a83c79fbdda29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the smallest arithmetic type that is able to store elements of all template parameter types exactly.  <a href="namespacegko.html#a6837b759dc528737540a83c79fbdda29">More...</a><br /></td></tr>
<tr class="separator:a6837b759dc528737540a83c79fbdda29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512fc29f227f5d452e13787bf3df7d48"><td class="memTemplParams" colspan="2"><a id="a512fc29f227f5d452e13787bf3df7d48"></a>
template&lt;typename T , size_type Limit = sizeof(uint16) * byte_size&gt; </td></tr>
<tr class="memitem:a512fc29f227f5d452e13787bf3df7d48"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a512fc29f227f5d452e13787bf3df7d48">truncate_type</a> = std::conditional_t&lt; detail::type_size_impl&lt; T &gt;::value &gt;=2 *Limit, typename detail::truncate_type_impl&lt; T &gt;::type, T &gt;</td></tr>
<tr class="memdesc:a512fc29f227f5d452e13787bf3df7d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncates the type by half (by dropping bits), but ensures that it is at least <code>Limit</code> bits wide. <br /></td></tr>
<tr class="separator:a512fc29f227f5d452e13787bf3df7d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e5c95df0ae4e47aab2f604a22d98ee7"><td class="memItemLeft" align="right" valign="top"><a id="a6e5c95df0ae4e47aab2f604a22d98ee7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#a6e5c95df0ae4e47aab2f604a22d98ee7">size_type</a> = std::size_t</td></tr>
<tr class="memdesc:a6e5c95df0ae4e47aab2f604a22d98ee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integral type used for allocation quantities. <br /></td></tr>
<tr class="separator:a6e5c95df0ae4e47aab2f604a22d98ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a8c26c7cb547663bff3cc1df3c8db0"><td class="memItemLeft" align="right" valign="top"><a id="ad7a8c26c7cb547663bff3cc1df3c8db0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#ad7a8c26c7cb547663bff3cc1df3c8db0">int8</a> = std::int8_t</td></tr>
<tr class="memdesc:ad7a8c26c7cb547663bff3cc1df3c8db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">8-bit signed integral type. <br /></td></tr>
<tr class="separator:ad7a8c26c7cb547663bff3cc1df3c8db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d2e6df1a5280b092afd1e5d9fabeed"><td class="memItemLeft" align="right" valign="top"><a id="a26d2e6df1a5280b092afd1e5d9fabeed"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#a26d2e6df1a5280b092afd1e5d9fabeed">int16</a> = std::int16_t</td></tr>
<tr class="memdesc:a26d2e6df1a5280b092afd1e5d9fabeed"><td class="mdescLeft">&#160;</td><td class="mdescRight">16-bit signed integral type. <br /></td></tr>
<tr class="separator:a26d2e6df1a5280b092afd1e5d9fabeed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec26caa2379a21a8d0cde611559fff6"><td class="memItemLeft" align="right" valign="top"><a id="a1ec26caa2379a21a8d0cde611559fff6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#a1ec26caa2379a21a8d0cde611559fff6">int32</a> = std::int32_t</td></tr>
<tr class="memdesc:a1ec26caa2379a21a8d0cde611559fff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">32-bit signed integral type. <br /></td></tr>
<tr class="separator:a1ec26caa2379a21a8d0cde611559fff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c57dbf3168b1ecad3ea133aaf2efbc1"><td class="memItemLeft" align="right" valign="top"><a id="a6c57dbf3168b1ecad3ea133aaf2efbc1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#a6c57dbf3168b1ecad3ea133aaf2efbc1">int64</a> = std::int64_t</td></tr>
<tr class="memdesc:a6c57dbf3168b1ecad3ea133aaf2efbc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit signed integral type. <br /></td></tr>
<tr class="separator:a6c57dbf3168b1ecad3ea133aaf2efbc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3950fc3732811a8563484e5098c31531"><td class="memItemLeft" align="right" valign="top"><a id="a3950fc3732811a8563484e5098c31531"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#a3950fc3732811a8563484e5098c31531">uint8</a> = std::uint8_t</td></tr>
<tr class="memdesc:a3950fc3732811a8563484e5098c31531"><td class="mdescLeft">&#160;</td><td class="mdescRight">8-bit unsigned integral type. <br /></td></tr>
<tr class="separator:a3950fc3732811a8563484e5098c31531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb8517627d37e0c4ff4f39a5303a795"><td class="memItemLeft" align="right" valign="top"><a id="afdb8517627d37e0c4ff4f39a5303a795"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#afdb8517627d37e0c4ff4f39a5303a795">uint16</a> = std::uint16_t</td></tr>
<tr class="memdesc:afdb8517627d37e0c4ff4f39a5303a795"><td class="mdescLeft">&#160;</td><td class="mdescRight">16-bit unsigned integral type. <br /></td></tr>
<tr class="separator:afdb8517627d37e0c4ff4f39a5303a795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318c831e3fe269ba04c6ed8bf5a71073"><td class="memItemLeft" align="right" valign="top"><a id="a318c831e3fe269ba04c6ed8bf5a71073"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#a318c831e3fe269ba04c6ed8bf5a71073">uint32</a> = std::uint32_t</td></tr>
<tr class="memdesc:a318c831e3fe269ba04c6ed8bf5a71073"><td class="mdescLeft">&#160;</td><td class="mdescRight">32-bit unsigned integral type. <br /></td></tr>
<tr class="separator:a318c831e3fe269ba04c6ed8bf5a71073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad54a79afecd57aabbb04b1dc611ae55e"><td class="memItemLeft" align="right" valign="top"><a id="ad54a79afecd57aabbb04b1dc611ae55e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#ad54a79afecd57aabbb04b1dc611ae55e">uint64</a> = std::uint64_t</td></tr>
<tr class="memdesc:ad54a79afecd57aabbb04b1dc611ae55e"><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit unsigned integral type. <br /></td></tr>
<tr class="separator:ad54a79afecd57aabbb04b1dc611ae55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0913bfb81622f6bdde52884015c2a4ed"><td class="memItemLeft" align="right" valign="top"><a id="a0913bfb81622f6bdde52884015c2a4ed"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#a0913bfb81622f6bdde52884015c2a4ed">uintptr</a> = std::uintptr_t</td></tr>
<tr class="memdesc:a0913bfb81622f6bdde52884015c2a4ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type capable of holding a pointer to void. <br /></td></tr>
<tr class="separator:a0913bfb81622f6bdde52884015c2a4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86477c0acba18c50cac69112d791dfa6"><td class="memItemLeft" align="right" valign="top"><a id="a86477c0acba18c50cac69112d791dfa6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#a86477c0acba18c50cac69112d791dfa6">float16</a> = half</td></tr>
<tr class="memdesc:a86477c0acba18c50cac69112d791dfa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Half precision floating point type. <br /></td></tr>
<tr class="separator:a86477c0acba18c50cac69112d791dfa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5dbd886493d4ccaba6a7a1ba74896c"><td class="memItemLeft" align="right" valign="top"><a id="a0b5dbd886493d4ccaba6a7a1ba74896c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#a0b5dbd886493d4ccaba6a7a1ba74896c">float32</a> = float</td></tr>
<tr class="memdesc:a0b5dbd886493d4ccaba6a7a1ba74896c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single precision floating point type. <br /></td></tr>
<tr class="separator:a0b5dbd886493d4ccaba6a7a1ba74896c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c7a433d814b8b37d0bc2a9c57fbe65"><td class="memItemLeft" align="right" valign="top"><a id="a75c7a433d814b8b37d0bc2a9c57fbe65"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#a75c7a433d814b8b37d0bc2a9c57fbe65">float64</a> = double</td></tr>
<tr class="memdesc:a75c7a433d814b8b37d0bc2a9c57fbe65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double precision floating point type. <br /></td></tr>
<tr class="separator:a75c7a433d814b8b37d0bc2a9c57fbe65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3257beda99ac9180b501912be5caa5f"><td class="memItemLeft" align="right" valign="top"><a id="ae3257beda99ac9180b501912be5caa5f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#ae3257beda99ac9180b501912be5caa5f">full_precision</a> = double</td></tr>
<tr class="memdesc:ae3257beda99ac9180b501912be5caa5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The most precise floating-point type. <br /></td></tr>
<tr class="separator:ae3257beda99ac9180b501912be5caa5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d44e117d2f74b34bdc83ac5c0c6b605"><td class="memItemLeft" align="right" valign="top"><a id="a1d44e117d2f74b34bdc83ac5c0c6b605"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#a1d44e117d2f74b34bdc83ac5c0c6b605">default_precision</a> = double</td></tr>
<tr class="memdesc:a1d44e117d2f74b34bdc83ac5c0c6b605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Precision used if no precision is explicitly specified. <br /></td></tr>
<tr class="separator:a1d44e117d2f74b34bdc83ac5c0c6b605"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:afbed8e2cbd3ee4ca962e12f688858bdb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#afbed8e2cbd3ee4ca962e12f688858bdb">allocation_mode</a> { <b>device</b>, 
<b>unified_global</b>, 
<b>unified_host</b>
 }</td></tr>
<tr class="memdesc:afbed8e2cbd3ee4ca962e12f688858bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the mode of allocation for CUDA/HIP GPUs.  <a href="namespacegko.html#afbed8e2cbd3ee4ca962e12f688858bdb">More...</a><br /></td></tr>
<tr class="separator:afbed8e2cbd3ee4ca962e12f688858bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae749a5ea11a93c1bcc9158d9a6e9fb68"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#ae749a5ea11a93c1bcc9158d9a6e9fb68">layout_type</a> { <a class="el" href="namespacegko.html#ae749a5ea11a93c1bcc9158d9a6e9fb68af1f713c9e000f5d3f280adbd124df4f5">layout_type::array</a>, 
<a class="el" href="namespacegko.html#ae749a5ea11a93c1bcc9158d9a6e9fb68af5d7aa3ba4929cc12dc51a92c59fabd3">layout_type::coordinate</a>
 }</td></tr>
<tr class="memdesc:ae749a5ea11a93c1bcc9158d9a6e9fb68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the layout type when writing data in matrix market format.  <a href="namespacegko.html#ae749a5ea11a93c1bcc9158d9a6e9fb68">More...</a><br /></td></tr>
<tr class="separator:ae749a5ea11a93c1bcc9158d9a6e9fb68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a12e62081e2511f958dc2c9f1cc73c11d"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a12e62081e2511f958dc2c9f1cc73c11d"><td class="memTemplItemLeft" align="right" valign="top">ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a12e62081e2511f958dc2c9f1cc73c11d">reduce_add</a> (const <a class="el" href="classgko_1_1array.html">array</a>&lt; ValueType &gt; &amp;input_arr, const ValueType init_val=0)</td></tr>
<tr class="memdesc:a12e62081e2511f958dc2c9f1cc73c11d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce (sum) the values in the array.  <a href="namespacegko.html#a12e62081e2511f958dc2c9f1cc73c11d">More...</a><br /></td></tr>
<tr class="separator:a12e62081e2511f958dc2c9f1cc73c11d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718bb2876f514b73c900f72fcc9d464e"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a718bb2876f514b73c900f72fcc9d464e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a718bb2876f514b73c900f72fcc9d464e">reduce_add</a> (const <a class="el" href="classgko_1_1array.html">array</a>&lt; ValueType &gt; &amp;input_arr, <a class="el" href="classgko_1_1array.html">array</a>&lt; ValueType &gt; &amp;result)</td></tr>
<tr class="memdesc:a718bb2876f514b73c900f72fcc9d464e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce (sum) the values in the array.  <a href="namespacegko.html#a718bb2876f514b73c900f72fcc9d464e">More...</a><br /></td></tr>
<tr class="separator:a718bb2876f514b73c900f72fcc9d464e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c63e16608df2b83cf706b490bcef72"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:ab6c63e16608df2b83cf706b490bcef72"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgko_1_1array.html">array</a>&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#ab6c63e16608df2b83cf706b490bcef72">make_array_view</a> (std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt; exec, <a class="el" href="namespacegko.html#a6e5c95df0ae4e47aab2f604a22d98ee7">size_type</a> size, ValueType *data)</td></tr>
<tr class="memdesc:ab6c63e16608df2b83cf706b490bcef72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to create an array view deducing the value type.  <a href="namespacegko.html#ab6c63e16608df2b83cf706b490bcef72">More...</a><br /></td></tr>
<tr class="separator:ab6c63e16608df2b83cf706b490bcef72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3c05a831ad72e1383bf393ff43e013"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:aaf3c05a831ad72e1383bf393ff43e013"><td class="memTemplItemLeft" align="right" valign="top">detail::const_array_view&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#aaf3c05a831ad72e1383bf393ff43e013">make_const_array_view</a> (std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt; exec, <a class="el" href="namespacegko.html#a6e5c95df0ae4e47aab2f604a22d98ee7">size_type</a> size, const ValueType *data)</td></tr>
<tr class="memdesc:aaf3c05a831ad72e1383bf393ff43e013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to create a const array view deducing the value type.  <a href="namespacegko.html#aaf3c05a831ad72e1383bf393ff43e013">More...</a><br /></td></tr>
<tr class="separator:aaf3c05a831ad72e1383bf393ff43e013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c3716da36cbedc000aa24006b0bd46"><td class="memTemplParams" colspan="2">template&lt;size_type Dimensionality, typename DimensionType &gt; </td></tr>
<tr class="memitem:a74c3716da36cbedc000aa24006b0bd46"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a74c3716da36cbedc000aa24006b0bd46">operator!=</a> (const <a class="el" href="structgko_1_1dim.html">dim</a>&lt; Dimensionality, DimensionType &gt; &amp;x, const <a class="el" href="structgko_1_1dim.html">dim</a>&lt; Dimensionality, DimensionType &gt; &amp;y)</td></tr>
<tr class="memdesc:a74c3716da36cbedc000aa24006b0bd46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two dim objects are different.  <a href="namespacegko.html#a74c3716da36cbedc000aa24006b0bd46">More...</a><br /></td></tr>
<tr class="separator:a74c3716da36cbedc000aa24006b0bd46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6a9d7018703d6d1f2140054e2afe4a"><td class="memTemplParams" colspan="2">template&lt;typename DimensionType &gt; </td></tr>
<tr class="memitem:a9b6a9d7018703d6d1f2140054e2afe4a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgko_1_1dim.html">dim</a>&lt; 2, DimensionType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a9b6a9d7018703d6d1f2140054e2afe4a">transpose</a> (const <a class="el" href="structgko_1_1dim.html">dim</a>&lt; 2, DimensionType &gt; &amp;dimensions) noexcept</td></tr>
<tr class="memdesc:a9b6a9d7018703d6d1f2140054e2afe4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="structgko_1_1dim.html">dim&lt;2&gt;</a> object with its dimensions swapped.  <a href="namespacegko.html#a9b6a9d7018703d6d1f2140054e2afe4a">More...</a><br /></td></tr>
<tr class="separator:a9b6a9d7018703d6d1f2140054e2afe4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3e79911bb6145d7ba865dbe436b915"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9b3e79911bb6145d7ba865dbe436b915"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a9b3e79911bb6145d7ba865dbe436b915">is_complex</a> ()</td></tr>
<tr class="memdesc:a9b3e79911bb6145d7ba865dbe436b915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if T is a complex type.  <a href="namespacegko.html#a9b3e79911bb6145d7ba865dbe436b915">More...</a><br /></td></tr>
<tr class="separator:a9b3e79911bb6145d7ba865dbe436b915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6881ebae53e15cb88342c0540d953f59"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6881ebae53e15cb88342c0540d953f59"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a6881ebae53e15cb88342c0540d953f59">is_complex_or_scalar</a> ()</td></tr>
<tr class="memdesc:a6881ebae53e15cb88342c0540d953f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if T is a complex/scalar type.  <a href="namespacegko.html#a6881ebae53e15cb88342c0540d953f59">More...</a><br /></td></tr>
<tr class="separator:a6881ebae53e15cb88342c0540d953f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9c197f1db98fdc874f8907978ad114"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5f9c197f1db98fdc874f8907978ad114"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegko.html#ab5d71c1f4bd1b654df1e561ea7a811f2">reduce_precision</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a5f9c197f1db98fdc874f8907978ad114">round_down</a> (T val)</td></tr>
<tr class="memdesc:a5f9c197f1db98fdc874f8907978ad114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces the precision of the input parameter.  <a href="namespacegko.html#a5f9c197f1db98fdc874f8907978ad114">More...</a><br /></td></tr>
<tr class="separator:a5f9c197f1db98fdc874f8907978ad114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45d1c855f31d2f8c1d3d799f2cf21c6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad45d1c855f31d2f8c1d3d799f2cf21c6"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegko.html#a373c2b4782d95e675d7e91a75bab101d">increase_precision</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#ad45d1c855f31d2f8c1d3d799f2cf21c6">round_up</a> (T val)</td></tr>
<tr class="memdesc:ad45d1c855f31d2f8c1d3d799f2cf21c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increases the precision of the input parameter.  <a href="namespacegko.html#ad45d1c855f31d2f8c1d3d799f2cf21c6">More...</a><br /></td></tr>
<tr class="separator:ad45d1c855f31d2f8c1d3d799f2cf21c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93065a86872e6511b701b73b75823483"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegko.html#a6c57dbf3168b1ecad3ea133aaf2efbc1">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#a93065a86872e6511b701b73b75823483">ceildiv</a> (<a class="el" href="namespacegko.html#a6c57dbf3168b1ecad3ea133aaf2efbc1">int64</a> num, <a class="el" href="namespacegko.html#a6c57dbf3168b1ecad3ea133aaf2efbc1">int64</a> den)</td></tr>
<tr class="memdesc:a93065a86872e6511b701b73b75823483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs integer division with rounding up.  <a href="namespacegko.html#a93065a86872e6511b701b73b75823483">More...</a><br /></td></tr>
<tr class="separator:a93065a86872e6511b701b73b75823483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70dbe01ff95c7b953d3d737424c6feb5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a70dbe01ff95c7b953d3d737424c6feb5"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a70dbe01ff95c7b953d3d737424c6feb5">zero</a> ()</td></tr>
<tr class="memdesc:a70dbe01ff95c7b953d3d737424c6feb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the additive identity for T.  <a href="namespacegko.html#a70dbe01ff95c7b953d3d737424c6feb5">More...</a><br /></td></tr>
<tr class="separator:a70dbe01ff95c7b953d3d737424c6feb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1cd7be946b9a2c15b01b744cf3e732"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9f1cd7be946b9a2c15b01b744cf3e732"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a9f1cd7be946b9a2c15b01b744cf3e732">zero</a> (const T &amp;)</td></tr>
<tr class="memdesc:a9f1cd7be946b9a2c15b01b744cf3e732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the additive identity for T.  <a href="namespacegko.html#a9f1cd7be946b9a2c15b01b744cf3e732">More...</a><br /></td></tr>
<tr class="separator:a9f1cd7be946b9a2c15b01b744cf3e732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0059e27f8f4bc348ff65c1e60caf47c8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0059e27f8f4bc348ff65c1e60caf47c8"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a0059e27f8f4bc348ff65c1e60caf47c8">one</a> ()</td></tr>
<tr class="memdesc:a0059e27f8f4bc348ff65c1e60caf47c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the multiplicative identity for T.  <a href="namespacegko.html#a0059e27f8f4bc348ff65c1e60caf47c8">More...</a><br /></td></tr>
<tr class="separator:a0059e27f8f4bc348ff65c1e60caf47c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f16ecf0a759f46259cf9518f1e4568"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab4f16ecf0a759f46259cf9518f1e4568"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#ab4f16ecf0a759f46259cf9518f1e4568">one</a> (const T &amp;)</td></tr>
<tr class="memdesc:ab4f16ecf0a759f46259cf9518f1e4568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the multiplicative identity for T.  <a href="namespacegko.html#ab4f16ecf0a759f46259cf9518f1e4568">More...</a><br /></td></tr>
<tr class="separator:ab4f16ecf0a759f46259cf9518f1e4568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785976e6dbc9d8511325617ca46040bf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a785976e6dbc9d8511325617ca46040bf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a785976e6dbc9d8511325617ca46040bf">is_zero</a> (T value)</td></tr>
<tr class="memdesc:a785976e6dbc9d8511325617ca46040bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if and only if the given value is zero.  <a href="namespacegko.html#a785976e6dbc9d8511325617ca46040bf">More...</a><br /></td></tr>
<tr class="separator:a785976e6dbc9d8511325617ca46040bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9b29733e6eb45475a2b84f79a6d012"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aef9b29733e6eb45475a2b84f79a6d012"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#aef9b29733e6eb45475a2b84f79a6d012">is_nonzero</a> (T value)</td></tr>
<tr class="memdesc:aef9b29733e6eb45475a2b84f79a6d012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if and only if the given value is not zero.  <a href="namespacegko.html#aef9b29733e6eb45475a2b84f79a6d012">More...</a><br /></td></tr>
<tr class="separator:aef9b29733e6eb45475a2b84f79a6d012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1812df45c6ec07780d579a12b64c753"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af1812df45c6ec07780d579a12b64c753"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#af1812df45c6ec07780d579a12b64c753">max</a> (const T &amp;x, const T &amp;y)</td></tr>
<tr class="memdesc:af1812df45c6ec07780d579a12b64c753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the larger of the arguments.  <a href="namespacegko.html#af1812df45c6ec07780d579a12b64c753">More...</a><br /></td></tr>
<tr class="separator:af1812df45c6ec07780d579a12b64c753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf8487194bcb40b528969c187a413a0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaaf8487194bcb40b528969c187a413a0"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#aaaf8487194bcb40b528969c187a413a0">min</a> (const T &amp;x, const T &amp;y)</td></tr>
<tr class="memdesc:aaaf8487194bcb40b528969c187a413a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smaller of the arguments.  <a href="namespacegko.html#aaaf8487194bcb40b528969c187a413a0">More...</a><br /></td></tr>
<tr class="separator:aaaf8487194bcb40b528969c187a413a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21648097306adbabc6234b4609ce297"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af21648097306adbabc6234b4609ce297"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#af21648097306adbabc6234b4609ce297">real</a> (const T &amp;x)</td></tr>
<tr class="memdesc:af21648097306adbabc6234b4609ce297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the real part of the object.  <a href="namespacegko.html#af21648097306adbabc6234b4609ce297">More...</a><br /></td></tr>
<tr class="separator:af21648097306adbabc6234b4609ce297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795f649e3744fbfe128aec0b0f928aaa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a795f649e3744fbfe128aec0b0f928aaa"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a795f649e3744fbfe128aec0b0f928aaa">imag</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a795f649e3744fbfe128aec0b0f928aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the imaginary part of the object.  <a href="namespacegko.html#a795f649e3744fbfe128aec0b0f928aaa">More...</a><br /></td></tr>
<tr class="separator:a795f649e3744fbfe128aec0b0f928aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79fd5c1fb85403796c40c0a916a15f2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad79fd5c1fb85403796c40c0a916a15f2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#ad79fd5c1fb85403796c40c0a916a15f2">conj</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ad79fd5c1fb85403796c40c0a916a15f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the conjugate of an object.  <a href="namespacegko.html#ad79fd5c1fb85403796c40c0a916a15f2">More...</a><br /></td></tr>
<tr class="separator:ad79fd5c1fb85403796c40c0a916a15f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb55709b10d707b2cbef803832aa834"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abbb55709b10d707b2cbef803832aa834"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#abbb55709b10d707b2cbef803832aa834">squared_norm</a> (const T &amp;x) -&gt; decltype(<a class="el" href="namespacegko.html#af21648097306adbabc6234b4609ce297">real</a>(<a class="el" href="namespacegko.html#ad79fd5c1fb85403796c40c0a916a15f2">conj</a>(x) *x))</td></tr>
<tr class="memdesc:abbb55709b10d707b2cbef803832aa834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the squared norm of the object.  <a href="namespacegko.html#abbb55709b10d707b2cbef803832aa834">More...</a><br /></td></tr>
<tr class="separator:abbb55709b10d707b2cbef803832aa834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb470aaf293d7c5548392b2f451e8e4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adeb470aaf293d7c5548392b2f451e8e4"><td class="memTemplItemLeft" align="right" valign="top">constexpr xstd::enable_if_t&lt;!<a class="el" href="namespacegko.html#aeede19206954d5c8ebd04c95cf63bb88">is_complex_s</a>&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#adeb470aaf293d7c5548392b2f451e8e4">abs</a> (const T &amp;x)</td></tr>
<tr class="memdesc:adeb470aaf293d7c5548392b2f451e8e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute value of the object.  <a href="namespacegko.html#adeb470aaf293d7c5548392b2f451e8e4">More...</a><br /></td></tr>
<tr class="separator:adeb470aaf293d7c5548392b2f451e8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac677f1a4d6794c15b200b4a6cc5b1bbd"><td class="memTemplParams" colspan="2"><a id="ac677f1a4d6794c15b200b4a6cc5b1bbd"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac677f1a4d6794c15b200b4a6cc5b1bbd"><td class="memTemplItemLeft" align="right" valign="top">constexpr xstd::enable_if_t&lt; <a class="el" href="namespacegko.html#aeede19206954d5c8ebd04c95cf63bb88">is_complex_s</a>&lt; T &gt;::value, <a class="el" href="namespacegko.html#afd46d554050c4ae90e84ea4fcd9a41f3">remove_complex</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (const T &amp;x)</td></tr>
<tr class="separator:ac677f1a4d6794c15b200b4a6cc5b1bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0603ce0a60183a6698ac9b523694fb68"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0603ce0a60183a6698ac9b523694fb68"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a0603ce0a60183a6698ac9b523694fb68">pi</a> ()</td></tr>
<tr class="memdesc:a0603ce0a60183a6698ac9b523694fb68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of pi.  <a href="namespacegko.html#a0603ce0a60183a6698ac9b523694fb68">More...</a><br /></td></tr>
<tr class="separator:a0603ce0a60183a6698ac9b523694fb68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92d450201f5b215901c0f8c3e2e376c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab92d450201f5b215901c0f8c3e2e376c"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::complex&lt; <a class="el" href="namespacegko.html#afd46d554050c4ae90e84ea4fcd9a41f3">remove_complex</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#ab92d450201f5b215901c0f8c3e2e376c">unit_root</a> (<a class="el" href="namespacegko.html#a6c57dbf3168b1ecad3ea133aaf2efbc1">int64</a> n, <a class="el" href="namespacegko.html#a6c57dbf3168b1ecad3ea133aaf2efbc1">int64</a> k=1)</td></tr>
<tr class="memdesc:ab92d450201f5b215901c0f8c3e2e376c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of exp(2 * pi * i * k / n), i.e.  <a href="namespacegko.html#ab92d450201f5b215901c0f8c3e2e376c">More...</a><br /></td></tr>
<tr class="separator:ab92d450201f5b215901c0f8c3e2e376c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eea40e4123a3fdb60fcd92f902c6d6d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4eea40e4123a3fdb60fcd92f902c6d6d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegko.html#a318c831e3fe269ba04c6ed8bf5a71073">uint32</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a4eea40e4123a3fdb60fcd92f902c6d6d">get_significant_bit</a> (const T &amp;n, <a class="el" href="namespacegko.html#a318c831e3fe269ba04c6ed8bf5a71073">uint32</a> hint=0u) noexcept</td></tr>
<tr class="memdesc:a4eea40e4123a3fdb60fcd92f902c6d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of the most significant bit of the number.  <a href="namespacegko.html#a4eea40e4123a3fdb60fcd92f902c6d6d">More...</a><br /></td></tr>
<tr class="separator:a4eea40e4123a3fdb60fcd92f902c6d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39645fe8148a8a812a9528865a77600"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad39645fe8148a8a812a9528865a77600"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#ad39645fe8148a8a812a9528865a77600">get_superior_power</a> (const T &amp;base, const T &amp;limit, const T &amp;hint=T{1}) noexcept</td></tr>
<tr class="memdesc:ad39645fe8148a8a812a9528865a77600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest power of <code>base</code> not smaller than <code>limit</code>.  <a href="namespacegko.html#ad39645fe8148a8a812a9528865a77600">More...</a><br /></td></tr>
<tr class="separator:ad39645fe8148a8a812a9528865a77600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58498d28d199c188555a48fda471f103"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a58498d28d199c188555a48fda471f103"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!<a class="el" href="namespacegko.html#aeede19206954d5c8ebd04c95cf63bb88">is_complex_s</a>&lt; T &gt;::value, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a58498d28d199c188555a48fda471f103">is_finite</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a58498d28d199c188555a48fda471f103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a floating point number is finite, meaning it is neither +/- infinity nor NaN.  <a href="namespacegko.html#a58498d28d199c188555a48fda471f103">More...</a><br /></td></tr>
<tr class="separator:a58498d28d199c188555a48fda471f103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a737d84b498f462463fa40846e22aec6d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a737d84b498f462463fa40846e22aec6d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacegko.html#aeede19206954d5c8ebd04c95cf63bb88">is_complex_s</a>&lt; T &gt;::value, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a737d84b498f462463fa40846e22aec6d">is_finite</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a737d84b498f462463fa40846e22aec6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if all components of a complex value are finite, meaning they are neither +/- infinity nor NaN.  <a href="namespacegko.html#a737d84b498f462463fa40846e22aec6d">More...</a><br /></td></tr>
<tr class="separator:a737d84b498f462463fa40846e22aec6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1470fdc2a75dcda76bea4b879a29886"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa1470fdc2a75dcda76bea4b879a29886"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#aa1470fdc2a75dcda76bea4b879a29886">safe_divide</a> (T a, T b)</td></tr>
<tr class="memdesc:aa1470fdc2a75dcda76bea4b879a29886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the quotient of the given parameters, guarding against division by zero.  <a href="namespacegko.html#aa1470fdc2a75dcda76bea4b879a29886">More...</a><br /></td></tr>
<tr class="separator:aa1470fdc2a75dcda76bea4b879a29886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b5bfaadc2c5a40f17f0459a3aa412d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae8b5bfaadc2c5a40f17f0459a3aa412d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!<a class="el" href="namespacegko.html#aeede19206954d5c8ebd04c95cf63bb88">is_complex_s</a>&lt; T &gt;::value, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#ae8b5bfaadc2c5a40f17f0459a3aa412d">is_nan</a> (const T &amp;value)</td></tr>
<tr class="memdesc:ae8b5bfaadc2c5a40f17f0459a3aa412d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a floating point number is NaN.  <a href="namespacegko.html#ae8b5bfaadc2c5a40f17f0459a3aa412d">More...</a><br /></td></tr>
<tr class="separator:ae8b5bfaadc2c5a40f17f0459a3aa412d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8963a80e755ccccebd819827995e1e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abb8963a80e755ccccebd819827995e1e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacegko.html#aeede19206954d5c8ebd04c95cf63bb88">is_complex_s</a>&lt; T &gt;::value, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#abb8963a80e755ccccebd819827995e1e">is_nan</a> (const T &amp;value)</td></tr>
<tr class="memdesc:abb8963a80e755ccccebd819827995e1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if any component of a complex value is NaN.  <a href="namespacegko.html#abb8963a80e755ccccebd819827995e1e">More...</a><br /></td></tr>
<tr class="separator:abb8963a80e755ccccebd819827995e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4235252c8531e7028f76eff44b14dc53"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4235252c8531e7028f76eff44b14dc53"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt;!<a class="el" href="namespacegko.html#aeede19206954d5c8ebd04c95cf63bb88">is_complex_s</a>&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a4235252c8531e7028f76eff44b14dc53">nan</a> ()</td></tr>
<tr class="memdesc:a4235252c8531e7028f76eff44b14dc53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a quiet NaN of the given type.  <a href="namespacegko.html#a4235252c8531e7028f76eff44b14dc53">More...</a><br /></td></tr>
<tr class="separator:a4235252c8531e7028f76eff44b14dc53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fab450618d0d6a0bab20cead0d5b60b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2fab450618d0d6a0bab20cead0d5b60b"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; <a class="el" href="namespacegko.html#aeede19206954d5c8ebd04c95cf63bb88">is_complex_s</a>&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a2fab450618d0d6a0bab20cead0d5b60b">nan</a> ()</td></tr>
<tr class="memdesc:a2fab450618d0d6a0bab20cead0d5b60b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a complex with both components quiet NaN.  <a href="namespacegko.html#a2fab450618d0d6a0bab20cead0d5b60b">More...</a><br /></td></tr>
<tr class="separator:a2fab450618d0d6a0bab20cead0d5b60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b476e0e3df616b08efe85000bff8da0"><td class="memTemplParams" colspan="2">template&lt;typename ValueType  = default_precision, typename IndexType  = int32&gt; </td></tr>
<tr class="memitem:a0b476e0e3df616b08efe85000bff8da0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structgko_1_1matrix__data.html">matrix_data</a>&lt; ValueType, IndexType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a0b476e0e3df616b08efe85000bff8da0">read_raw</a> (std::istream &amp;is)</td></tr>
<tr class="memdesc:a0b476e0e3df616b08efe85000bff8da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a matrix stored in matrix market format from an input stream.  <a href="namespacegko.html#a0b476e0e3df616b08efe85000bff8da0">More...</a><br /></td></tr>
<tr class="separator:a0b476e0e3df616b08efe85000bff8da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c57f7b636344e8b4d17d42d2f17358f"><td class="memTemplParams" colspan="2">template&lt;typename ValueType  = default_precision, typename IndexType  = int32&gt; </td></tr>
<tr class="memitem:a4c57f7b636344e8b4d17d42d2f17358f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structgko_1_1matrix__data.html">matrix_data</a>&lt; ValueType, IndexType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a4c57f7b636344e8b4d17d42d2f17358f">read_binary_raw</a> (std::istream &amp;is)</td></tr>
<tr class="memdesc:a4c57f7b636344e8b4d17d42d2f17358f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a matrix stored in Ginkgo's binary matrix format from an input stream.  <a href="namespacegko.html#a4c57f7b636344e8b4d17d42d2f17358f">More...</a><br /></td></tr>
<tr class="separator:a4c57f7b636344e8b4d17d42d2f17358f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b610840dd471007b09be2fc1fe4b1e7"><td class="memTemplParams" colspan="2">template&lt;typename ValueType  = default_precision, typename IndexType  = int32&gt; </td></tr>
<tr class="memitem:a3b610840dd471007b09be2fc1fe4b1e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structgko_1_1matrix__data.html">matrix_data</a>&lt; ValueType, IndexType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a3b610840dd471007b09be2fc1fe4b1e7">read_generic_raw</a> (std::istream &amp;is)</td></tr>
<tr class="memdesc:a3b610840dd471007b09be2fc1fe4b1e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a matrix stored in either binary or matrix market format from an input stream.  <a href="namespacegko.html#a3b610840dd471007b09be2fc1fe4b1e7">More...</a><br /></td></tr>
<tr class="separator:a3b610840dd471007b09be2fc1fe4b1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31feb99c64fc6df58ac09abd4af69b6"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename IndexType &gt; </td></tr>
<tr class="memitem:ab31feb99c64fc6df58ac09abd4af69b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#ab31feb99c64fc6df58ac09abd4af69b6">write_raw</a> (std::ostream &amp;os, const <a class="el" href="structgko_1_1matrix__data.html">matrix_data</a>&lt; ValueType, IndexType &gt; &amp;data, <a class="el" href="namespacegko.html#ae749a5ea11a93c1bcc9158d9a6e9fb68">layout_type</a> layout=<a class="el" href="namespacegko.html#ae749a5ea11a93c1bcc9158d9a6e9fb68af1f713c9e000f5d3f280adbd124df4f5">layout_type::array</a>)</td></tr>
<tr class="memdesc:ab31feb99c64fc6df58ac09abd4af69b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a <a class="el" href="structgko_1_1matrix__data.html" title="This structure is used as an intermediate data type to store a sparse matrix.">matrix_data</a> structure to a stream in matrix market format.  <a href="namespacegko.html#ab31feb99c64fc6df58ac09abd4af69b6">More...</a><br /></td></tr>
<tr class="separator:ab31feb99c64fc6df58ac09abd4af69b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b27a0c0282115116c160884dc0a9468"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename IndexType &gt; </td></tr>
<tr class="memitem:a3b27a0c0282115116c160884dc0a9468"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a3b27a0c0282115116c160884dc0a9468">write_binary_raw</a> (std::ostream &amp;os, const <a class="el" href="structgko_1_1matrix__data.html">matrix_data</a>&lt; ValueType, IndexType &gt; &amp;data)</td></tr>
<tr class="memdesc:a3b27a0c0282115116c160884dc0a9468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a <a class="el" href="structgko_1_1matrix__data.html" title="This structure is used as an intermediate data type to store a sparse matrix.">matrix_data</a> structure to a stream in binary format.  <a href="namespacegko.html#a3b27a0c0282115116c160884dc0a9468">More...</a><br /></td></tr>
<tr class="separator:a3b27a0c0282115116c160884dc0a9468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92cf0178c1c55419d32d2bb527e57e5b"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename StreamType , typename... MatrixArgs&gt; </td></tr>
<tr class="memitem:a92cf0178c1c55419d32d2bb527e57e5b"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; MatrixType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a92cf0178c1c55419d32d2bb527e57e5b">read</a> (StreamType &amp;&amp;is, MatrixArgs &amp;&amp;... args)</td></tr>
<tr class="memdesc:a92cf0178c1c55419d32d2bb527e57e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a matrix stored in matrix market format from an input stream.  <a href="namespacegko.html#a92cf0178c1c55419d32d2bb527e57e5b">More...</a><br /></td></tr>
<tr class="separator:a92cf0178c1c55419d32d2bb527e57e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10dc71f76a4125568cb0ab5add863cd"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename StreamType , typename... MatrixArgs&gt; </td></tr>
<tr class="memitem:ad10dc71f76a4125568cb0ab5add863cd"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; MatrixType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#ad10dc71f76a4125568cb0ab5add863cd">read_binary</a> (StreamType &amp;&amp;is, MatrixArgs &amp;&amp;... args)</td></tr>
<tr class="memdesc:ad10dc71f76a4125568cb0ab5add863cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a matrix stored in binary format from an input stream.  <a href="namespacegko.html#ad10dc71f76a4125568cb0ab5add863cd">More...</a><br /></td></tr>
<tr class="separator:ad10dc71f76a4125568cb0ab5add863cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71759a8a78d3c4946a11ce4b378a88e"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename StreamType , typename... MatrixArgs&gt; </td></tr>
<tr class="memitem:ac71759a8a78d3c4946a11ce4b378a88e"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; MatrixType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#ac71759a8a78d3c4946a11ce4b378a88e">read_generic</a> (StreamType &amp;&amp;is, MatrixArgs &amp;&amp;... args)</td></tr>
<tr class="memdesc:ac71759a8a78d3c4946a11ce4b378a88e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a matrix stored either in binary or matrix market format from an input stream.  <a href="namespacegko.html#ac71759a8a78d3c4946a11ce4b378a88e">More...</a><br /></td></tr>
<tr class="separator:ac71759a8a78d3c4946a11ce4b378a88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24837da3770b3dddf981d9bfe0d3b52"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename StreamType &gt; </td></tr>
<tr class="memitem:aa24837da3770b3dddf981d9bfe0d3b52"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#aa24837da3770b3dddf981d9bfe0d3b52">write</a> (StreamType &amp;&amp;os, MatrixType *matrix, <a class="el" href="namespacegko.html#ae749a5ea11a93c1bcc9158d9a6e9fb68">layout_type</a> layout=detail::mtx_io_traits&lt; std::remove_const_t&lt; MatrixType &gt;&gt;::default_layout)</td></tr>
<tr class="memdesc:aa24837da3770b3dddf981d9bfe0d3b52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a matrix into an output stream in matrix market format.  <a href="namespacegko.html#aa24837da3770b3dddf981d9bfe0d3b52">More...</a><br /></td></tr>
<tr class="separator:aa24837da3770b3dddf981d9bfe0d3b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1280f63daa434fc2afe2cf7974608d81"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename StreamType &gt; </td></tr>
<tr class="memitem:a1280f63daa434fc2afe2cf7974608d81"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a1280f63daa434fc2afe2cf7974608d81">write_binary</a> (StreamType &amp;&amp;os, MatrixType *matrix)</td></tr>
<tr class="memdesc:a1280f63daa434fc2afe2cf7974608d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a matrix into an output stream in binary format.  <a href="namespacegko.html#a1280f63daa434fc2afe2cf7974608d81">More...</a><br /></td></tr>
<tr class="separator:a1280f63daa434fc2afe2cf7974608d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb378b82b7b7c6347ebdfb4c2ddc9366"><td class="memTemplParams" colspan="2">template&lt;typename R , typename T &gt; </td></tr>
<tr class="memitem:abb378b82b7b7c6347ebdfb4c2ddc9366"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; R, std::function&lt; void(R *)&gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#abb378b82b7b7c6347ebdfb4c2ddc9366">copy_and_convert_to</a> (std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt; exec, T *obj)</td></tr>
<tr class="memdesc:abb378b82b7b7c6347ebdfb4c2ddc9366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the object to R and places it on <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a> exec.  <a href="namespacegko.html#abb378b82b7b7c6347ebdfb4c2ddc9366">More...</a><br /></td></tr>
<tr class="separator:abb378b82b7b7c6347ebdfb4c2ddc9366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3a167c72a0659cb9003b64c7b754d0"><td class="memTemplParams" colspan="2">template&lt;typename R , typename T &gt; </td></tr>
<tr class="memitem:a3f3a167c72a0659cb9003b64c7b754d0"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; const R, std::function&lt; void(const R *)&gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a3f3a167c72a0659cb9003b64c7b754d0">copy_and_convert_to</a> (std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt; exec, const T *obj)</td></tr>
<tr class="memdesc:a3f3a167c72a0659cb9003b64c7b754d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the object to R and places it on <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a> exec.  <a href="namespacegko.html#a3f3a167c72a0659cb9003b64c7b754d0">More...</a><br /></td></tr>
<tr class="separator:a3f3a167c72a0659cb9003b64c7b754d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b925f8d9f288210c7d1f0e00e5c495"><td class="memTemplParams" colspan="2">template&lt;typename R , typename T &gt; </td></tr>
<tr class="memitem:ac2b925f8d9f288210c7d1f0e00e5c495"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#ac2b925f8d9f288210c7d1f0e00e5c495">copy_and_convert_to</a> (std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt; exec, std::shared_ptr&lt; T &gt; obj)</td></tr>
<tr class="memdesc:ac2b925f8d9f288210c7d1f0e00e5c495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the object to R and places it on <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a> exec.  <a href="namespacegko.html#ac2b925f8d9f288210c7d1f0e00e5c495">More...</a><br /></td></tr>
<tr class="separator:ac2b925f8d9f288210c7d1f0e00e5c495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f28847393e540a33fdda8cd80584789"><td class="memTemplParams" colspan="2">template&lt;typename R , typename T &gt; </td></tr>
<tr class="memitem:a0f28847393e540a33fdda8cd80584789"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; const R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a0f28847393e540a33fdda8cd80584789">copy_and_convert_to</a> (std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt; exec, std::shared_ptr&lt; const T &gt; obj)</td></tr>
<tr class="separator:a0f28847393e540a33fdda8cd80584789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6861874b1a8e349961c487c92c497658"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a6861874b1a8e349961c487c92c497658"><td class="memTemplItemLeft" align="right" valign="top">detail::temporary_conversion&lt; <a class="el" href="classgko_1_1matrix_1_1Dense.html">matrix::Dense</a>&lt; ValueType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a6861874b1a8e349961c487c92c497658">make_temporary_conversion</a> (<a class="el" href="classgko_1_1LinOp.html">LinOp</a> *matrix)</td></tr>
<tr class="memdesc:a6861874b1a8e349961c487c92c497658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the given <a class="el" href="classgko_1_1LinOp.html">LinOp</a> from matrix::Dense&lt;...&gt; to matrix::Dense&lt;ValueType&gt;.  <a href="namespacegko.html#a6861874b1a8e349961c487c92c497658">More...</a><br /></td></tr>
<tr class="separator:a6861874b1a8e349961c487c92c497658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6470e8e212add7923569e6b885a74610"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a6470e8e212add7923569e6b885a74610"><td class="memTemplItemLeft" align="right" valign="top">detail::temporary_conversion&lt; const <a class="el" href="classgko_1_1matrix_1_1Dense.html">matrix::Dense</a>&lt; ValueType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a6470e8e212add7923569e6b885a74610">make_temporary_conversion</a> (const <a class="el" href="classgko_1_1LinOp.html">LinOp</a> *matrix)</td></tr>
<tr class="memdesc:a6470e8e212add7923569e6b885a74610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the given <a class="el" href="classgko_1_1LinOp.html">LinOp</a> from matrix::Dense&lt;...&gt; to matrix::Dense&lt;ValueType&gt;.  <a href="namespacegko.html#a6470e8e212add7923569e6b885a74610">More...</a><br /></td></tr>
<tr class="separator:a6470e8e212add7923569e6b885a74610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c46f1caf8135f7492aa83d9ac3bc83e"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename Function , typename... Args&gt; </td></tr>
<tr class="memitem:a3c46f1caf8135f7492aa83d9ac3bc83e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a3c46f1caf8135f7492aa83d9ac3bc83e">precision_dispatch</a> (Function fn, Args *... linops)</td></tr>
<tr class="memdesc:a3c46f1caf8135f7492aa83d9ac3bc83e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the given function with each given argument <a class="el" href="classgko_1_1LinOp.html">LinOp</a> temporarily converted into matrix::Dense&lt;ValueType&gt; as parameters.  <a href="namespacegko.html#a3c46f1caf8135f7492aa83d9ac3bc83e">More...</a><br /></td></tr>
<tr class="separator:a3c46f1caf8135f7492aa83d9ac3bc83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c5a37c89e32c0f2b567f8e73870e3a"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename Function &gt; </td></tr>
<tr class="memitem:a98c5a37c89e32c0f2b567f8e73870e3a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a98c5a37c89e32c0f2b567f8e73870e3a">precision_dispatch_real_complex</a> (Function fn, const <a class="el" href="classgko_1_1LinOp.html">LinOp</a> *in, <a class="el" href="classgko_1_1LinOp.html">LinOp</a> *out)</td></tr>
<tr class="memdesc:a98c5a37c89e32c0f2b567f8e73870e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the given function with the given LinOps temporarily converted to matrix::Dense&lt;ValueType&gt;* as parameters.  <a href="namespacegko.html#a98c5a37c89e32c0f2b567f8e73870e3a">More...</a><br /></td></tr>
<tr class="separator:a98c5a37c89e32c0f2b567f8e73870e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24dd55a9e5d991204024c68a501cdb3e"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename Function &gt; </td></tr>
<tr class="memitem:a24dd55a9e5d991204024c68a501cdb3e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a24dd55a9e5d991204024c68a501cdb3e">precision_dispatch_real_complex</a> (Function fn, const <a class="el" href="classgko_1_1LinOp.html">LinOp</a> *alpha, const <a class="el" href="classgko_1_1LinOp.html">LinOp</a> *in, <a class="el" href="classgko_1_1LinOp.html">LinOp</a> *out)</td></tr>
<tr class="memdesc:a24dd55a9e5d991204024c68a501cdb3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the given function with the given LinOps temporarily converted to matrix::Dense&lt;ValueType&gt;* as parameters.  <a href="namespacegko.html#a24dd55a9e5d991204024c68a501cdb3e">More...</a><br /></td></tr>
<tr class="separator:a24dd55a9e5d991204024c68a501cdb3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaebbe93d733274398213df2d3acf1b79"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename Function &gt; </td></tr>
<tr class="memitem:aaebbe93d733274398213df2d3acf1b79"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#aaebbe93d733274398213df2d3acf1b79">precision_dispatch_real_complex</a> (Function fn, const <a class="el" href="classgko_1_1LinOp.html">LinOp</a> *alpha, const <a class="el" href="classgko_1_1LinOp.html">LinOp</a> *in, const <a class="el" href="classgko_1_1LinOp.html">LinOp</a> *beta, <a class="el" href="classgko_1_1LinOp.html">LinOp</a> *out)</td></tr>
<tr class="memdesc:aaebbe93d733274398213df2d3acf1b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the given function with the given LinOps temporarily converted to matrix::Dense&lt;ValueType&gt;* as parameters.  <a href="namespacegko.html#aaebbe93d733274398213df2d3acf1b79">More...</a><br /></td></tr>
<tr class="separator:aaebbe93d733274398213df2d3acf1b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205901dcce27e1df970c569d46d87551"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename Function &gt; </td></tr>
<tr class="memitem:a205901dcce27e1df970c569d46d87551"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a205901dcce27e1df970c569d46d87551">mixed_precision_dispatch</a> (Function fn, const <a class="el" href="classgko_1_1LinOp.html">LinOp</a> *in, <a class="el" href="classgko_1_1LinOp.html">LinOp</a> *out)</td></tr>
<tr class="memdesc:a205901dcce27e1df970c569d46d87551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the given function with each given argument <a class="el" href="classgko_1_1LinOp.html">LinOp</a> converted into matrix::Dense&lt;ValueType&gt; as parameters.  <a href="namespacegko.html#a205901dcce27e1df970c569d46d87551">More...</a><br /></td></tr>
<tr class="separator:a205901dcce27e1df970c569d46d87551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9785eed86179e15b8fb4e74f7e9f89"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename Function , std::enable_if_t&lt; is_complex&lt; ValueType &gt;()&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3b9785eed86179e15b8fb4e74f7e9f89"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a3b9785eed86179e15b8fb4e74f7e9f89">mixed_precision_dispatch_real_complex</a> (Function fn, const <a class="el" href="classgko_1_1LinOp.html">LinOp</a> *in, <a class="el" href="classgko_1_1LinOp.html">LinOp</a> *out)</td></tr>
<tr class="memdesc:a3b9785eed86179e15b8fb4e74f7e9f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the given function with the given LinOps cast to their dynamic type matrix::Dense&lt;ValueType&gt;* as parameters.  <a href="namespacegko.html#a3b9785eed86179e15b8fb4e74f7e9f89">More...</a><br /></td></tr>
<tr class="separator:a3b9785eed86179e15b8fb4e74f7e9f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22cd8a74bb04c04ba81d88de0d0677b2"><td class="memItemLeft" align="right" valign="top"><a id="a22cd8a74bb04c04ba81d88de0d0677b2"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="structgko_1_1span.html">span</a> &amp;first, const <a class="el" href="structgko_1_1span.html">span</a> &amp;second)</td></tr>
<tr class="separator:a22cd8a74bb04c04ba81d88de0d0677b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece8127f67d50be468da56463320819f"><td class="memItemLeft" align="right" valign="top"><a id="aece8127f67d50be468da56463320819f"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="structgko_1_1span.html">span</a> &amp;first, const <a class="el" href="structgko_1_1span.html">span</a> &amp;second)</td></tr>
<tr class="separator:aece8127f67d50be468da56463320819f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfec3871dd48b1b7abd345404fc5fea4"><td class="memItemLeft" align="right" valign="top"><a id="abfec3871dd48b1b7abd345404fc5fea4"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="structgko_1_1span.html">span</a> &amp;first, const <a class="el" href="structgko_1_1span.html">span</a> &amp;second)</td></tr>
<tr class="separator:abfec3871dd48b1b7abd345404fc5fea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6a579660b1a1d65b353ede9ab691730"><td class="memItemLeft" align="right" valign="top"><a id="af6a579660b1a1d65b353ede9ab691730"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="structgko_1_1span.html">span</a> &amp;first, const <a class="el" href="structgko_1_1span.html">span</a> &amp;second)</td></tr>
<tr class="separator:af6a579660b1a1d65b353ede9ab691730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa4fd5d9324b20d7205d3cc6ab610444"><td class="memItemLeft" align="right" valign="top"><a id="afa4fd5d9324b20d7205d3cc6ab610444"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structgko_1_1span.html">span</a> &amp;first, const <a class="el" href="structgko_1_1span.html">span</a> &amp;second)</td></tr>
<tr class="separator:afa4fd5d9324b20d7205d3cc6ab610444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b572cdf444e58282049b6eeed87f0a"><td class="memItemLeft" align="right" valign="top"><a id="a76b572cdf444e58282049b6eeed87f0a"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="structgko_1_1span.html">span</a> &amp;first, const <a class="el" href="structgko_1_1span.html">span</a> &amp;second)</td></tr>
<tr class="separator:a76b572cdf444e58282049b6eeed87f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac794f6c0cb0e1252d2326feebae6ba56"><td class="memTemplParams" colspan="2"><a id="ac794f6c0cb0e1252d2326feebae6ba56"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:ac794f6c0cb0e1252d2326feebae6ba56"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1unary__plus.html">accessor::unary_plus</a>&lt; Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;operand)</td></tr>
<tr class="separator:ac794f6c0cb0e1252d2326feebae6ba56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb7f55a089dea8a02ce13d570894253"><td class="memTemplParams" colspan="2"><a id="acdb7f55a089dea8a02ce13d570894253"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:acdb7f55a089dea8a02ce13d570894253"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1unary__minus.html">accessor::unary_minus</a>&lt; Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;operand)</td></tr>
<tr class="separator:acdb7f55a089dea8a02ce13d570894253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0174e1e36ef6c8561108174e35a1b6"><td class="memTemplParams" colspan="2"><a id="a1b0174e1e36ef6c8561108174e35a1b6"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a1b0174e1e36ef6c8561108174e35a1b6"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1logical__not.html">accessor::logical_not</a>&lt; Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;operand)</td></tr>
<tr class="separator:a1b0174e1e36ef6c8561108174e35a1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69778756c37d99881afbd0ec6203db60"><td class="memTemplParams" colspan="2"><a id="a69778756c37d99881afbd0ec6203db60"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a69778756c37d99881afbd0ec6203db60"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1bitwise__not.html">accessor::bitwise_not</a>&lt; Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator~</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;operand)</td></tr>
<tr class="separator:a69778756c37d99881afbd0ec6203db60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6313c0993fea961ebefddb393ab937d"><td class="memTemplParams" colspan="2"><a id="ae6313c0993fea961ebefddb393ab937d"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:ae6313c0993fea961ebefddb393ab937d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1zero__operation.html">accessor::zero_operation</a>&lt; Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>zero</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;operand)</td></tr>
<tr class="separator:ae6313c0993fea961ebefddb393ab937d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a314483c618b92c78dc6ac2e978ad4529"><td class="memTemplParams" colspan="2"><a id="a314483c618b92c78dc6ac2e978ad4529"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a314483c618b92c78dc6ac2e978ad4529"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1one__operaton.html">accessor::one_operaton</a>&lt; Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>one</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;operand)</td></tr>
<tr class="separator:a314483c618b92c78dc6ac2e978ad4529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1affadd93ed2a2b867d5aeff319e8922"><td class="memTemplParams" colspan="2"><a id="a1affadd93ed2a2b867d5aeff319e8922"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a1affadd93ed2a2b867d5aeff319e8922"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1abs__operaton.html">accessor::abs_operaton</a>&lt; Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;operand)</td></tr>
<tr class="separator:a1affadd93ed2a2b867d5aeff319e8922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1abf93b0d48330b1d2dad93a30f7a67"><td class="memTemplParams" colspan="2"><a id="ac1abf93b0d48330b1d2dad93a30f7a67"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:ac1abf93b0d48330b1d2dad93a30f7a67"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1real__operaton.html">accessor::real_operaton</a>&lt; Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>real</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;operand)</td></tr>
<tr class="separator:ac1abf93b0d48330b1d2dad93a30f7a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11c76be937a8bf8393f4c1c27702dc0"><td class="memTemplParams" colspan="2"><a id="ae11c76be937a8bf8393f4c1c27702dc0"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:ae11c76be937a8bf8393f4c1c27702dc0"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1imag__operaton.html">accessor::imag_operaton</a>&lt; Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>imag</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;operand)</td></tr>
<tr class="separator:ae11c76be937a8bf8393f4c1c27702dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d217879d3f2759a2020e2ff5bbb2eca"><td class="memTemplParams" colspan="2"><a id="a5d217879d3f2759a2020e2ff5bbb2eca"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a5d217879d3f2759a2020e2ff5bbb2eca"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1conj__operaton.html">accessor::conj_operaton</a>&lt; Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>conj</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;operand)</td></tr>
<tr class="separator:a5d217879d3f2759a2020e2ff5bbb2eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf85875a944e6e03c8427d3790e568c1"><td class="memTemplParams" colspan="2"><a id="aaf85875a944e6e03c8427d3790e568c1"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:aaf85875a944e6e03c8427d3790e568c1"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1squared__norm__operaton.html">accessor::squared_norm_operaton</a>&lt; Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>squared_norm</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;operand)</td></tr>
<tr class="separator:aaf85875a944e6e03c8427d3790e568c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d61bb1d045d3cc21add96cd565cb56"><td class="memTemplParams" colspan="2"><a id="af0d61bb1d045d3cc21add96cd565cb56"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:af0d61bb1d045d3cc21add96cd565cb56"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1transpose__operation.html">accessor::transpose_operation</a>&lt; Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;operand)</td></tr>
<tr class="separator:af0d61bb1d045d3cc21add96cd565cb56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1313bcbb37e83bf24a111edfebb83e44"><td class="memTemplParams" colspan="2"><a id="a1313bcbb37e83bf24a111edfebb83e44"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a1313bcbb37e83bf24a111edfebb83e44"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1add.html">accessor::add</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:a1313bcbb37e83bf24a111edfebb83e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d04205743fc18e740caee6b8cb8720c"><td class="memTemplParams" colspan="2"><a id="a0d04205743fc18e740caee6b8cb8720c"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a0d04205743fc18e740caee6b8cb8720c"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1add.html">accessor::add</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a0d04205743fc18e740caee6b8cb8720c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2193faa27b6fcc5c7220923141a3ad"><td class="memTemplParams" colspan="2"><a id="add2193faa27b6fcc5c7220923141a3ad"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:add2193faa27b6fcc5c7220923141a3ad"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1add.html">accessor::add</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:add2193faa27b6fcc5c7220923141a3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15048e6bc74da6120729e407b5c74f30"><td class="memTemplParams" colspan="2"><a id="a15048e6bc74da6120729e407b5c74f30"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a15048e6bc74da6120729e407b5c74f30"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1add.html">accessor::add</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a15048e6bc74da6120729e407b5c74f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c773c140e30d751bbf8826c2faf4f74"><td class="memTemplParams" colspan="2"><a id="a4c773c140e30d751bbf8826c2faf4f74"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a4c773c140e30d751bbf8826c2faf4f74"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1sub.html">accessor::sub</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:a4c773c140e30d751bbf8826c2faf4f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46f88660f5606ed9da1c156bb7139b6"><td class="memTemplParams" colspan="2"><a id="ae46f88660f5606ed9da1c156bb7139b6"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:ae46f88660f5606ed9da1c156bb7139b6"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1sub.html">accessor::sub</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:ae46f88660f5606ed9da1c156bb7139b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d778fb0a4dd79be3297adea7a8b4e31"><td class="memTemplParams" colspan="2"><a id="a4d778fb0a4dd79be3297adea7a8b4e31"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:a4d778fb0a4dd79be3297adea7a8b4e31"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1sub.html">accessor::sub</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:a4d778fb0a4dd79be3297adea7a8b4e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0e9697a7f202cdfef1016e535e2568"><td class="memTemplParams" colspan="2"><a id="a5d0e9697a7f202cdfef1016e535e2568"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a5d0e9697a7f202cdfef1016e535e2568"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1sub.html">accessor::sub</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a5d0e9697a7f202cdfef1016e535e2568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2723c0333fc2349178c8bd33a13d72b8"><td class="memTemplParams" colspan="2"><a id="a2723c0333fc2349178c8bd33a13d72b8"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a2723c0333fc2349178c8bd33a13d72b8"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1mul.html">accessor::mul</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:a2723c0333fc2349178c8bd33a13d72b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b3c1ce84d54e93c170a0a993434349"><td class="memTemplParams" colspan="2"><a id="a86b3c1ce84d54e93c170a0a993434349"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a86b3c1ce84d54e93c170a0a993434349"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1mul.html">accessor::mul</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a86b3c1ce84d54e93c170a0a993434349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb48dd84f149784a1b8827d5cc1a190"><td class="memTemplParams" colspan="2"><a id="a1cb48dd84f149784a1b8827d5cc1a190"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:a1cb48dd84f149784a1b8827d5cc1a190"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1mul.html">accessor::mul</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:a1cb48dd84f149784a1b8827d5cc1a190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2fb75dc070c4ea51828628aeec144cc"><td class="memTemplParams" colspan="2"><a id="aa2fb75dc070c4ea51828628aeec144cc"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:aa2fb75dc070c4ea51828628aeec144cc"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1mul.html">accessor::mul</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:aa2fb75dc070c4ea51828628aeec144cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c291b8175c3a41649bdfdfde9d7485"><td class="memTemplParams" colspan="2"><a id="a83c291b8175c3a41649bdfdfde9d7485"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a83c291b8175c3a41649bdfdfde9d7485"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1div.html">accessor::div</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:a83c291b8175c3a41649bdfdfde9d7485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c33c78a06d2e2bae92f7f1cc254a3e"><td class="memTemplParams" colspan="2"><a id="a40c33c78a06d2e2bae92f7f1cc254a3e"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a40c33c78a06d2e2bae92f7f1cc254a3e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1div.html">accessor::div</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a40c33c78a06d2e2bae92f7f1cc254a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b921aed556c1773376ad2feb082fafb"><td class="memTemplParams" colspan="2"><a id="a3b921aed556c1773376ad2feb082fafb"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:a3b921aed556c1773376ad2feb082fafb"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1div.html">accessor::div</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:a3b921aed556c1773376ad2feb082fafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad617073f36809325a11db56fc66d433e"><td class="memTemplParams" colspan="2"><a id="ad617073f36809325a11db56fc66d433e"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:ad617073f36809325a11db56fc66d433e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1div.html">accessor::div</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:ad617073f36809325a11db56fc66d433e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabcbe4818e5316566e04afa5d653ec23"><td class="memTemplParams" colspan="2"><a id="aabcbe4818e5316566e04afa5d653ec23"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:aabcbe4818e5316566e04afa5d653ec23"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1mod.html">accessor::mod</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator%</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:aabcbe4818e5316566e04afa5d653ec23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02261bf3b7594d48bb51093593896e1"><td class="memTemplParams" colspan="2"><a id="af02261bf3b7594d48bb51093593896e1"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:af02261bf3b7594d48bb51093593896e1"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1mod.html">accessor::mod</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator%</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:af02261bf3b7594d48bb51093593896e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175e929e92316d5352207795a0da2a82"><td class="memTemplParams" colspan="2"><a id="a175e929e92316d5352207795a0da2a82"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:a175e929e92316d5352207795a0da2a82"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1mod.html">accessor::mod</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator%</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:a175e929e92316d5352207795a0da2a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe20522bc3e2a9e6f1069d783cad8e06"><td class="memTemplParams" colspan="2"><a id="abe20522bc3e2a9e6f1069d783cad8e06"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:abe20522bc3e2a9e6f1069d783cad8e06"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1mod.html">accessor::mod</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator%</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:abe20522bc3e2a9e6f1069d783cad8e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab86394e93b6c232aae4816b59bdcca96"><td class="memTemplParams" colspan="2"><a id="ab86394e93b6c232aae4816b59bdcca96"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:ab86394e93b6c232aae4816b59bdcca96"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1less.html">accessor::less</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:ab86394e93b6c232aae4816b59bdcca96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b90df104f6069d07d0d7a81a21d1de"><td class="memTemplParams" colspan="2"><a id="ae8b90df104f6069d07d0d7a81a21d1de"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:ae8b90df104f6069d07d0d7a81a21d1de"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1less.html">accessor::less</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:ae8b90df104f6069d07d0d7a81a21d1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e29cc3ae776a00c79b7a3b8fdf2ef9"><td class="memTemplParams" colspan="2"><a id="a06e29cc3ae776a00c79b7a3b8fdf2ef9"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:a06e29cc3ae776a00c79b7a3b8fdf2ef9"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1less.html">accessor::less</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:a06e29cc3ae776a00c79b7a3b8fdf2ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4f898ac5f7d9aedbabd1b361943982"><td class="memTemplParams" colspan="2"><a id="afe4f898ac5f7d9aedbabd1b361943982"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:afe4f898ac5f7d9aedbabd1b361943982"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1less.html">accessor::less</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:afe4f898ac5f7d9aedbabd1b361943982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2fc01ef12bf15ea7da4c14d98e55cc7"><td class="memTemplParams" colspan="2"><a id="af2fc01ef12bf15ea7da4c14d98e55cc7"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:af2fc01ef12bf15ea7da4c14d98e55cc7"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1greater.html">accessor::greater</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:af2fc01ef12bf15ea7da4c14d98e55cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0ff2b60791b5cc3bab79fa91ab46f8"><td class="memTemplParams" colspan="2"><a id="a3f0ff2b60791b5cc3bab79fa91ab46f8"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a3f0ff2b60791b5cc3bab79fa91ab46f8"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1greater.html">accessor::greater</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a3f0ff2b60791b5cc3bab79fa91ab46f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7af1edcc3719e52f0f3b9519651d2d"><td class="memTemplParams" colspan="2"><a id="a3d7af1edcc3719e52f0f3b9519651d2d"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:a3d7af1edcc3719e52f0f3b9519651d2d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1greater.html">accessor::greater</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:a3d7af1edcc3719e52f0f3b9519651d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea0e27f2e5baab0c073e4e6baff4b7e"><td class="memTemplParams" colspan="2"><a id="a8ea0e27f2e5baab0c073e4e6baff4b7e"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a8ea0e27f2e5baab0c073e4e6baff4b7e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1greater.html">accessor::greater</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a8ea0e27f2e5baab0c073e4e6baff4b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41355e557a67620659b116f79ba7074d"><td class="memTemplParams" colspan="2"><a id="a41355e557a67620659b116f79ba7074d"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a41355e557a67620659b116f79ba7074d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1less__or__equal.html">accessor::less_or_equal</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:a41355e557a67620659b116f79ba7074d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff69ca2e7cb612911bd85ae82bf0c0b8"><td class="memTemplParams" colspan="2"><a id="aff69ca2e7cb612911bd85ae82bf0c0b8"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:aff69ca2e7cb612911bd85ae82bf0c0b8"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1less__or__equal.html">accessor::less_or_equal</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:aff69ca2e7cb612911bd85ae82bf0c0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59c44515b0155c808f9d77b5d430cac"><td class="memTemplParams" colspan="2"><a id="ab59c44515b0155c808f9d77b5d430cac"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:ab59c44515b0155c808f9d77b5d430cac"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1less__or__equal.html">accessor::less_or_equal</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:ab59c44515b0155c808f9d77b5d430cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1165979d19164d7762c6fdf560bf1b15"><td class="memTemplParams" colspan="2"><a id="a1165979d19164d7762c6fdf560bf1b15"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a1165979d19164d7762c6fdf560bf1b15"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1less__or__equal.html">accessor::less_or_equal</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a1165979d19164d7762c6fdf560bf1b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323744fe971b1e322b0adde873ee6fc6"><td class="memTemplParams" colspan="2"><a id="a323744fe971b1e322b0adde873ee6fc6"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a323744fe971b1e322b0adde873ee6fc6"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1greater__or__equal.html">accessor::greater_or_equal</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:a323744fe971b1e322b0adde873ee6fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aaf424ba6928e394060e3daee3ec841"><td class="memTemplParams" colspan="2"><a id="a9aaf424ba6928e394060e3daee3ec841"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a9aaf424ba6928e394060e3daee3ec841"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1greater__or__equal.html">accessor::greater_or_equal</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a9aaf424ba6928e394060e3daee3ec841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e68118a9f8c4eb4c5c5d93a9a98e84"><td class="memTemplParams" colspan="2"><a id="a21e68118a9f8c4eb4c5c5d93a9a98e84"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:a21e68118a9f8c4eb4c5c5d93a9a98e84"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1greater__or__equal.html">accessor::greater_or_equal</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:a21e68118a9f8c4eb4c5c5d93a9a98e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e5c84356708a0ee714198c211118d7"><td class="memTemplParams" colspan="2"><a id="a60e5c84356708a0ee714198c211118d7"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a60e5c84356708a0ee714198c211118d7"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1greater__or__equal.html">accessor::greater_or_equal</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a60e5c84356708a0ee714198c211118d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b12398fc180e82bf31cd7aa210ba731"><td class="memTemplParams" colspan="2"><a id="a9b12398fc180e82bf31cd7aa210ba731"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a9b12398fc180e82bf31cd7aa210ba731"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1equal.html">accessor::equal</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:a9b12398fc180e82bf31cd7aa210ba731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754f3a148a6ffbd2ebc1de4950f874d3"><td class="memTemplParams" colspan="2"><a id="a754f3a148a6ffbd2ebc1de4950f874d3"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a754f3a148a6ffbd2ebc1de4950f874d3"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1equal.html">accessor::equal</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a754f3a148a6ffbd2ebc1de4950f874d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae093d67dc43ee09722642623abfef970"><td class="memTemplParams" colspan="2"><a id="ae093d67dc43ee09722642623abfef970"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:ae093d67dc43ee09722642623abfef970"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1equal.html">accessor::equal</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:ae093d67dc43ee09722642623abfef970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045f895f0a9784b07f8df78507b278ac"><td class="memTemplParams" colspan="2"><a id="a045f895f0a9784b07f8df78507b278ac"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a045f895f0a9784b07f8df78507b278ac"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1equal.html">accessor::equal</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a045f895f0a9784b07f8df78507b278ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3192cdc0e20795c77068697d2fbb87b3"><td class="memTemplParams" colspan="2"><a id="a3192cdc0e20795c77068697d2fbb87b3"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a3192cdc0e20795c77068697d2fbb87b3"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1not__equal.html">accessor::not_equal</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:a3192cdc0e20795c77068697d2fbb87b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaba7c56d10cf4ac78abbf1915abc813"><td class="memTemplParams" colspan="2"><a id="acaba7c56d10cf4ac78abbf1915abc813"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:acaba7c56d10cf4ac78abbf1915abc813"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1not__equal.html">accessor::not_equal</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:acaba7c56d10cf4ac78abbf1915abc813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f677bbc94cc91eb9edf9c55e6f3bec0"><td class="memTemplParams" colspan="2"><a id="a6f677bbc94cc91eb9edf9c55e6f3bec0"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:a6f677bbc94cc91eb9edf9c55e6f3bec0"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1not__equal.html">accessor::not_equal</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:a6f677bbc94cc91eb9edf9c55e6f3bec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca70088d495ea60993e6bf86d155571c"><td class="memTemplParams" colspan="2"><a id="aca70088d495ea60993e6bf86d155571c"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:aca70088d495ea60993e6bf86d155571c"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1not__equal.html">accessor::not_equal</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:aca70088d495ea60993e6bf86d155571c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5409d98fe2fc4ae364dab8e6a76d4016"><td class="memTemplParams" colspan="2"><a id="a5409d98fe2fc4ae364dab8e6a76d4016"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a5409d98fe2fc4ae364dab8e6a76d4016"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1logical__or.html">accessor::logical_or</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator||</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:a5409d98fe2fc4ae364dab8e6a76d4016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d30de07b0c483d6c25cd9ac7f27487"><td class="memTemplParams" colspan="2"><a id="a90d30de07b0c483d6c25cd9ac7f27487"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a90d30de07b0c483d6c25cd9ac7f27487"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1logical__or.html">accessor::logical_or</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator||</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a90d30de07b0c483d6c25cd9ac7f27487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e2f0c77efabd6d47e3dbb4b2a8270b"><td class="memTemplParams" colspan="2"><a id="ad2e2f0c77efabd6d47e3dbb4b2a8270b"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:ad2e2f0c77efabd6d47e3dbb4b2a8270b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1logical__or.html">accessor::logical_or</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator||</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:ad2e2f0c77efabd6d47e3dbb4b2a8270b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa475e217d2a6cec2e7be2b5b67c1f411"><td class="memTemplParams" colspan="2"><a id="aa475e217d2a6cec2e7be2b5b67c1f411"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:aa475e217d2a6cec2e7be2b5b67c1f411"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1logical__or.html">accessor::logical_or</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator||</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:aa475e217d2a6cec2e7be2b5b67c1f411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e49f8d45550558d6d45a427786a84cc"><td class="memTemplParams" colspan="2"><a id="a7e49f8d45550558d6d45a427786a84cc"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a7e49f8d45550558d6d45a427786a84cc"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1logical__and.html">accessor::logical_and</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;&amp;</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:a7e49f8d45550558d6d45a427786a84cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77d1017b99c32afdf5c38af1b29e4d0"><td class="memTemplParams" colspan="2"><a id="aa77d1017b99c32afdf5c38af1b29e4d0"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:aa77d1017b99c32afdf5c38af1b29e4d0"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1logical__and.html">accessor::logical_and</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;&amp;</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:aa77d1017b99c32afdf5c38af1b29e4d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b0898350bd21a971d8687355b69ecb"><td class="memTemplParams" colspan="2"><a id="ab2b0898350bd21a971d8687355b69ecb"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:ab2b0898350bd21a971d8687355b69ecb"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1logical__and.html">accessor::logical_and</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;&amp;</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:ab2b0898350bd21a971d8687355b69ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4df98eb3e10aba66c6a5ecff830b68"><td class="memTemplParams" colspan="2"><a id="a9c4df98eb3e10aba66c6a5ecff830b68"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a9c4df98eb3e10aba66c6a5ecff830b68"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1logical__and.html">accessor::logical_and</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;&amp;</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a9c4df98eb3e10aba66c6a5ecff830b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa83739f5164d2c071abe69bb4fb89203"><td class="memTemplParams" colspan="2"><a id="aa83739f5164d2c071abe69bb4fb89203"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:aa83739f5164d2c071abe69bb4fb89203"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1bitwise__or.html">accessor::bitwise_or</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator|</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:aa83739f5164d2c071abe69bb4fb89203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4bc92ac2122a4fc41a92003bfaf9c4c"><td class="memTemplParams" colspan="2"><a id="ab4bc92ac2122a4fc41a92003bfaf9c4c"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:ab4bc92ac2122a4fc41a92003bfaf9c4c"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1bitwise__or.html">accessor::bitwise_or</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator|</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:ab4bc92ac2122a4fc41a92003bfaf9c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8261b7cf1c5356d8acd690cf6da78ae"><td class="memTemplParams" colspan="2"><a id="aa8261b7cf1c5356d8acd690cf6da78ae"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:aa8261b7cf1c5356d8acd690cf6da78ae"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1bitwise__or.html">accessor::bitwise_or</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator|</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:aa8261b7cf1c5356d8acd690cf6da78ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5919cbe46045874ae714655dadf21f7"><td class="memTemplParams" colspan="2"><a id="af5919cbe46045874ae714655dadf21f7"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:af5919cbe46045874ae714655dadf21f7"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1bitwise__or.html">accessor::bitwise_or</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator|</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:af5919cbe46045874ae714655dadf21f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863cedf8acfcbe8fd49bdfd75c5cf98c"><td class="memTemplParams" colspan="2"><a id="a863cedf8acfcbe8fd49bdfd75c5cf98c"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a863cedf8acfcbe8fd49bdfd75c5cf98c"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1bitwise__and.html">accessor::bitwise_and</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:a863cedf8acfcbe8fd49bdfd75c5cf98c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810dbc268bd5afe52957e86516a52144"><td class="memTemplParams" colspan="2"><a id="a810dbc268bd5afe52957e86516a52144"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a810dbc268bd5afe52957e86516a52144"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1bitwise__and.html">accessor::bitwise_and</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a810dbc268bd5afe52957e86516a52144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c492e305ee2fede581c5064e2a67e9b"><td class="memTemplParams" colspan="2"><a id="a6c492e305ee2fede581c5064e2a67e9b"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:a6c492e305ee2fede581c5064e2a67e9b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1bitwise__and.html">accessor::bitwise_and</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:a6c492e305ee2fede581c5064e2a67e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7510cbb7b5d9f64e475ee454eff5936d"><td class="memTemplParams" colspan="2"><a id="a7510cbb7b5d9f64e475ee454eff5936d"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a7510cbb7b5d9f64e475ee454eff5936d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1bitwise__and.html">accessor::bitwise_and</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a7510cbb7b5d9f64e475ee454eff5936d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9632339715461aa398490e01ff0061c1"><td class="memTemplParams" colspan="2"><a id="a9632339715461aa398490e01ff0061c1"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a9632339715461aa398490e01ff0061c1"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1bitwise__xor.html">accessor::bitwise_xor</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator^</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:a9632339715461aa398490e01ff0061c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa283184871e7e3c2732eee8d5730a58f"><td class="memTemplParams" colspan="2"><a id="aa283184871e7e3c2732eee8d5730a58f"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:aa283184871e7e3c2732eee8d5730a58f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1bitwise__xor.html">accessor::bitwise_xor</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator^</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:aa283184871e7e3c2732eee8d5730a58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa4929c556ad4f2690b9c8aeaf2cea4f"><td class="memTemplParams" colspan="2"><a id="afa4929c556ad4f2690b9c8aeaf2cea4f"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:afa4929c556ad4f2690b9c8aeaf2cea4f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1bitwise__xor.html">accessor::bitwise_xor</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator^</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:afa4929c556ad4f2690b9c8aeaf2cea4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110b727befb8ac474ece75ac62ae6668"><td class="memTemplParams" colspan="2"><a id="a110b727befb8ac474ece75ac62ae6668"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a110b727befb8ac474ece75ac62ae6668"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1bitwise__xor.html">accessor::bitwise_xor</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator^</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a110b727befb8ac474ece75ac62ae6668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0fb3b3ff225d07950e27943d29593f"><td class="memTemplParams" colspan="2"><a id="a3a0fb3b3ff225d07950e27943d29593f"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a3a0fb3b3ff225d07950e27943d29593f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1left__shift.html">accessor::left_shift</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:a3a0fb3b3ff225d07950e27943d29593f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7500d198bc217d251346560148657e"><td class="memTemplParams" colspan="2"><a id="a6d7500d198bc217d251346560148657e"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a6d7500d198bc217d251346560148657e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1left__shift.html">accessor::left_shift</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a6d7500d198bc217d251346560148657e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34302fcd90695bfd2e0267da0454c8b9"><td class="memTemplParams" colspan="2"><a id="a34302fcd90695bfd2e0267da0454c8b9"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:a34302fcd90695bfd2e0267da0454c8b9"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1left__shift.html">accessor::left_shift</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:a34302fcd90695bfd2e0267da0454c8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeaf5e40ac6cca7985630beed38975e0"><td class="memTemplParams" colspan="2"><a id="aeeaf5e40ac6cca7985630beed38975e0"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:aeeaf5e40ac6cca7985630beed38975e0"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1left__shift.html">accessor::left_shift</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:aeeaf5e40ac6cca7985630beed38975e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787e41cf20d8dbf332b38f9e6bd014c8"><td class="memTemplParams" colspan="2"><a id="a787e41cf20d8dbf332b38f9e6bd014c8"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a787e41cf20d8dbf332b38f9e6bd014c8"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1right__shift.html">accessor::right_shift</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:a787e41cf20d8dbf332b38f9e6bd014c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44870f0181208f0e356c0510ef136f0a"><td class="memTemplParams" colspan="2"><a id="a44870f0181208f0e356c0510ef136f0a"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a44870f0181208f0e356c0510ef136f0a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1right__shift.html">accessor::right_shift</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a44870f0181208f0e356c0510ef136f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0467ed5f04ab215c0c5639f0a4f880b5"><td class="memTemplParams" colspan="2"><a id="a0467ed5f04ab215c0c5639f0a4f880b5"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:a0467ed5f04ab215c0c5639f0a4f880b5"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1right__shift.html">accessor::right_shift</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:a0467ed5f04ab215c0c5639f0a4f880b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb6c9447f2f6620551a3c6900f290fd"><td class="memTemplParams" colspan="2"><a id="a7fb6c9447f2f6620551a3c6900f290fd"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a7fb6c9447f2f6620551a3c6900f290fd"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1right__shift.html">accessor::right_shift</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a7fb6c9447f2f6620551a3c6900f290fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9525dbd3cab0f88c517605970eeec941"><td class="memTemplParams" colspan="2"><a id="a9525dbd3cab0f88c517605970eeec941"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a9525dbd3cab0f88c517605970eeec941"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1max__operaton.html">accessor::max_operaton</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>max</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:a9525dbd3cab0f88c517605970eeec941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6953ed43df70b724348be1ee86e086c0"><td class="memTemplParams" colspan="2"><a id="a6953ed43df70b724348be1ee86e086c0"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a6953ed43df70b724348be1ee86e086c0"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1max__operaton.html">accessor::max_operaton</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>max</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a6953ed43df70b724348be1ee86e086c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12db47e6880294113f8cfc3b260b5c44"><td class="memTemplParams" colspan="2"><a id="a12db47e6880294113f8cfc3b260b5c44"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:a12db47e6880294113f8cfc3b260b5c44"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1max__operaton.html">accessor::max_operaton</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>max</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:a12db47e6880294113f8cfc3b260b5c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1cf347b60113f5504144cf885be230"><td class="memTemplParams" colspan="2"><a id="a4e1cf347b60113f5504144cf885be230"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a4e1cf347b60113f5504144cf885be230"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1max__operaton.html">accessor::max_operaton</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>max</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a4e1cf347b60113f5504144cf885be230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f6a1d8d6ddb53fa5604c4fffab2215"><td class="memTemplParams" colspan="2"><a id="a92f6a1d8d6ddb53fa5604c4fffab2215"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a92f6a1d8d6ddb53fa5604c4fffab2215"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1min__operaton.html">accessor::min_operaton</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>min</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:a92f6a1d8d6ddb53fa5604c4fffab2215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed7f057eac94682a4aa2735af799e56a"><td class="memTemplParams" colspan="2"><a id="aed7f057eac94682a4aa2735af799e56a"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:aed7f057eac94682a4aa2735af799e56a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1min__operaton.html">accessor::min_operaton</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>min</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:aed7f057eac94682a4aa2735af799e56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71f6df883e89643ce21f8adbb2ce07e"><td class="memTemplParams" colspan="2"><a id="ac71f6df883e89643ce21f8adbb2ce07e"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:ac71f6df883e89643ce21f8adbb2ce07e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1min__operaton.html">accessor::min_operaton</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>min</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:ac71f6df883e89643ce21f8adbb2ce07e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af612eba2f92e21c5809701a80864565d"><td class="memTemplParams" colspan="2"><a id="af612eba2f92e21c5809701a80864565d"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:af612eba2f92e21c5809701a80864565d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1min__operaton.html">accessor::min_operaton</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>min</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:af612eba2f92e21c5809701a80864565d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25a3968d03816b31d07e8f45499796d"><td class="memTemplParams" colspan="2"><a id="af25a3968d03816b31d07e8f45499796d"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:af25a3968d03816b31d07e8f45499796d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1mmul__operation.html">accessor::mmul_operation</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mmul</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:af25a3968d03816b31d07e8f45499796d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821da786ceea22fbd7b3c259feef2ac2"><td class="memTemplParams" colspan="2"><a id="a821da786ceea22fbd7b3c259feef2ac2"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a821da786ceea22fbd7b3c259feef2ac2"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1mmul__operation.html">accessor::mmul_operation</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mmul</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a821da786ceea22fbd7b3c259feef2ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb6555448ea2dc4bcd3004eb7fa6479"><td class="memTemplParams" colspan="2"><a id="a0eb6555448ea2dc4bcd3004eb7fa6479"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:a0eb6555448ea2dc4bcd3004eb7fa6479"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1mmul__operation.html">accessor::mmul_operation</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mmul</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:a0eb6555448ea2dc4bcd3004eb7fa6479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2193d82004fe19f7fa1d9441e7e179c1"><td class="memTemplParams" colspan="2"><a id="a2193d82004fe19f7fa1d9441e7e179c1"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a2193d82004fe19f7fa1d9441e7e179c1"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1mmul__operation.html">accessor::mmul_operation</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mmul</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a2193d82004fe19f7fa1d9441e7e179c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2166ec09e3e8a0ef437aee9c2b97f422"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2166ec09e3e8a0ef437aee9c2b97f422"><td class="memTemplItemLeft" align="right" valign="top">detail::temporary_clone&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a2166ec09e3e8a0ef437aee9c2b97f422">make_temporary_clone</a> (std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt; exec, T *ptr)</td></tr>
<tr class="memdesc:a2166ec09e3e8a0ef437aee9c2b97f422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a temporary_clone.  <a href="namespacegko.html#a2166ec09e3e8a0ef437aee9c2b97f422">More...</a><br /></td></tr>
<tr class="separator:a2166ec09e3e8a0ef437aee9c2b97f422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0132e53621ce6f4222a2684ea6d6f021"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0132e53621ce6f4222a2684ea6d6f021"><td class="memTemplItemLeft" align="right" valign="top">detail::temporary_clone&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a0132e53621ce6f4222a2684ea6d6f021">make_temporary_output_clone</a> (std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt; exec, T *ptr)</td></tr>
<tr class="memdesc:a0132e53621ce6f4222a2684ea6d6f021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a uninitialized temporary_clone that will be copied back to the input afterwards.  <a href="namespacegko.html#a0132e53621ce6f4222a2684ea6d6f021">More...</a><br /></td></tr>
<tr class="separator:a0132e53621ce6f4222a2684ea6d6f021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dbafa6e062c2036991ec8c3f6b201cf"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#a4dbafa6e062c2036991ec8c3f6b201cf">operator==</a> (<a class="el" href="classgko_1_1precision__reduction.html">precision_reduction</a> x, <a class="el" href="classgko_1_1precision__reduction.html">precision_reduction</a> y) noexcept</td></tr>
<tr class="memdesc:a4dbafa6e062c2036991ec8c3f6b201cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two <a class="el" href="classgko_1_1precision__reduction.html" title="This class is used to encode storage precisions of low precision algorithms.">precision_reduction</a> encodings are equal.  <a href="namespacegko.html#a4dbafa6e062c2036991ec8c3f6b201cf">More...</a><br /></td></tr>
<tr class="separator:a4dbafa6e062c2036991ec8c3f6b201cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d408b4cd77aae6cac7a40c8307fddb"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#a61d408b4cd77aae6cac7a40c8307fddb">operator!=</a> (<a class="el" href="classgko_1_1precision__reduction.html">precision_reduction</a> x, <a class="el" href="classgko_1_1precision__reduction.html">precision_reduction</a> y) noexcept</td></tr>
<tr class="memdesc:a61d408b4cd77aae6cac7a40c8307fddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two <a class="el" href="classgko_1_1precision__reduction.html" title="This class is used to encode storage precisions of low precision algorithms.">precision_reduction</a> encodings are different.  <a href="namespacegko.html#a61d408b4cd77aae6cac7a40c8307fddb">More...</a><br /></td></tr>
<tr class="separator:a61d408b4cd77aae6cac7a40c8307fddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec01a3afbf68d99fc0f886c51bdc713"><td class="memTemplParams" colspan="2"><a id="afec01a3afbf68d99fc0f886c51bdc713"></a>
template&lt;typename IndexType &gt; </td></tr>
<tr class="memitem:afec01a3afbf68d99fc0f886c51bdc713"><td class="memTemplItemLeft" align="right" valign="top">constexpr IndexType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#afec01a3afbf68d99fc0f886c51bdc713">invalid_index</a> ()</td></tr>
<tr class="memdesc:afec01a3afbf68d99fc0f886c51bdc713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value for an invalid signed index type. <br /></td></tr>
<tr class="separator:afec01a3afbf68d99fc0f886c51bdc713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1beb80750459e4201aa9d882d2d074c3"><td class="memTemplParams" colspan="2">template&lt;typename Pointer &gt; </td></tr>
<tr class="memitem:a1beb80750459e4201aa9d882d2d074c3"><td class="memTemplItemLeft" align="right" valign="top">detail::cloned_type&lt; Pointer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a1beb80750459e4201aa9d882d2d074c3">clone</a> (const Pointer &amp;p)</td></tr>
<tr class="memdesc:a1beb80750459e4201aa9d882d2d074c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a unique clone of the object pointed to by <code>p</code>.  <a href="namespacegko.html#a1beb80750459e4201aa9d882d2d074c3">More...</a><br /></td></tr>
<tr class="separator:a1beb80750459e4201aa9d882d2d074c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b00a9dd24aa08d4495762d89f3762a"><td class="memTemplParams" colspan="2">template&lt;typename Pointer &gt; </td></tr>
<tr class="memitem:a13b00a9dd24aa08d4495762d89f3762a"><td class="memTemplItemLeft" align="right" valign="top">detail::cloned_type&lt; Pointer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a13b00a9dd24aa08d4495762d89f3762a">clone</a> (std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt; exec, const Pointer &amp;p)</td></tr>
<tr class="memdesc:a13b00a9dd24aa08d4495762d89f3762a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a unique clone of the object pointed to by <code>p</code> on <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a> <code>exec</code>.  <a href="namespacegko.html#a13b00a9dd24aa08d4495762d89f3762a">More...</a><br /></td></tr>
<tr class="separator:a13b00a9dd24aa08d4495762d89f3762a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce296f73db0ff398bdea6009a3a5c58"><td class="memTemplParams" colspan="2">template&lt;typename OwningPointer &gt; </td></tr>
<tr class="memitem:a3ce296f73db0ff398bdea6009a3a5c58"><td class="memTemplItemLeft" align="right" valign="top">detail::shared_type&lt; OwningPointer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a3ce296f73db0ff398bdea6009a3a5c58">share</a> (OwningPointer &amp;&amp;p)</td></tr>
<tr class="memdesc:a3ce296f73db0ff398bdea6009a3a5c58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the object pointed to by <code>p</code> as shared.  <a href="namespacegko.html#a3ce296f73db0ff398bdea6009a3a5c58">More...</a><br /></td></tr>
<tr class="separator:a3ce296f73db0ff398bdea6009a3a5c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd3fd6d07e498892881e8e2ab0b4167"><td class="memTemplParams" colspan="2">template&lt;typename OwningPointer &gt; </td></tr>
<tr class="memitem:acbd3fd6d07e498892881e8e2ab0b4167"><td class="memTemplItemLeft" align="right" valign="top">std::remove_reference&lt; OwningPointer &gt;::type &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#acbd3fd6d07e498892881e8e2ab0b4167">give</a> (OwningPointer &amp;&amp;p)</td></tr>
<tr class="memdesc:acbd3fd6d07e498892881e8e2ab0b4167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks that the object pointed to by <code>p</code> can be given to the callee.  <a href="namespacegko.html#acbd3fd6d07e498892881e8e2ab0b4167">More...</a><br /></td></tr>
<tr class="separator:acbd3fd6d07e498892881e8e2ab0b4167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014ec51e675c425bb83908361f630450"><td class="memTemplParams" colspan="2">template&lt;typename Pointer &gt; </td></tr>
<tr class="memitem:a014ec51e675c425bb83908361f630450"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; detail::have_ownership_s&lt; Pointer &gt;::value, detail::pointee&lt; Pointer &gt; * &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a014ec51e675c425bb83908361f630450">lend</a> (const Pointer &amp;p)</td></tr>
<tr class="memdesc:a014ec51e675c425bb83908361f630450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a non-owning (plain) pointer to the object pointed to by <code>p</code>.  <a href="namespacegko.html#a014ec51e675c425bb83908361f630450">More...</a><br /></td></tr>
<tr class="separator:a014ec51e675c425bb83908361f630450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3cb20c98b2bb170d222e976bdf7cb9"><td class="memTemplParams" colspan="2">template&lt;typename Pointer &gt; </td></tr>
<tr class="memitem:ade3cb20c98b2bb170d222e976bdf7cb9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!detail::have_ownership_s&lt; Pointer &gt;::value, detail::pointee&lt; Pointer &gt; * &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#ade3cb20c98b2bb170d222e976bdf7cb9">lend</a> (const Pointer &amp;p)</td></tr>
<tr class="memdesc:ade3cb20c98b2bb170d222e976bdf7cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a non-owning (plain) pointer to the object pointed to by <code>p</code>.  <a href="namespacegko.html#ade3cb20c98b2bb170d222e976bdf7cb9">More...</a><br /></td></tr>
<tr class="separator:ade3cb20c98b2bb170d222e976bdf7cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ce7e87aec389b5210630bb617b4baa"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a73ce7e87aec389b5210630bb617b4baa"><td class="memTemplItemLeft" align="right" valign="top">std::decay&lt; T &gt;::type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a73ce7e87aec389b5210630bb617b4baa">as</a> (U *obj)</td></tr>
<tr class="memdesc:a73ce7e87aec389b5210630bb617b4baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs polymorphic type conversion.  <a href="namespacegko.html#a73ce7e87aec389b5210630bb617b4baa">More...</a><br /></td></tr>
<tr class="separator:a73ce7e87aec389b5210630bb617b4baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289e84ef5dea2f579dd12f27140a1470"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a289e84ef5dea2f579dd12f27140a1470"><td class="memTemplItemLeft" align="right" valign="top">const std::decay&lt; T &gt;::type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a289e84ef5dea2f579dd12f27140a1470">as</a> (const U *obj)</td></tr>
<tr class="memdesc:a289e84ef5dea2f579dd12f27140a1470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs polymorphic type conversion.  <a href="namespacegko.html#a289e84ef5dea2f579dd12f27140a1470">More...</a><br /></td></tr>
<tr class="separator:a289e84ef5dea2f579dd12f27140a1470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1d94c42e7fd9103e256100d004f28a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a1f1d94c42e7fd9103e256100d004f28a"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; typename std::decay&lt; T &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a1f1d94c42e7fd9103e256100d004f28a">as</a> (std::unique_ptr&lt; U &gt; &amp;&amp;obj)</td></tr>
<tr class="memdesc:a1f1d94c42e7fd9103e256100d004f28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs polymorphic type conversion of a unique_ptr.  <a href="namespacegko.html#a1f1d94c42e7fd9103e256100d004f28a">More...</a><br /></td></tr>
<tr class="separator:a1f1d94c42e7fd9103e256100d004f28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f747ca6333526fbca64180417dc28a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a67f747ca6333526fbca64180417dc28a"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; typename std::decay&lt; T &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a67f747ca6333526fbca64180417dc28a">as</a> (std::shared_ptr&lt; U &gt; obj)</td></tr>
<tr class="memdesc:a67f747ca6333526fbca64180417dc28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs polymorphic type conversion of a shared_ptr.  <a href="namespacegko.html#a67f747ca6333526fbca64180417dc28a">More...</a><br /></td></tr>
<tr class="separator:a67f747ca6333526fbca64180417dc28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a5f4822744132cfc4a21439f19a67a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a78a5f4822744132cfc4a21439f19a67a"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; const typename std::decay&lt; T &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a78a5f4822744132cfc4a21439f19a67a">as</a> (std::shared_ptr&lt; const U &gt; obj)</td></tr>
<tr class="memdesc:a78a5f4822744132cfc4a21439f19a67a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs polymorphic type conversion of a shared_ptr.  <a href="namespacegko.html#a78a5f4822744132cfc4a21439f19a67a">More...</a><br /></td></tr>
<tr class="separator:a78a5f4822744132cfc4a21439f19a67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeaafa7179e5dbc1f1c02197598664fb"><td class="memItemLeft" align="right" valign="top"><a id="aeeaafa7179e5dbc1f1c02197598664fb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structgko_1_1version.html">version</a> &amp;first, const <a class="el" href="structgko_1_1version.html">version</a> &amp;second)</td></tr>
<tr class="separator:aeeaafa7179e5dbc1f1c02197598664fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d150bb18c9fbdc62c2a02315bd908b"><td class="memItemLeft" align="right" valign="top"><a id="af2d150bb18c9fbdc62c2a02315bd908b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="structgko_1_1version.html">version</a> &amp;first, const <a class="el" href="structgko_1_1version.html">version</a> &amp;second)</td></tr>
<tr class="separator:af2d150bb18c9fbdc62c2a02315bd908b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e5d651d3fc23e6ed48980efd2098d3"><td class="memItemLeft" align="right" valign="top"><a id="a70e5d651d3fc23e6ed48980efd2098d3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="structgko_1_1version.html">version</a> &amp;first, const <a class="el" href="structgko_1_1version.html">version</a> &amp;second)</td></tr>
<tr class="separator:a70e5d651d3fc23e6ed48980efd2098d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a749f76b73c3b0e161e2019ad12308"><td class="memItemLeft" align="right" valign="top"><a id="aa3a749f76b73c3b0e161e2019ad12308"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="structgko_1_1version.html">version</a> &amp;first, const <a class="el" href="structgko_1_1version.html">version</a> &amp;second)</td></tr>
<tr class="separator:aa3a749f76b73c3b0e161e2019ad12308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6724904a78b5293c610d113e3b23682"><td class="memItemLeft" align="right" valign="top"><a id="aa6724904a78b5293c610d113e3b23682"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="structgko_1_1version.html">version</a> &amp;first, const <a class="el" href="structgko_1_1version.html">version</a> &amp;second)</td></tr>
<tr class="separator:aa6724904a78b5293c610d113e3b23682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac033cb13ef2c4d291a894f26d2c64862"><td class="memItemLeft" align="right" valign="top"><a id="ac033cb13ef2c4d291a894f26d2c64862"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="structgko_1_1version.html">version</a> &amp;first, const <a class="el" href="structgko_1_1version.html">version</a> &amp;second)</td></tr>
<tr class="separator:ac033cb13ef2c4d291a894f26d2c64862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ef652f487afe43aebcf778038ff780"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#ae0ef652f487afe43aebcf778038ff780">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structgko_1_1version.html">version</a> &amp;ver)</td></tr>
<tr class="memdesc:ae0ef652f487afe43aebcf778038ff780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints version information to a stream.  <a href="namespacegko.html#ae0ef652f487afe43aebcf778038ff780">More...</a><br /></td></tr>
<tr class="separator:ae0ef652f487afe43aebcf778038ff780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e3ba96a10fe47a03ceef39b45bd43c"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#ad9e3ba96a10fe47a03ceef39b45bd43c">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classgko_1_1version__info.html">version_info</a> &amp;ver_info)</td></tr>
<tr class="memdesc:ad9e3ba96a10fe47a03ceef39b45bd43c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints library version information in human-readable format to a stream.  <a href="namespacegko.html#ad9e3ba96a10fe47a03ceef39b45bd43c">More...</a><br /></td></tr>
<tr class="separator:ad9e3ba96a10fe47a03ceef39b45bd43c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537803d962d07cf43e1e0cbc9f6a3f8b"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename, typename &gt; class MatrixType, typename... Args&gt; </td></tr>
<tr class="memitem:a537803d962d07cf43e1e0cbc9f6a3f8b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a537803d962d07cf43e1e0cbc9f6a3f8b">with_matrix_type</a> (Args &amp;&amp;... create_args)</td></tr>
<tr class="memdesc:a537803d962d07cf43e1e0cbc9f6a3f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a type that delays a call to MatrixType::create.  <a href="namespacegko.html#a537803d962d07cf43e1e0cbc9f6a3f8b">More...</a><br /></td></tr>
<tr class="separator:a537803d962d07cf43e1e0cbc9f6a3f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b90fccc0dbebcad123cc74d2abd73a"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:af1b90fccc0dbebcad123cc74d2abd73a"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classgko_1_1matrix_1_1Dense.html">matrix::Dense</a>&lt; ValueType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#af1b90fccc0dbebcad123cc74d2abd73a">make_dense_view</a> (<a class="el" href="classgko_1_1matrix_1_1Dense.html">matrix::Dense</a>&lt; ValueType &gt; *vector)</td></tr>
<tr class="memdesc:af1b90fccc0dbebcad123cc74d2abd73a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a view of a given Dense vector.  <a href="namespacegko.html#af1b90fccc0dbebcad123cc74d2abd73a">More...</a><br /></td></tr>
<tr class="separator:af1b90fccc0dbebcad123cc74d2abd73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8430581df497444dd83e9f8c3a9b9c65"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a8430581df497444dd83e9f8c3a9b9c65"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; const <a class="el" href="classgko_1_1matrix_1_1Dense.html">matrix::Dense</a>&lt; ValueType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a8430581df497444dd83e9f8c3a9b9c65">make_const_dense_view</a> (const <a class="el" href="classgko_1_1matrix_1_1Dense.html">matrix::Dense</a>&lt; ValueType &gt; *vector)</td></tr>
<tr class="memdesc:a8430581df497444dd83e9f8c3a9b9c65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a view of a given Dense vector.  <a href="namespacegko.html#a8430581df497444dd83e9f8c3a9b9c65">More...</a><br /></td></tr>
<tr class="separator:a8430581df497444dd83e9f8c3a9b9c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f54bac1e95fb3ef03974fa9c9088491"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename... TArgs&gt; </td></tr>
<tr class="memitem:ga2f54bac1e95fb3ef03974fa9c9088491"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Matrix &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LinOp.html#ga2f54bac1e95fb3ef03974fa9c9088491">initialize</a> (<a class="el" href="namespacegko.html#a6e5c95df0ae4e47aab2f604a22d98ee7">size_type</a> stride, std::initializer_list&lt; typename Matrix::value_type &gt; vals, std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt; exec, TArgs &amp;&amp;... create_args)</td></tr>
<tr class="memdesc:ga2f54bac1e95fb3ef03974fa9c9088491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and initializes a column-vector.  <a href="group__LinOp.html#ga2f54bac1e95fb3ef03974fa9c9088491">More...</a><br /></td></tr>
<tr class="separator:ga2f54bac1e95fb3ef03974fa9c9088491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac5f7b4ff3b43dbc6918c687dd7d2d2e"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename... TArgs&gt; </td></tr>
<tr class="memitem:gaac5f7b4ff3b43dbc6918c687dd7d2d2e"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Matrix &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LinOp.html#gaac5f7b4ff3b43dbc6918c687dd7d2d2e">initialize</a> (std::initializer_list&lt; typename Matrix::value_type &gt; vals, std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt; exec, TArgs &amp;&amp;... create_args)</td></tr>
<tr class="memdesc:gaac5f7b4ff3b43dbc6918c687dd7d2d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and initializes a column-vector.  <a href="group__LinOp.html#gaac5f7b4ff3b43dbc6918c687dd7d2d2e">More...</a><br /></td></tr>
<tr class="separator:gaac5f7b4ff3b43dbc6918c687dd7d2d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf2520e5921e1bea00853c290f4fc28f"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename... TArgs&gt; </td></tr>
<tr class="memitem:gaaf2520e5921e1bea00853c290f4fc28f"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Matrix &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LinOp.html#gaaf2520e5921e1bea00853c290f4fc28f">initialize</a> (<a class="el" href="namespacegko.html#a6e5c95df0ae4e47aab2f604a22d98ee7">size_type</a> stride, std::initializer_list&lt; std::initializer_list&lt; typename Matrix::value_type &gt;&gt; vals, std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt; exec, TArgs &amp;&amp;... create_args)</td></tr>
<tr class="memdesc:gaaf2520e5921e1bea00853c290f4fc28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and initializes a matrix.  <a href="group__LinOp.html#gaaf2520e5921e1bea00853c290f4fc28f">More...</a><br /></td></tr>
<tr class="separator:gaaf2520e5921e1bea00853c290f4fc28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe4ff67be5b3aae4e981b33ea9883385"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename... TArgs&gt; </td></tr>
<tr class="memitem:gabe4ff67be5b3aae4e981b33ea9883385"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Matrix &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LinOp.html#gabe4ff67be5b3aae4e981b33ea9883385">initialize</a> (std::initializer_list&lt; std::initializer_list&lt; typename Matrix::value_type &gt;&gt; vals, std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt; exec, TArgs &amp;&amp;... create_args)</td></tr>
<tr class="memdesc:gabe4ff67be5b3aae4e981b33ea9883385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and initializes a matrix.  <a href="group__LinOp.html#gabe4ff67be5b3aae4e981b33ea9883385">More...</a><br /></td></tr>
<tr class="separator:gabe4ff67be5b3aae4e981b33ea9883385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf34f605deac3e475189bb5b8a0fa71a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#acf34f605deac3e475189bb5b8a0fa71a">operator==</a> (const <a class="el" href="classgko_1_1stopping__status.html">stopping_status</a> &amp;x, const <a class="el" href="classgko_1_1stopping__status.html">stopping_status</a> &amp;y) noexcept</td></tr>
<tr class="memdesc:acf34f605deac3e475189bb5b8a0fa71a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two stopping statuses are equivalent.  <a href="namespacegko.html#acf34f605deac3e475189bb5b8a0fa71a">More...</a><br /></td></tr>
<tr class="separator:acf34f605deac3e475189bb5b8a0fa71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf1dbf5054c76e154490d825b0f44ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#accf1dbf5054c76e154490d825b0f44ee">operator!=</a> (const <a class="el" href="classgko_1_1stopping__status.html">stopping_status</a> &amp;x, const <a class="el" href="classgko_1_1stopping__status.html">stopping_status</a> &amp;y) noexcept</td></tr>
<tr class="memdesc:accf1dbf5054c76e154490d825b0f44ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two stopping statuses are different.  <a href="namespacegko.html#accf1dbf5054c76e154490d825b0f44ee">More...</a><br /></td></tr>
<tr class="separator:accf1dbf5054c76e154490d825b0f44ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a75fb6095836eeaadd8ae9137b9d224c2"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegko.html#afbed8e2cbd3ee4ca962e12f688858bdb">allocation_mode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>default_cuda_alloc_mode</b></td></tr>
<tr class="separator:a75fb6095836eeaadd8ae9137b9d224c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc4eaf27900ef925725bf542d705351"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegko.html#afbed8e2cbd3ee4ca962e12f688858bdb">allocation_mode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>default_hip_alloc_mode</b></td></tr>
<tr class="separator:a6dc4eaf27900ef925725bf542d705351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae2e648052ec788bd8ba9e0192652a6"><td class="memItemLeft" align="right" valign="top"><a id="acae2e648052ec788bd8ba9e0192652a6"></a>
constexpr <a class="el" href="namespacegko.html#a6e5c95df0ae4e47aab2f604a22d98ee7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#acae2e648052ec788bd8ba9e0192652a6">byte_size</a> = CHAR_BIT</td></tr>
<tr class="memdesc:acae2e648052ec788bd8ba9e0192652a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bits in a byte. <br /></td></tr>
<tr class="separator:acae2e648052ec788bd8ba9e0192652a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The Ginkgo namespace. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a6837b759dc528737540a83c79fbdda29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6837b759dc528737540a83c79fbdda29">&#9670;&nbsp;</a></span>highest_precision</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacegko.html#a6837b759dc528737540a83c79fbdda29">gko::highest_precision</a> = typedef typename detail::highest_precision_variadic&lt;Ts...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains the smallest arithmetic type that is able to store elements of all template parameter types exactly. </p>
<p>All template type parameters need to be either real or complex types, mixing them is not possible.</p>
<p>Formally, it computes a right-fold over the type list, with the highest precision of a pair of real arithmetic types T1, T2 computed as <code>decltype(T1{} + T2{})</code>, or <code>std::complex&lt;highest_precision&lt;remove_complex&lt;T1&gt;, remove_complex&lt;T2&gt;&gt;&gt;</code> for complex types. </p>

</div>
</div>
<a id="a7a3f195040a356643b3e8659554c7a48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a3f195040a356643b3e8659554c7a48">&#9670;&nbsp;</a></span>is_complex_or_scalar_s</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacegko.html#a7a3f195040a356643b3e8659554c7a48">gko::is_complex_or_scalar_s</a> = typedef detail::is_complex_or_scalar_impl&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows to check if T is a complex or scalar value during compile time by accessing the <code>value</code> attribute of this struct. </p>
<p>If <code>value</code> is <code>true</code>, T is a complex/scalar type, if it is <code>false</code>, T is not a complex/scalar type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeede19206954d5c8ebd04c95cf63bb88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeede19206954d5c8ebd04c95cf63bb88">&#9670;&nbsp;</a></span>is_complex_s</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacegko.html#aeede19206954d5c8ebd04c95cf63bb88">gko::is_complex_s</a> = typedef detail::is_complex_impl&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows to check if T is a complex value during compile time by accessing the <code>value</code> attribute of this struct. </p>
<p>If <code>value</code> is <code>true</code>, T is a complex type, if it is <code>false</code>, T is not a complex type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71559818fee20b97bc6ea6712ec75034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71559818fee20b97bc6ea6712ec75034">&#9670;&nbsp;</a></span>previous_precision</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacegko.html#a71559818fee20b97bc6ea6712ec75034">gko::previous_precision</a> = typedef <a class="el" href="namespacegko.html#a6362f751c7753cf4fa0a4771d56e8ede">next_precision</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains the previous type in the singly-linked precision list. </p>
<dl class="section note"><dt>Note</dt><dd>Currently our lists contains only two elements, so this is the same as next_precision. </dd></dl>

</div>
</div>
<a id="afd46d554050c4ae90e84ea4fcd9a41f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd46d554050c4ae90e84ea4fcd9a41f3">&#9670;&nbsp;</a></span>remove_complex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacegko.html#afd46d554050c4ae90e84ea4fcd9a41f3">gko::remove_complex</a> = typedef typename detail::remove_complex_s&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the type which removed the complex of complex/scalar type or the template parameter of class by accessing the <code>type</code> attribute of this struct. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type to remove complex</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>remove_complex&lt;class&gt; can not be used in friend class declaration. </dd></dl>

</div>
</div>
<a id="acc281c8ff5bfa4fd6f25afcce466b1af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc281c8ff5bfa4fd6f25afcce466b1af">&#9670;&nbsp;</a></span>to_complex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacegko.html#acc281c8ff5bfa4fd6f25afcce466b1af">gko::to_complex</a> = typedef typename detail::to_complex_s&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the type which adds the complex of complex/scalar type or the template parameter of class by accessing the <code>type</code> attribute of this struct. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type to complex_type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>to_complex&lt;class&gt; can not be used in friend class declaration. the followings are the error message from different combination. friend to_complex&lt;Csr&gt;; error: can not recognize it is class correctly. friend class to_complex&lt;Csr&gt;; error: using alias template specialization friend class to_complex_s&lt;Csr&lt;ValueType,IndexType&gt;&gt;::type; error: can not recognize it is class correctly. </dd></dl>

</div>
</div>
<a id="ace1eb45b2e5273be609ca5746089d18d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace1eb45b2e5273be609ca5746089d18d">&#9670;&nbsp;</a></span>to_real</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacegko.html#ace1eb45b2e5273be609ca5746089d18d">gko::to_real</a> = typedef <a class="el" href="namespacegko.html#afd46d554050c4ae90e84ea4fcd9a41f3">remove_complex</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>to_real is alias of remove_complex </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type to real </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="afbed8e2cbd3ee4ca962e12f688858bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbed8e2cbd3ee4ca962e12f688858bdb">&#9670;&nbsp;</a></span>allocation_mode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacegko.html#afbed8e2cbd3ee4ca962e12f688858bdb">gko::allocation_mode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specify the mode of allocation for CUDA/HIP GPUs. </p>
<p><code>device</code> allocates memory on the device and Unified Memory model is not used.</p>
<p><code>unified_global</code> allocates memory on the device, but is accessible by the host through the Unified memory model.</p>
<p><code>unified_host</code> allocates memory on the host and it is not available on devices which do not have concurrent acesses switched on, but this access can be explictly switched on, when necessary. </p>

</div>
</div>
<a id="ae749a5ea11a93c1bcc9158d9a6e9fb68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae749a5ea11a93c1bcc9158d9a6e9fb68">&#9670;&nbsp;</a></span>layout_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacegko.html#ae749a5ea11a93c1bcc9158d9a6e9fb68">gko::layout_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies the layout type when writing data in matrix market format. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae749a5ea11a93c1bcc9158d9a6e9fb68af1f713c9e000f5d3f280adbd124df4f5"></a>array&#160;</td><td class="fielddoc"><p>The matrix should be written as dense matrix in column-major order. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae749a5ea11a93c1bcc9158d9a6e9fb68af5d7aa3ba4929cc12dc51a92c59fabd3"></a>coordinate&#160;</td><td class="fielddoc"><p>The matrix should be written as a sparse matrix in coordinate format. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="adeb470aaf293d7c5548392b2f451e8e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeb470aaf293d7c5548392b2f451e8e4">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr xstd::enable_if_t&lt;!<a class="el" href="namespacegko.html#aeede19206954d5c8ebd04c95cf63bb88">is_complex_s</a>&lt;T&gt;::value, T&gt; gko::abs </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the absolute value of the object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the object</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x &gt;= <a class="el" href="namespacegko.html#a70dbe01ff95c7b953d3d737424c6feb5" title="Returns the additive identity for T.">zero&lt;T&gt;()</a> ? x : -x; </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespacegko.html#a58498d28d199c188555a48fda471f103">is_finite()</a>.</p>

</div>
</div>
<a id="a289e84ef5dea2f579dd12f27140a1470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a289e84ef5dea2f579dd12f27140a1470">&#9670;&nbsp;</a></span>as() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::decay&lt;T&gt;::type* gko::as </td>
          <td>(</td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs polymorphic type conversion. </p>
<p>This is the constant version of the function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>requested result type </td></tr>
    <tr><td class="paramname">U</td><td>static type of the passed object</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>the object which should be converted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful, returns a pointer to the subtype, otherwise throws <a class="el" href="classgko_1_1NotSupported.html" title="NotSupported is thrown in case it is not possible to perform the requested operation on the given obj...">NotSupported</a>. </dd></dl>

</div>
</div>
<a id="a78a5f4822744132cfc4a21439f19a67a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a5f4822744132cfc4a21439f19a67a">&#9670;&nbsp;</a></span>as() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const typename std::decay&lt;T&gt;::type&gt; gko::as </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const U &gt;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs polymorphic type conversion of a shared_ptr. </p>
<p>This is the constant version of the function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>requested result type </td></tr>
    <tr><td class="paramname">U</td><td>static type of the passed object</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>the shared_ptr to the object which should be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful, returns a shared_ptr to the subtype, otherwise throws <a class="el" href="classgko_1_1NotSupported.html" title="NotSupported is thrown in case it is not possible to perform the requested operation on the given obj...">NotSupported</a>. This pointer shares ownership with the input pointer. </dd></dl>

</div>
</div>
<a id="a67f747ca6333526fbca64180417dc28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67f747ca6333526fbca64180417dc28a">&#9670;&nbsp;</a></span>as() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;typename std::decay&lt;T&gt;::type&gt; gko::as </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; U &gt;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs polymorphic type conversion of a shared_ptr. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>requested result type </td></tr>
    <tr><td class="paramname">U</td><td>static type of the passed object</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>the shared_ptr to the object which should be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful, returns a shared_ptr to the subtype, otherwise throws <a class="el" href="classgko_1_1NotSupported.html" title="NotSupported is thrown in case it is not possible to perform the requested operation on the given obj...">NotSupported</a>. This pointer shares ownership with the input pointer. </dd></dl>

</div>
</div>
<a id="a1f1d94c42e7fd9103e256100d004f28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f1d94c42e7fd9103e256100d004f28a">&#9670;&nbsp;</a></span>as() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;typename std::decay&lt;T&gt;::type&gt; gko::as </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs polymorphic type conversion of a unique_ptr. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>requested result type </td></tr>
    <tr><td class="paramname">U</td><td>static type of the passed object</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>the unique_ptr to the object which should be converted. If successful, it will be reset to a nullptr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful, returns a unique_ptr to the subtype, otherwise throws <a class="el" href="classgko_1_1NotSupported.html" title="NotSupported is thrown in case it is not possible to perform the requested operation on the given obj...">NotSupported</a>. </dd></dl>

</div>
</div>
<a id="a73ce7e87aec389b5210630bb617b4baa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ce7e87aec389b5210630bb617b4baa">&#9670;&nbsp;</a></span>as() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::decay&lt;T&gt;::type* gko::as </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs polymorphic type conversion. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>requested result type </td></tr>
    <tr><td class="paramname">U</td><td>static type of the passed object</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>the object which should be converted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful, returns a pointer to the subtype, otherwise throws <a class="el" href="classgko_1_1NotSupported.html" title="NotSupported is thrown in case it is not possible to perform the requested operation on the given obj...">NotSupported</a>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classgko_1_1preconditioner_1_1Isai.html#a76b0195c7742295144b38edcc6bd4a0b">gko::preconditioner::Isai&lt; IsaiType, ValueType, IndexType &gt;::get_approximate_inverse()</a>.</p>

</div>
</div>
<a id="a93065a86872e6511b701b73b75823483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93065a86872e6511b701b73b75823483">&#9670;&nbsp;</a></span>ceildiv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacegko.html#a6c57dbf3168b1ecad3ea133aaf2efbc1">int64</a> gko::ceildiv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegko.html#a6c57dbf3168b1ecad3ea133aaf2efbc1">int64</a>&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegko.html#a6c57dbf3168b1ecad3ea133aaf2efbc1">int64</a>&#160;</td>
          <td class="paramname"><em>den</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs integer division with rounding up. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>numerator </td></tr>
    <tr><td class="paramname">den</td><td>denominator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the ceiled quotient. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classgko_1_1matrix_1_1Csr_1_1load__balance.html#ac0413220bebe762defe180d900240fac">gko::matrix::Csr&lt; ValueType, IndexType &gt;::load_balance::clac_size()</a>, <a class="el" href="structgko_1_1preconditioner_1_1block__interleaved__storage__scheme.html#ae46b38432c1e1b87d5743a649f2cfe84">gko::preconditioner::block_interleaved_storage_scheme&lt; index_type &gt;::compute_storage_space()</a>, and <a class="el" href="classgko_1_1matrix_1_1Csr_1_1load__balance.html#a0849e0d936dda023474673d7316e73d8">gko::matrix::Csr&lt; ValueType, IndexType &gt;::load_balance::process()</a>.</p>

</div>
</div>
<a id="a1beb80750459e4201aa9d882d2d074c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1beb80750459e4201aa9d882d2d074c3">&#9670;&nbsp;</a></span>clone() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Pointer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">detail::cloned_type&lt;Pointer&gt; gko::clone </td>
          <td>(</td>
          <td class="paramtype">const Pointer &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a unique clone of the object pointed to by <code>p</code>. </p>
<p>The pointee (i.e. <code>*p</code>) needs to have a clone method that returns a std::unique_ptr in order for this method to work.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Pointer</td><td>type of pointer to the object (plain or smart pointer)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>a pointer to the object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The difference between this function and directly calling LinOp::clone() is that this one preserves the static type of the object. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classgko_1_1preconditioner_1_1Ic.html#a1090b05e9e795c46bab7211aa20934ca">gko::preconditioner::Ic&lt; LSolverType, IndexType &gt;::operator=()</a>, <a class="el" href="classgko_1_1preconditioner_1_1Ilu.html#a23a9881155894ed00b7f216f269fd4e7">gko::preconditioner::Ilu&lt; LSolverType, USolverType, ReverseApply, IndexType &gt;::operator=()</a>, <a class="el" href="classgko_1_1solver_1_1EnablePreconditionable.html#ad1f52e213256cd7c50811787dfcf4288">gko::solver::EnablePreconditionable&lt; Bicg&lt; ValueType &gt; &gt;::set_preconditioner()</a>, and <a class="el" href="classgko_1_1solver_1_1EnableIterativeBase.html#a5e96a31681a2bc03fffb2d76e7a7da12">gko::solver::EnableIterativeBase&lt; Bicg&lt; ValueType &gt; &gt;::set_stop_criterion_factory()</a>.</p>

</div>
</div>
<a id="a13b00a9dd24aa08d4495762d89f3762a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b00a9dd24aa08d4495762d89f3762a">&#9670;&nbsp;</a></span>clone() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Pointer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">detail::cloned_type&lt;Pointer&gt; gko::clone </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Pointer &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a unique clone of the object pointed to by <code>p</code> on <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a> <code>exec</code>. </p>
<p>The pointee (i.e. <code>*p</code>) needs to have a clone method that takes an executor and returns a std::unique_ptr in order for this method to work.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Pointer</td><td>type of pointer to the object (plain or smart pointer)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>the executor where the cloned object should be stored </td></tr>
    <tr><td class="paramname">p</td><td>a pointer to the object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The difference between this function and directly calling LinOp::clone() is that this one preserves the static type of the object. </dd></dl>

</div>
</div>
<a id="ad79fd5c1fb85403796c40c0a916a15f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad79fd5c1fb85403796c40c0a916a15f2">&#9670;&nbsp;</a></span>conj()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto gko::conj </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the conjugate of an object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the number to conjugate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>conjugate of the object (by default, the object itself) </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespacegko.html#abbb55709b10d707b2cbef803832aa834">squared_norm()</a>.</p>

</div>
</div>
<a id="a3f3a167c72a0659cb9003b64c7b754d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f3a167c72a0659cb9003b64c7b754d0">&#9670;&nbsp;</a></span>copy_and_convert_to() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;const R, std::function&lt;void(const R*)&gt; &gt; gko::copy_and_convert_to </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the object to R and places it on <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a> exec. </p>
<p>If the object is already of the requested type and on the requested executor, the copy and conversion is avoided and a reference to the original object is returned instead.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>the type to which the object should be converted </td></tr>
    <tr><td class="paramname">T</td><td>the type of the input object</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>the executor where the result should be placed </td></tr>
    <tr><td class="paramname">obj</td><td>the object that should be converted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a unique pointer (with dynamically bound deleter) to the converted object</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a version of the function which adds the const qualifier to the result if the input had the same qualifier. </dd></dl>

</div>
</div>
<a id="a0f28847393e540a33fdda8cd80584789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f28847393e540a33fdda8cd80584789">&#9670;&nbsp;</a></span>copy_and_convert_to() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const R&gt; gko::copy_and_convert_to </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const T &gt;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>This is the version that takes in the std::shared_ptr and returns a std::shared_ptr</p>
<p>If the object is already of the requested type and on the requested executor, the copy and conversion is avoided and a reference to the original object is returned instead.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>the type to which the object should be converted </td></tr>
    <tr><td class="paramname">T</td><td>the type of the input object</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>the executor where the result should be placed </td></tr>
    <tr><td class="paramname">obj</td><td>the object that should be converted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a shared pointer to the converted object</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a version of the function which adds the const qualifier to the result if the input had the same qualifier. </dd></dl>

</div>
</div>
<a id="ac2b925f8d9f288210c7d1f0e00e5c495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b925f8d9f288210c7d1f0e00e5c495">&#9670;&nbsp;</a></span>copy_and_convert_to() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;R&gt; gko::copy_and_convert_to </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; T &gt;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the object to R and places it on <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a> exec. </p>
<p>This is the version that takes in the std::shared_ptr and returns a std::shared_ptr</p>
<p>If the object is already of the requested type and on the requested executor, the copy and conversion is avoided and a reference to the original object is returned instead.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>the type to which the object should be converted </td></tr>
    <tr><td class="paramname">T</td><td>the type of the input object</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>the executor where the result should be placed </td></tr>
    <tr><td class="paramname">obj</td><td>the object that should be converted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a shared pointer to the converted object </dd></dl>

</div>
</div>
<a id="abb378b82b7b7c6347ebdfb4c2ddc9366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb378b82b7b7c6347ebdfb4c2ddc9366">&#9670;&nbsp;</a></span>copy_and_convert_to() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;R, std::function&lt;void(R*)&gt; &gt; gko::copy_and_convert_to </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the object to R and places it on <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a> exec. </p>
<p>If the object is already of the requested type and on the requested executor, the copy and conversion is avoided and a reference to the original object is returned instead.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>the type to which the object should be converted </td></tr>
    <tr><td class="paramname">T</td><td>the type of the input object</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>the executor where the result should be placed </td></tr>
    <tr><td class="paramname">obj</td><td>the object that should be converted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a unique pointer (with dynamically bound deleter) to the converted object </dd></dl>

</div>
</div>
<a id="a4eea40e4123a3fdb60fcd92f902c6d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eea40e4123a3fdb60fcd92f902c6d6d">&#9670;&nbsp;</a></span>get_significant_bit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacegko.html#a318c831e3fe269ba04c6ed8bf5a71073">uint32</a> gko::get_significant_bit </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegko.html#a318c831e3fe269ba04c6ed8bf5a71073">uint32</a>&#160;</td>
          <td class="paramname"><em>hint</em> = <code>0u</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the position of the most significant bit of the number. </p>
<p>This is the same as the rounded down base-2 logarithm of the number.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>a numeric type supporting bit shift and comparison</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>a number </td></tr>
    <tr><td class="paramname">hint</td><td>a lower bound for the position o the significant bit</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>maximum of <code>hint</code> and the significant bit position of <code>n</code> </dd></dl>

</div>
</div>
<a id="ad39645fe8148a8a812a9528865a77600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39645fe8148a8a812a9528865a77600">&#9670;&nbsp;</a></span>get_superior_power()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T gko::get_superior_power </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>hint</em> = <code>T{1}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smallest power of <code>base</code> not smaller than <code>limit</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>a numeric type supporting multiplication and comparison</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>the base of the power to be returned </td></tr>
    <tr><td class="paramname">limit</td><td>the lower limit on the size of the power returned </td></tr>
    <tr><td class="paramname">hint</td><td>a lower bound on the result, has to be a power of base</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the smallest power of <code>base</code> not smaller than <code>limit</code> </dd></dl>

</div>
</div>
<a id="acbd3fd6d07e498892881e8e2ab0b4167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd3fd6d07e498892881e8e2ab0b4167">&#9670;&nbsp;</a></span>give()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OwningPointer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::remove_reference&lt;OwningPointer&gt;::type&amp;&amp; gko::give </td>
          <td>(</td>
          <td class="paramtype">OwningPointer &amp;&amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks that the object pointed to by <code>p</code> can be given to the callee. </p>
<p>Effectively calls <code>std::move(p)</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OwningPointer</td><td>type of pointer with ownership to the object (has to be a smart pointer)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>a pointer to the object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The original pointer <code>p</code> becomes invalid after this call. </dd></dl>

</div>
</div>
<a id="a795f649e3744fbfe128aec0b0f928aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a795f649e3744fbfe128aec0b0f928aaa">&#9670;&nbsp;</a></span>imag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto gko::imag </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the imaginary part of the object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the object</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>imaginary part of the object (by default, <a class="el" href="namespacegko.html#a70dbe01ff95c7b953d3d737424c6feb5" title="Returns the additive identity for T.">zero&lt;T&gt;()</a>) </dd></dl>

</div>
</div>
<a id="a9b3e79911bb6145d7ba865dbe436b915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b3e79911bb6145d7ba865dbe436b915">&#9670;&nbsp;</a></span>is_complex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool gko::is_complex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if T is a complex type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if T is a complex type, <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="a6881ebae53e15cb88342c0540d953f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6881ebae53e15cb88342c0540d953f59">&#9670;&nbsp;</a></span>is_complex_or_scalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool gko::is_complex_or_scalar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if T is a complex/scalar type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if T is a complex/scalar type, <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="a58498d28d199c188555a48fda471f103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58498d28d199c188555a48fda471f103">&#9670;&nbsp;</a></span>is_finite() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!<a class="el" href="namespacegko.html#aeede19206954d5c8ebd04c95cf63bb88">is_complex_s</a>&lt;T&gt;::value, bool&gt; gko::is_finite </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a floating point number is finite, meaning it is neither +/- infinity nor NaN. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the value to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>value to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is finite, meaning it are neither +/- infinity nor NaN. </dd></dl>

<p class="reference">References <a class="el" href="namespacegko.html#adeb470aaf293d7c5548392b2f451e8e4">abs()</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespacegko.html#a737d84b498f462463fa40846e22aec6d">is_finite()</a>.</p>

</div>
</div>
<a id="a737d84b498f462463fa40846e22aec6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a737d84b498f462463fa40846e22aec6d">&#9670;&nbsp;</a></span>is_finite() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="namespacegko.html#aeede19206954d5c8ebd04c95cf63bb88">is_complex_s</a>&lt;T&gt;::value, bool&gt; gko::is_finite </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if all components of a complex value are finite, meaning they are neither +/- infinity nor NaN. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>complex type of the value to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>complex value to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both components of the given value are finite, meaning they are neither +/- infinity nor NaN. </dd></dl>

<p class="reference">References <a class="el" href="namespacegko.html#a58498d28d199c188555a48fda471f103">is_finite()</a>.</p>

</div>
</div>
<a id="ae8b5bfaadc2c5a40f17f0459a3aa412d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b5bfaadc2c5a40f17f0459a3aa412d">&#9670;&nbsp;</a></span>is_nan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!<a class="el" href="namespacegko.html#aeede19206954d5c8ebd04c95cf63bb88">is_complex_s</a>&lt;T&gt;::value, bool&gt; gko::is_nan </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a floating point number is NaN. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the value to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>value to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is NaN. </dd></dl>

</div>
</div>
<a id="abb8963a80e755ccccebd819827995e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8963a80e755ccccebd819827995e1e">&#9670;&nbsp;</a></span>is_nan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="namespacegko.html#aeede19206954d5c8ebd04c95cf63bb88">is_complex_s</a>&lt;T&gt;::value, bool&gt; gko::is_nan </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if any component of a complex value is NaN. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>complex type of the value to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>complex value to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if any component of the given value is NaN. </dd></dl>

</div>
</div>
<a id="aef9b29733e6eb45475a2b84f79a6d012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef9b29733e6eb45475a2b84f79a6d012">&#9670;&nbsp;</a></span>is_nonzero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool gko::is_nonzero </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if and only if the given value is not zero. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the value</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the given value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff the given value is not zero, i.e. <code>value != zero&lt;T&gt;()</code> </dd></dl>

<p class="reference">Referenced by <a class="el" href="structgko_1_1matrix__data.html#a307091117617a342b9e576bcc9dd3c80">gko::matrix_data&lt; ValueType, IndexType &gt;::diag()</a>.</p>

</div>
</div>
<a id="a785976e6dbc9d8511325617ca46040bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a785976e6dbc9d8511325617ca46040bf">&#9670;&nbsp;</a></span>is_zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool gko::is_zero </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if and only if the given value is zero. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the value</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the given value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff the given value is zero, i.e. <code>value == zero&lt;T&gt;()</code> </dd></dl>

<p class="reference">Referenced by <a class="el" href="structgko_1_1matrix__data.html#a7b360eaf4c11e846c561f2910e2d425f">gko::matrix_data&lt; ValueType, IndexType &gt;::remove_zeros()</a>.</p>

</div>
</div>
<a id="a014ec51e675c425bb83908361f630450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a014ec51e675c425bb83908361f630450">&#9670;&nbsp;</a></span>lend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Pointer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;detail::have_ownership_s&lt;Pointer&gt;::value, detail::pointee&lt;Pointer&gt;*&gt;::type gko::lend </td>
          <td>(</td>
          <td class="paramtype">const Pointer &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a non-owning (plain) pointer to the object pointed to by <code>p</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Pointer</td><td>type of pointer to the object (plain or smart pointer)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>a pointer to the object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is the overload for owning (smart) pointers, that behaves the same as calling .get() on the smart pointer. </dd></dl>

</div>
</div>
<a id="ade3cb20c98b2bb170d222e976bdf7cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade3cb20c98b2bb170d222e976bdf7cb9">&#9670;&nbsp;</a></span>lend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Pointer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!detail::have_ownership_s&lt;Pointer&gt;::value, detail::pointee&lt;Pointer&gt;*&gt;::type gko::lend </td>
          <td>(</td>
          <td class="paramtype">const Pointer &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a non-owning (plain) pointer to the object pointed to by <code>p</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Pointer</td><td>type of pointer to the object (plain or smart pointer)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>a pointer to the object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is the overload for non-owning (plain) pointers, that just returns <code>p</code>. </dd></dl>

</div>
</div>
<a id="ab6c63e16608df2b83cf706b490bcef72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c63e16608df2b83cf706b490bcef72">&#9670;&nbsp;</a></span>make_array_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgko_1_1array.html">array</a>&lt;ValueType&gt; gko::make_array_view </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegko.html#a6e5c95df0ae4e47aab2f604a22d98ee7">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to create an array view deducing the value type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>the executor on which the array resides </td></tr>
    <tr><td class="paramname">size</td><td>the number of elements for the array </td></tr>
    <tr><td class="paramname">data</td><td>the pointer to the array we create a view on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>the type of the array elements</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>array&lt;ValueType&gt;::view(exec, size, data)</code> </dd></dl>

<p class="reference">References <a class="el" href="namespacegko.html#ab6c63e16608df2b83cf706b490bcef72">make_array_view()</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespacegko.html#ab6c63e16608df2b83cf706b490bcef72">make_array_view()</a>.</p>

</div>
</div>
<a id="aaf3c05a831ad72e1383bf393ff43e013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf3c05a831ad72e1383bf393ff43e013">&#9670;&nbsp;</a></span>make_const_array_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::const_array_view&lt;ValueType&gt; gko::make_const_array_view </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegko.html#a6e5c95df0ae4e47aab2f604a22d98ee7">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to create a const array view deducing the value type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>the executor on which the array resides </td></tr>
    <tr><td class="paramname">size</td><td>the number of elements for the array </td></tr>
    <tr><td class="paramname">data</td><td>the pointer to the array we create a view on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>the type of the array elements</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>array&lt;ValueType&gt;::const_view(exec, size, data)</code> </dd></dl>

<p class="reference">References <a class="el" href="namespacegko.html#aaf3c05a831ad72e1383bf393ff43e013">make_const_array_view()</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespacegko.html#aaf3c05a831ad72e1383bf393ff43e013">make_const_array_view()</a>.</p>

</div>
</div>
<a id="a8430581df497444dd83e9f8c3a9b9c65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8430581df497444dd83e9f8c3a9b9c65">&#9670;&nbsp;</a></span>make_const_dense_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;const <a class="el" href="classgko_1_1matrix_1_1Dense.html">matrix::Dense</a>&lt;ValueType&gt; &gt; gko::make_const_dense_view </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgko_1_1matrix_1_1Dense.html">matrix::Dense</a>&lt; ValueType &gt; *&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a view of a given Dense vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>the underlying value type of the vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>the vector on which to create the view </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classgko_1_1matrix_1_1Dense.html#a6ce80720088f8f10d7141c307eb8b1e7">gko::matrix::Dense&lt; ValueType &gt;::create_const_view_of()</a>.</p>

</div>
</div>
<a id="af1b90fccc0dbebcad123cc74d2abd73a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b90fccc0dbebcad123cc74d2abd73a">&#9670;&nbsp;</a></span>make_dense_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classgko_1_1matrix_1_1Dense.html">matrix::Dense</a>&lt;ValueType&gt; &gt; gko::make_dense_view </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgko_1_1matrix_1_1Dense.html">matrix::Dense</a>&lt; ValueType &gt; *&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a view of a given Dense vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>the underlying value type of the vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>the vector on which to create the view </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classgko_1_1matrix_1_1Dense.html#a37e735b174cd2211920a40df128357a7">gko::matrix::Dense&lt; ValueType &gt;::create_view_of()</a>.</p>

</div>
</div>
<a id="a2166ec09e3e8a0ef437aee9c2b97f422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2166ec09e3e8a0ef437aee9c2b97f422">&#9670;&nbsp;</a></span>make_temporary_clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::temporary_clone&lt;T&gt; gko::make_temporary_clone </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a temporary_clone. </p>
<p>This is a helper function which avoids the need to explicitly specify the type of the object, as would be the case if using the constructor of temporary_clone.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>the executor where the clone will be created </td></tr>
    <tr><td class="paramname">ptr</td><td>a pointer to the object of which the clone will be created </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="classgko_1_1ScaledIdentityAddable.html#ac854dff6c6789a8f30bc77c92864c004">gko::ScaledIdentityAddable::add_scaled_identity()</a>, <a class="el" href="classgko_1_1LinOp.html#a0449b2fc705d2f970855af23b5e2788e">gko::LinOp::apply()</a>, <a class="el" href="classgko_1_1matrix_1_1Coo.html#ad2e97eee0ad21f8896f4a82cc5ac8a50">gko::matrix::Coo&lt; ValueType, IndexType &gt;::apply2()</a>, <a class="el" href="classgko_1_1matrix_1_1Csr.html#afed96de4d6859e457dde15c2cb31ec8b">gko::matrix::Csr&lt; ValueType, IndexType &gt;::inv_scale()</a>, and <a class="el" href="classgko_1_1matrix_1_1Csr.html#af7735090a0e2d7e13ce5ec5c046f69e5">gko::matrix::Csr&lt; ValueType, IndexType &gt;::scale()</a>.</p>

</div>
</div>
<a id="a6470e8e212add7923569e6b885a74610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6470e8e212add7923569e6b885a74610">&#9670;&nbsp;</a></span>make_temporary_conversion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::temporary_conversion&lt;const <a class="el" href="classgko_1_1matrix_1_1Dense.html">matrix::Dense</a>&lt;ValueType&gt; &gt; gko::make_temporary_conversion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgko_1_1LinOp.html">LinOp</a> *&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the given <a class="el" href="classgko_1_1LinOp.html">LinOp</a> from matrix::Dense&lt;...&gt; to matrix::Dense&lt;ValueType&gt;. </p>
<p>The conversion tries to convert the input <a class="el" href="classgko_1_1LinOp.html">LinOp</a> to all Dense types with value type recursively reachable by next_precision&lt;...&gt; starting from the ValueType template parameter. This means that all real-to-real and complex-to-complex conversions for default precisions are being considered. If the input matrix is non-const, the contents of the modified converted object will be converted back to the input matrix when the returned object is destroyed. This may lead to a loss of precision!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>the input matrix which is supposed to be converted. It is wrapped unchanged if it is already of type matrix::Dense&lt;ValueType&gt;, otherwise it will be converted to this type if possible.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a detail::temporary_conversion pointing to the (potentially converted) object.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classgko_1_1NotSupported.html" title="NotSupported is thrown in case it is not possible to perform the requested operation on the given obj...">NotSupported</a></td><td>if the input matrix cannot be converted to matrix::Dense&lt;ValueType&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>the value type into whose associated <a class="el" href="classgko_1_1matrix_1_1Dense.html" title="Dense is a matrix format which explicitly stores all values of the matrix.">matrix::Dense</a> type to convert the input <a class="el" href="classgko_1_1LinOp.html">LinOp</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6861874b1a8e349961c487c92c497658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6861874b1a8e349961c487c92c497658">&#9670;&nbsp;</a></span>make_temporary_conversion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::temporary_conversion&lt;<a class="el" href="classgko_1_1matrix_1_1Dense.html">matrix::Dense</a>&lt;ValueType&gt; &gt; gko::make_temporary_conversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgko_1_1LinOp.html">LinOp</a> *&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the given <a class="el" href="classgko_1_1LinOp.html">LinOp</a> from matrix::Dense&lt;...&gt; to matrix::Dense&lt;ValueType&gt;. </p>
<p>The conversion tries to convert the input <a class="el" href="classgko_1_1LinOp.html">LinOp</a> to all Dense types with value type recursively reachable by next_precision&lt;...&gt; starting from the ValueType template parameter. This means that all real-to-real and complex-to-complex conversions for default precisions are being considered. If the input matrix is non-const, the contents of the modified converted object will be converted back to the input matrix when the returned object is destroyed. This may lead to a loss of precision!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>the input matrix which is supposed to be converted. It is wrapped unchanged if it is already of type matrix::Dense&lt;ValueType&gt;, otherwise it will be converted to this type if possible.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a detail::temporary_conversion pointing to the (potentially converted) object.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classgko_1_1NotSupported.html" title="NotSupported is thrown in case it is not possible to perform the requested operation on the given obj...">NotSupported</a></td><td>if the input matrix cannot be converted to matrix::Dense&lt;ValueType&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>the value type into whose associated <a class="el" href="classgko_1_1matrix_1_1Dense.html" title="Dense is a matrix format which explicitly stores all values of the matrix.">matrix::Dense</a> type to convert the input <a class="el" href="classgko_1_1LinOp.html">LinOp</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0132e53621ce6f4222a2684ea6d6f021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0132e53621ce6f4222a2684ea6d6f021">&#9670;&nbsp;</a></span>make_temporary_output_clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::temporary_clone&lt;T&gt; gko::make_temporary_output_clone </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a uninitialized temporary_clone that will be copied back to the input afterwards. </p>
<p>It can be used for output parameters to avoid an unnecessary copy in make_temporary_clone.</p>
<p>This is a helper function which avoids the need to explicitly specify the type of the object, as would be the case if using the constructor of temporary_clone.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>the executor where the uninitialized clone will be created </td></tr>
    <tr><td class="paramname">ptr</td><td>a pointer to the object of which the clone will be created </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1812df45c6ec07780d579a12b64c753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1812df45c6ec07780d579a12b64c753">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T gko::max </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the larger of the arguments. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the arguments</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x &gt;= y ? x : y </dd></dl>

</div>
</div>
<a id="aaaf8487194bcb40b528969c187a413a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf8487194bcb40b528969c187a413a0">&#9670;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T gko::min </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smaller of the arguments. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the arguments</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x &lt;= y ? x : y </dd></dl>

<p class="reference">Referenced by <a class="el" href="classgko_1_1matrix_1_1Csr_1_1load__balance.html#ac0413220bebe762defe180d900240fac">gko::matrix::Csr&lt; ValueType, IndexType &gt;::load_balance::clac_size()</a>.</p>

</div>
</div>
<a id="a205901dcce27e1df970c569d46d87551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a205901dcce27e1df970c569d46d87551">&#9670;&nbsp;</a></span>mixed_precision_dispatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gko::mixed_precision_dispatch </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgko_1_1LinOp.html">LinOp</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgko_1_1LinOp.html">LinOp</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the given function with each given argument <a class="el" href="classgko_1_1LinOp.html">LinOp</a> converted into matrix::Dense&lt;ValueType&gt; as parameters. </p>
<p>If GINKGO_MIXED_PRECISION is defined, this means that the function will be called with its dynamic type as a static type, so the (templated/generic) function will be instantiated with all pairs of Dense&lt;ValueType&gt; and Dense&lt;next_precision&lt;ValueType&gt;&gt; parameter types, and the appropriate overload will be called based on the dynamic type of the parameter.</p>
<p>If GINKGO_MIXED_PRECISION is not defined, it will behave exactly like precision_dispatch.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>the given function. It will be called with one const and one non-const matrix::Dense&lt;...&gt; parameter based on the dynamic type of the inputs (GINKGO_MIXED_PRECISION) or of type matrix::Dense&lt;ValueType&gt; (no GINKGO_MIXED_PRECISION). </td></tr>
    <tr><td class="paramname">in</td><td>The first parameter to be cast (GINKGO_MIXED_PRECISION) or converted (no GINKGO_MIXED_PRECISION) and used to call <code>fn</code>. </td></tr>
    <tr><td class="paramname">out</td><td>The second parameter to be cast (GINKGO_MIXED_PRECISION) or converted (no GINKGO_MIXED_PRECISION) and used to call <code>fn</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>the value type to use for the parameters of <code>fn</code> (no GINKGO_MIXED_PRECISION). With GINKGO_MIXED_PRECISION enabled, it only matters whether this type is complex or real. </td></tr>
    <tr><td class="paramname">Function</td><td>the function pointer, lambda or other functor type to call with the converted arguments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b9785eed86179e15b8fb4e74f7e9f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b9785eed86179e15b8fb4e74f7e9f89">&#9670;&nbsp;</a></span>mixed_precision_dispatch_real_complex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename Function , std::enable_if_t&lt; is_complex&lt; ValueType &gt;()&gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gko::mixed_precision_dispatch_real_complex </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgko_1_1LinOp.html">LinOp</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgko_1_1LinOp.html">LinOp</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the given function with the given LinOps cast to their dynamic type matrix::Dense&lt;ValueType&gt;* as parameters. </p>
<p>If ValueType is real and both <code>in</code> and <code>out</code> are complex, uses matrix::Dense::get_real_view() to convert them into real matrices after precision conversion.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegko.html#a205901dcce27e1df970c569d46d87551" title="Calls the given function with each given argument LinOp converted into matrix::Dense&lt;ValueType&gt; as pa...">mixed_precision_dispatch()</a> </dd></dl>

</div>
</div>
<a id="a4235252c8531e7028f76eff44b14dc53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4235252c8531e7028f76eff44b14dc53">&#9670;&nbsp;</a></span>nan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt;!<a class="el" href="namespacegko.html#aeede19206954d5c8ebd04c95cf63bb88">is_complex_s</a>&lt;T&gt;::value, T&gt; gko::nan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a quiet NaN of the given type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NaN. </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespacegko.html#a2fab450618d0d6a0bab20cead0d5b60b">nan()</a>.</p>

</div>
</div>
<a id="a2fab450618d0d6a0bab20cead0d5b60b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fab450618d0d6a0bab20cead0d5b60b">&#9670;&nbsp;</a></span>nan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt;<a class="el" href="namespacegko.html#aeede19206954d5c8ebd04c95cf63bb88">is_complex_s</a>&lt;T&gt;::value, T&gt; gko::nan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a complex with both components quiet NaN. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>complex{NaN, NaN}. </dd></dl>

<p class="reference">References <a class="el" href="namespacegko.html#a4235252c8531e7028f76eff44b14dc53">nan()</a>.</p>

</div>
</div>
<a id="a0059e27f8f4bc348ff65c1e60caf47c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0059e27f8f4bc348ff65c1e60caf47c8">&#9670;&nbsp;</a></span>one() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T gko::one </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the multiplicative identity for T. </p>
<dl class="section return"><dt>Returns</dt><dd>the multiplicative identity for T </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespacegko.html#ab92d450201f5b215901c0f8c3e2e376c">unit_root()</a>.</p>

</div>
</div>
<a id="ab4f16ecf0a759f46259cf9518f1e4568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f16ecf0a759f46259cf9518f1e4568">&#9670;&nbsp;</a></span>one() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T gko::one </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the multiplicative identity for T. </p>
<dl class="section return"><dt>Returns</dt><dd>the multiplicative identity for T</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This version takes an unused reference argument to avoid complicated calls like <code>one&lt;decltype(x)&gt;()</code>. Instead, it allows <code>one(x)</code>. </dd></dl>

</div>
</div>
<a id="a74c3716da36cbedc000aa24006b0bd46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74c3716da36cbedc000aa24006b0bd46">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_type Dimensionality, typename DimensionType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool gko::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgko_1_1dim.html">dim</a>&lt; Dimensionality, DimensionType &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgko_1_1dim.html">dim</a>&lt; Dimensionality, DimensionType &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two dim objects are different. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Dimensionality</td><td>number of dimensions of the dim objects </td></tr>
    <tr><td class="paramname">DimensionType</td><td>datatype used to represent each dimension</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>first object </td></tr>
    <tr><td class="paramname">y</td><td>second object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>!(x == y)</code> </dd></dl>

</div>
</div>
<a id="accf1dbf5054c76e154490d825b0f44ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf1dbf5054c76e154490d825b0f44ee">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gko::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgko_1_1stopping__status.html">stopping_status</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgko_1_1stopping__status.html">stopping_status</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two stopping statuses are different. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>a stopping status </td></tr>
    <tr><td class="paramname">y</td><td>a stopping status</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if <code>!(x == y)</code> </dd></dl>

</div>
</div>
<a id="a61d408b4cd77aae6cac7a40c8307fddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61d408b4cd77aae6cac7a40c8307fddb">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool gko::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgko_1_1precision__reduction.html">precision_reduction</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgko_1_1precision__reduction.html">precision_reduction</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two <a class="el" href="classgko_1_1precision__reduction.html" title="This class is used to encode storage precisions of low precision algorithms.">precision_reduction</a> encodings are different. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>an encoding </td></tr>
    <tr><td class="paramname">y</td><td>an encoding</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if <code>x</code> and <code>y</code> are different encodings. </dd></dl>

</div>
</div>
<a id="ae0ef652f487afe43aebcf778038ff780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ef652f487afe43aebcf778038ff780">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; gko::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgko_1_1version.html">version</a> &amp;&#160;</td>
          <td class="paramname"><em>ver</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints version information to a stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>output stream </td></tr>
    <tr><td class="paramname">ver</td><td>version structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>os </dd></dl>

<p class="reference">References <a class="el" href="structgko_1_1version.html#a019ce1d31714612e0c77c8ef5eb4cfde">gko::version::major</a>, <a class="el" href="structgko_1_1version.html#abb548e6dca39e0a3718ecf13cafbba36">gko::version::minor</a>, <a class="el" href="structgko_1_1version.html#a7580f68f7cf0600bc620c47ed6330c95">gko::version::patch</a>, and <a class="el" href="structgko_1_1version.html#a1bd0eaa4d551c145ff9cd0c10e555ac3">gko::version::tag</a>.</p>

</div>
</div>
<a id="ad9e3ba96a10fe47a03ceef39b45bd43c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e3ba96a10fe47a03ceef39b45bd43c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; gko::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgko_1_1version__info.html">version_info</a> &amp;&#160;</td>
          <td class="paramname"><em>ver_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints library version information in human-readable format to a stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>output stream </td></tr>
    <tr><td class="paramname">ver_info</td><td>version information</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>os </dd></dl>

</div>
</div>
<a id="acf34f605deac3e475189bb5b8a0fa71a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf34f605deac3e475189bb5b8a0fa71a">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gko::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgko_1_1stopping__status.html">stopping_status</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgko_1_1stopping__status.html">stopping_status</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two stopping statuses are equivalent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>a stopping status </td></tr>
    <tr><td class="paramname">y</td><td>a stopping status</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if both <code>x</code> and <code>y</code> have the same mask and converged and finalized state </dd></dl>

</div>
</div>
<a id="a4dbafa6e062c2036991ec8c3f6b201cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dbafa6e062c2036991ec8c3f6b201cf">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool gko::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgko_1_1precision__reduction.html">precision_reduction</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgko_1_1precision__reduction.html">precision_reduction</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two <a class="el" href="classgko_1_1precision__reduction.html" title="This class is used to encode storage precisions of low precision algorithms.">precision_reduction</a> encodings are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>an encoding </td></tr>
    <tr><td class="paramname">y</td><td>an encoding</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if <code>x</code> and <code>y</code> are the same encodings </dd></dl>

</div>
</div>
<a id="a0603ce0a60183a6698ac9b523694fb68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0603ce0a60183a6698ac9b523694fb68">&#9670;&nbsp;</a></span>pi()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T gko::pi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of pi. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the value type to return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c46f1caf8135f7492aa83d9ac3bc83e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c46f1caf8135f7492aa83d9ac3bc83e">&#9670;&nbsp;</a></span>precision_dispatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename Function , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gko::precision_dispatch </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args *...&#160;</td>
          <td class="paramname"><em>linops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the given function with each given argument <a class="el" href="classgko_1_1LinOp.html">LinOp</a> temporarily converted into matrix::Dense&lt;ValueType&gt; as parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>the given function. It will be passed one (potentially const) matrix::Dense&lt;ValueType&gt;* parameter per parameter in the parameter pack <code>linops</code>. </td></tr>
    <tr><td class="paramname">linops</td><td>the given arguments to be converted and passed on to fn.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>the value type to use for the parameters of <code>fn</code>. </td></tr>
    <tr><td class="paramname">Function</td><td>the function pointer, lambda or other functor type to call with the converted arguments. </td></tr>
    <tr><td class="paramname">Args</td><td>the argument type list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaebbe93d733274398213df2d3acf1b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaebbe93d733274398213df2d3acf1b79">&#9670;&nbsp;</a></span>precision_dispatch_real_complex() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gko::precision_dispatch_real_complex </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgko_1_1LinOp.html">LinOp</a> *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgko_1_1LinOp.html">LinOp</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgko_1_1LinOp.html">LinOp</a> *&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgko_1_1LinOp.html">LinOp</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the given function with the given LinOps temporarily converted to matrix::Dense&lt;ValueType&gt;* as parameters. </p>
<p>If ValueType is real and both <code>in</code> and <code>out</code> are complex, uses matrix::Dense::get_real_view() to convert them into real matrices after precision conversion.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegko.html#a3c46f1caf8135f7492aa83d9ac3bc83e" title="Calls the given function with each given argument LinOp temporarily converted into matrix::Dense&lt;Valu...">precision_dispatch()</a> </dd></dl>

</div>
</div>
<a id="a24dd55a9e5d991204024c68a501cdb3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24dd55a9e5d991204024c68a501cdb3e">&#9670;&nbsp;</a></span>precision_dispatch_real_complex() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gko::precision_dispatch_real_complex </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgko_1_1LinOp.html">LinOp</a> *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgko_1_1LinOp.html">LinOp</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgko_1_1LinOp.html">LinOp</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the given function with the given LinOps temporarily converted to matrix::Dense&lt;ValueType&gt;* as parameters. </p>
<p>If ValueType is real and both <code>in</code> and <code>out</code> are complex, uses matrix::Dense::get_real_view() to convert them into real matrices after precision conversion.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegko.html#a3c46f1caf8135f7492aa83d9ac3bc83e" title="Calls the given function with each given argument LinOp temporarily converted into matrix::Dense&lt;Valu...">precision_dispatch()</a> </dd></dl>

</div>
</div>
<a id="a98c5a37c89e32c0f2b567f8e73870e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c5a37c89e32c0f2b567f8e73870e3a">&#9670;&nbsp;</a></span>precision_dispatch_real_complex() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gko::precision_dispatch_real_complex </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgko_1_1LinOp.html">LinOp</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgko_1_1LinOp.html">LinOp</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the given function with the given LinOps temporarily converted to matrix::Dense&lt;ValueType&gt;* as parameters. </p>
<p>If ValueType is real and both input vectors are complex, uses matrix::Dense::get_real_view() to convert them into real matrices after precision conversion.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacegko.html#a3c46f1caf8135f7492aa83d9ac3bc83e" title="Calls the given function with each given argument LinOp temporarily converted into matrix::Dense&lt;Valu...">precision_dispatch()</a> </dd></dl>

</div>
</div>
<a id="a92cf0178c1c55419d32d2bb527e57e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92cf0178c1c55419d32d2bb527e57e5b">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename StreamType , typename... MatrixArgs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;MatrixType&gt; gko::read </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a matrix stored in matrix market format from an input stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>a <a class="el" href="classgko_1_1ReadableFromMatrixData.html" title="A LinOp implementing this interface can read its data from a matrix_data structure.">ReadableFromMatrixData</a> <a class="el" href="classgko_1_1LinOp.html">LinOp</a> type used to store the matrix once it's been read from disk. </td></tr>
    <tr><td class="paramname">StreamType</td><td>type of stream used to write the data to </td></tr>
    <tr><td class="paramname">MatrixArgs</td><td>additional argument types passed to MatrixType constructor</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>input stream from which to read the data </td></tr>
    <tr><td class="paramname">args</td><td>additional arguments passed to MatrixType constructor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A MatrixType <a class="el" href="classgko_1_1LinOp.html">LinOp</a> filled with data from filename </dd></dl>

<p class="reference">References <a class="el" href="namespacegko.html#a0b476e0e3df616b08efe85000bff8da0">read_raw()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classgko_1_1ReadableFromMatrixData.html#a7fc1141f76b70b6ca112c7b99387b8b7">gko::ReadableFromMatrixData&lt; ValueType, int32 &gt;::read()</a>.</p>

</div>
</div>
<a id="ad10dc71f76a4125568cb0ab5add863cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad10dc71f76a4125568cb0ab5add863cd">&#9670;&nbsp;</a></span>read_binary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename StreamType , typename... MatrixArgs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;MatrixType&gt; gko::read_binary </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a matrix stored in binary format from an input stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>a <a class="el" href="classgko_1_1ReadableFromMatrixData.html" title="A LinOp implementing this interface can read its data from a matrix_data structure.">ReadableFromMatrixData</a> <a class="el" href="classgko_1_1LinOp.html">LinOp</a> type used to store the matrix once it's been read from disk. </td></tr>
    <tr><td class="paramname">StreamType</td><td>type of stream used to write the data to </td></tr>
    <tr><td class="paramname">MatrixArgs</td><td>additional argument types passed to MatrixType constructor</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>input stream from which to read the data </td></tr>
    <tr><td class="paramname">args</td><td>additional arguments passed to MatrixType constructor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A MatrixType <a class="el" href="classgko_1_1LinOp.html">LinOp</a> filled with data from filename </dd></dl>

<p class="reference">References <a class="el" href="namespacegko.html#a4c57f7b636344e8b4d17d42d2f17358f">read_binary_raw()</a>.</p>

</div>
</div>
<a id="a4c57f7b636344e8b4d17d42d2f17358f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c57f7b636344e8b4d17d42d2f17358f">&#9670;&nbsp;</a></span>read_binary_raw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType  = default_precision, typename IndexType  = int32&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgko_1_1matrix__data.html">matrix_data</a>&lt;ValueType, IndexType&gt; gko::read_binary_raw </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a matrix stored in Ginkgo's binary matrix format from an input stream. </p>
<p>Note that this format depends on the processor's endianness, so files from a big endian processor can't be read from a little endian processor and vice-versa.</p>
<p>The binary format has the following structure (in system endianness):</p><ol type="1">
<li>A 32 byte header consisting of 4 uint64_t values: magic = GINKGO__: The highest two bytes stand for value and index type. value type: S (float), D (double), C (complex&lt;float&gt;), Z(complex&lt;double&gt;) index type: I (int32), L (int64) num_rows: Number of rows num_cols: Number of columns num_entries: Number of (row, column, value) tuples to follow</li>
<li>Following are num_entries blocks of size sizeof(IndexType) * 2 + sizeof(ValueType). Each consists of a row index stored as IndexType, followed by a column index stored as IndexType and a value stored as ValueType.</li>
</ol>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>type of matrix values </td></tr>
    <tr><td class="paramname">IndexType</td><td>type of matrix indexes</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>input stream from which to read the data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structgko_1_1matrix__data.html" title="This structure is used as an intermediate data type to store a sparse matrix.">matrix_data</a> structure containing the matrix. The nonzero elements are sorted in lexicographic order of their (row, column) indexes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is an advanced routine that will return the raw matrix data structure. Consider using <a class="el" href="namespacegko.html#ad10dc71f76a4125568cb0ab5add863cd" title="Reads a matrix stored in binary format from an input stream.">gko::read_binary</a> instead. </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespacegko.html#ad10dc71f76a4125568cb0ab5add863cd">read_binary()</a>.</p>

</div>
</div>
<a id="ac71759a8a78d3c4946a11ce4b378a88e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac71759a8a78d3c4946a11ce4b378a88e">&#9670;&nbsp;</a></span>read_generic()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename StreamType , typename... MatrixArgs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;MatrixType&gt; gko::read_generic </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a matrix stored either in binary or matrix market format from an input stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>a <a class="el" href="classgko_1_1ReadableFromMatrixData.html" title="A LinOp implementing this interface can read its data from a matrix_data structure.">ReadableFromMatrixData</a> <a class="el" href="classgko_1_1LinOp.html">LinOp</a> type used to store the matrix once it's been read from disk. </td></tr>
    <tr><td class="paramname">StreamType</td><td>type of stream used to write the data to </td></tr>
    <tr><td class="paramname">MatrixArgs</td><td>additional argument types passed to MatrixType constructor</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>input stream from which to read the data </td></tr>
    <tr><td class="paramname">args</td><td>additional arguments passed to MatrixType constructor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A MatrixType <a class="el" href="classgko_1_1LinOp.html">LinOp</a> filled with data from filename </dd></dl>

<p class="reference">References <a class="el" href="namespacegko.html#a3b610840dd471007b09be2fc1fe4b1e7">read_generic_raw()</a>.</p>

</div>
</div>
<a id="a3b610840dd471007b09be2fc1fe4b1e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b610840dd471007b09be2fc1fe4b1e7">&#9670;&nbsp;</a></span>read_generic_raw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType  = default_precision, typename IndexType  = int32&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgko_1_1matrix__data.html">matrix_data</a>&lt;ValueType, IndexType&gt; gko::read_generic_raw </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a matrix stored in either binary or matrix market format from an input stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>type of matrix values </td></tr>
    <tr><td class="paramname">IndexType</td><td>type of matrix indexes</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>input stream from which to read the data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structgko_1_1matrix__data.html" title="This structure is used as an intermediate data type to store a sparse matrix.">matrix_data</a> structure containing the matrix. The nonzero elements are sorted in lexicographic order of their (row, column) indexes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is an advanced routine that will return the raw matrix data structure. Consider using <a class="el" href="namespacegko.html#ac71759a8a78d3c4946a11ce4b378a88e" title="Reads a matrix stored either in binary or matrix market format from an input stream.">gko::read_generic</a> instead. </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespacegko.html#ac71759a8a78d3c4946a11ce4b378a88e">read_generic()</a>.</p>

</div>
</div>
<a id="a0b476e0e3df616b08efe85000bff8da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b476e0e3df616b08efe85000bff8da0">&#9670;&nbsp;</a></span>read_raw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType  = default_precision, typename IndexType  = int32&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgko_1_1matrix__data.html">matrix_data</a>&lt;ValueType, IndexType&gt; gko::read_raw </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a matrix stored in matrix market format from an input stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>type of matrix values </td></tr>
    <tr><td class="paramname">IndexType</td><td>type of matrix indexes</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>input stream from which to read the data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structgko_1_1matrix__data.html" title="This structure is used as an intermediate data type to store a sparse matrix.">matrix_data</a> structure containing the matrix. The nonzero elements are sorted in lexicographic order of their (row, column) indexes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is an advanced routine that will return the raw matrix data structure. Consider using <a class="el" href="namespacegko.html#a92cf0178c1c55419d32d2bb527e57e5b" title="Reads a matrix stored in matrix market format from an input stream.">gko::read</a> instead. </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespacegko.html#a92cf0178c1c55419d32d2bb527e57e5b">read()</a>.</p>

</div>
</div>
<a id="af21648097306adbabc6234b4609ce297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af21648097306adbabc6234b4609ce297">&#9670;&nbsp;</a></span>real()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto gko::real </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the real part of the object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the object</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>real part of the object (by default, the object itself) </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespacegko.html#abbb55709b10d707b2cbef803832aa834">squared_norm()</a>.</p>

</div>
</div>
<a id="a718bb2876f514b73c900f72fcc9d464e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a718bb2876f514b73c900f72fcc9d464e">&#9670;&nbsp;</a></span>reduce_add() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gko::reduce_add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgko_1_1array.html">array</a>&lt; ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgko_1_1array.html">array</a>&lt; ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduce (sum) the values in the array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">The</td><td>type of the input data</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_arr</td><td>the input array to be reduced </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">result</td><td>the reduced value. The result is written into the first entry and the value in the first entry is used as the initial value for the reduce. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12e62081e2511f958dc2c9f1cc73c11d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e62081e2511f958dc2c9f1cc73c11d">&#9670;&nbsp;</a></span>reduce_add() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ValueType gko::reduce_add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgko_1_1array.html">array</a>&lt; ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType&#160;</td>
          <td class="paramname"><em>init_val</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduce (sum) the values in the array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">The</td><td>type of the input data</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_arr</td><td>the input array to be reduced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">init_val</td><td>the initial value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reduced value </dd></dl>

</div>
</div>
<a id="a5f9c197f1db98fdc874f8907978ad114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f9c197f1db98fdc874f8907978ad114">&#9670;&nbsp;</a></span>round_down()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacegko.html#ab5d71c1f4bd1b654df1e561ea7a811f2">reduce_precision</a>&lt;T&gt; gko::round_down </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduces the precision of the input parameter. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the original precision</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to round down</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rounded down value </dd></dl>

</div>
</div>
<a id="ad45d1c855f31d2f8c1d3d799f2cf21c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45d1c855f31d2f8c1d3d799f2cf21c6">&#9670;&nbsp;</a></span>round_up()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacegko.html#a373c2b4782d95e675d7e91a75bab101d">increase_precision</a>&lt;T&gt; gko::round_up </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increases the precision of the input parameter. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the original precision</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to round up</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rounded up value </dd></dl>

</div>
</div>
<a id="aa1470fdc2a75dcda76bea4b879a29886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1470fdc2a75dcda76bea4b879a29886">&#9670;&nbsp;</a></span>safe_divide()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T gko::safe_divide </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the quotient of the given parameters, guarding against division by zero. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>value type of the parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the dividend </td></tr>
    <tr><td class="paramname">b</td><td>the divisor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of <code>a / b</code> if b is non-zero, zero otherwise. </dd></dl>

</div>
</div>
<a id="a3ce296f73db0ff398bdea6009a3a5c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce296f73db0ff398bdea6009a3a5c58">&#9670;&nbsp;</a></span>share()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OwningPointer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">detail::shared_type&lt;OwningPointer&gt; gko::share </td>
          <td>(</td>
          <td class="paramtype">OwningPointer &amp;&amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks the object pointed to by <code>p</code> as shared. </p>
<p>Effectively converts a pointer with ownership to std::shared_ptr.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OwningPointer</td><td>type of pointer with ownership to the object (has to be a smart pointer)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>a pointer to the object. It must be a temporary or explicitly marked movable (rvalue reference).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The original pointer <code>p</code> becomes invalid after this call. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classgko_1_1preconditioner_1_1Ic.html#ac5e214fa1008b2d1611a8cf0b4edd545">gko::preconditioner::Ic&lt; LSolverType, IndexType &gt;::conj_transpose()</a>, <a class="el" href="classgko_1_1preconditioner_1_1Ilu.html#a730786dbc37890c71f7555d563640fec">gko::preconditioner::Ilu&lt; LSolverType, USolverType, ReverseApply, IndexType &gt;::conj_transpose()</a>, <a class="el" href="classgko_1_1preconditioner_1_1Ic.html#aa058395d245de4ffdaddd5aa5a8fb42a">gko::preconditioner::Ic&lt; LSolverType, IndexType &gt;::transpose()</a>, and <a class="el" href="classgko_1_1preconditioner_1_1Ilu.html#a2dafdb3722dc990c5143237f40d812ba">gko::preconditioner::Ilu&lt; LSolverType, USolverType, ReverseApply, IndexType &gt;::transpose()</a>.</p>

</div>
</div>
<a id="abbb55709b10d707b2cbef803832aa834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbb55709b10d707b2cbef803832aa834">&#9670;&nbsp;</a></span>squared_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto gko::squared_norm </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="namespacegko.html#af21648097306adbabc6234b4609ce297">real</a>(<a class="el" href="namespacegko.html#ad79fd5c1fb85403796c40c0a916a15f2">conj</a>(x) * x))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the squared norm of the object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The squared norm of the object. </dd></dl>

<p class="reference">References <a class="el" href="namespacegko.html#ad79fd5c1fb85403796c40c0a916a15f2">conj()</a>, and <a class="el" href="namespacegko.html#af21648097306adbabc6234b4609ce297">real()</a>.</p>

</div>
</div>
<a id="a9b6a9d7018703d6d1f2140054e2afe4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b6a9d7018703d6d1f2140054e2afe4a">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DimensionType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgko_1_1dim.html">dim</a>&lt;2, DimensionType&gt; gko::transpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgko_1_1dim.html">dim</a>&lt; 2, DimensionType &gt; &amp;&#160;</td>
          <td class="paramname"><em>dimensions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="structgko_1_1dim.html">dim&lt;2&gt;</a> object with its dimensions swapped. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DimensionType</td><td>datatype used to represent each dimension</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dimensions</td><td>original object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="structgko_1_1dim.html">dim&lt;2&gt;</a> object with its dimensions swapped </dd></dl>

<p class="reference">Referenced by <a class="el" href="classgko_1_1preconditioner_1_1Ic.html#ac5e214fa1008b2d1611a8cf0b4edd545">gko::preconditioner::Ic&lt; LSolverType, IndexType &gt;::conj_transpose()</a>, <a class="el" href="classgko_1_1preconditioner_1_1Ilu.html#a730786dbc37890c71f7555d563640fec">gko::preconditioner::Ilu&lt; LSolverType, USolverType, ReverseApply, IndexType &gt;::conj_transpose()</a>, <a class="el" href="classgko_1_1preconditioner_1_1Ic.html#aa058395d245de4ffdaddd5aa5a8fb42a">gko::preconditioner::Ic&lt; LSolverType, IndexType &gt;::transpose()</a>, and <a class="el" href="classgko_1_1preconditioner_1_1Ilu.html#a2dafdb3722dc990c5143237f40d812ba">gko::preconditioner::Ilu&lt; LSolverType, USolverType, ReverseApply, IndexType &gt;::transpose()</a>.</p>

</div>
</div>
<a id="ab92d450201f5b215901c0f8c3e2e376c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab92d450201f5b215901c0f8c3e2e376c">&#9670;&nbsp;</a></span>unit_root()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::complex&lt;<a class="el" href="namespacegko.html#afd46d554050c4ae90e84ea4fcd9a41f3">remove_complex</a>&lt;T&gt; &gt; gko::unit_root </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegko.html#a6c57dbf3168b1ecad3ea133aaf2efbc1">int64</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegko.html#a6c57dbf3168b1ecad3ea133aaf2efbc1">int64</a>&#160;</td>
          <td class="paramname"><em>k</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of exp(2 * pi * i * k / n), i.e. </p>
<p>an nth root of unity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the denominator of the argument </td></tr>
    <tr><td class="paramname">k</td><td>the numerator of the argument. Defaults to 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the corresponding real value type. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespacegko.html#a0059e27f8f4bc348ff65c1e60caf47c8">one()</a>.</p>

</div>
</div>
<a id="a537803d962d07cf43e1e0cbc9f6a3f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a537803d962d07cf43e1e0cbc9f6a3f8b">&#9670;&nbsp;</a></span>with_matrix_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename, typename &gt; class MatrixType, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gko::with_matrix_type </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>create_args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns a type that delays a call to MatrixType::create. </p>
<p>It can be used to set the used value and index type, as well as the executor at a later stage.</p>
<p>For example, the following code creates first a temporary object, which is then used later to construct an operator of the previously defined base type: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> type = gko::with_matrix_type&lt;gko::matrix::Csr&gt;();</div>
<div class="line">...</div>
<div class="line">std::unique_ptr&lt;LinOp&gt; concrete_op</div>
<div class="line"><span class="keywordflow">if</span>(flag1){</div>
<div class="line">  concrete_op = type.template create&lt;double, int&gt;(exec);</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">  concrete_op = type.template create&lt;float, int&gt;(exec);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This is mainly a helper function to specify the local matrix type for a <a class="el" href="classgko_1_1experimental_1_1distributed_1_1Matrix.html" title="The Matrix class defines a (MPI-)distributed matrix.">gko::experimental::distributed::Matrix</a> more easily.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>A template type that accepts two types, the first one will be set to the value type, the second one to the index type. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of the arguments passed to MatrixType::create.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">create_args</td><td>arguments that will be forwarded to MatrixType::create</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A type with a function <code>create&lt;value_type, index_type&gt;(executor)</code>. </dd></dl>

</div>
</div>
<a id="aa24837da3770b3dddf981d9bfe0d3b52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa24837da3770b3dddf981d9bfe0d3b52">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gko::write </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType *&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegko.html#ae749a5ea11a93c1bcc9158d9a6e9fb68">layout_type</a>&#160;</td>
          <td class="paramname"><em>layout</em> = <code>detail::mtx_io_traits&lt;std::remove_const_t&lt;MatrixType&gt;&gt;::default_layout</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a matrix into an output stream in matrix market format. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>a <a class="el" href="classgko_1_1WritableToMatrixData.html" title="A LinOp implementing this interface can write its data to a matrix_data structure.">WritableToMatrixData</a> object providing data to be written. </td></tr>
    <tr><td class="paramname">StreamType</td><td>type of stream used to write the data to</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>output stream where the data is to be written </td></tr>
    <tr><td class="paramname">matrix</td><td>the matrix to write </td></tr>
    <tr><td class="paramname">layout</td><td>the layout used in the output </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespacegko.html#ab31feb99c64fc6df58ac09abd4af69b6">write_raw()</a>.</p>

</div>
</div>
<a id="a1280f63daa434fc2afe2cf7974608d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1280f63daa434fc2afe2cf7974608d81">&#9670;&nbsp;</a></span>write_binary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gko::write_binary </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType *&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a matrix into an output stream in binary format. </p>
<p>Note that this format depends on the processor's endianness, so files from a big endian processor can't be read from a little endian processor and vice-versa.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>a <a class="el" href="classgko_1_1WritableToMatrixData.html" title="A LinOp implementing this interface can write its data to a matrix_data structure.">WritableToMatrixData</a> object providing data to be written. </td></tr>
    <tr><td class="paramname">StreamType</td><td>type of stream used to write the data to</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>output stream where the data is to be written </td></tr>
    <tr><td class="paramname">matrix</td><td>the matrix to write </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespacegko.html#a3b27a0c0282115116c160884dc0a9468">write_binary_raw()</a>.</p>

</div>
</div>
<a id="a3b27a0c0282115116c160884dc0a9468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b27a0c0282115116c160884dc0a9468">&#9670;&nbsp;</a></span>write_binary_raw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gko::write_binary_raw </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgko_1_1matrix__data.html">matrix_data</a>&lt; ValueType, IndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a <a class="el" href="structgko_1_1matrix__data.html" title="This structure is used as an intermediate data type to store a sparse matrix.">matrix_data</a> structure to a stream in binary format. </p>
<p>Note that this format depends on the processor's endianness, so files from a big endian processor can't be read from a little endian processor and vice-versa.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>type of matrix values </td></tr>
    <tr><td class="paramname">IndexType</td><td>type of matrix indexes</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>output stream where the data is to be written </td></tr>
    <tr><td class="paramname">data</td><td>the matrix data to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is an advanced routine that writes the raw matrix data structure. If you are trying to write an existing matrix, consider using <a class="el" href="namespacegko.html#a1280f63daa434fc2afe2cf7974608d81" title="Writes a matrix into an output stream in binary format.">gko::write_binary</a> instead. </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespacegko.html#a1280f63daa434fc2afe2cf7974608d81">write_binary()</a>.</p>

</div>
</div>
<a id="ab31feb99c64fc6df58ac09abd4af69b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab31feb99c64fc6df58ac09abd4af69b6">&#9670;&nbsp;</a></span>write_raw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gko::write_raw </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgko_1_1matrix__data.html">matrix_data</a>&lt; ValueType, IndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegko.html#ae749a5ea11a93c1bcc9158d9a6e9fb68">layout_type</a>&#160;</td>
          <td class="paramname"><em>layout</em> = <code><a class="el" href="namespacegko.html#ae749a5ea11a93c1bcc9158d9a6e9fb68af1f713c9e000f5d3f280adbd124df4f5">layout_type::array</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a <a class="el" href="structgko_1_1matrix__data.html" title="This structure is used as an intermediate data type to store a sparse matrix.">matrix_data</a> structure to a stream in matrix market format. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>type of matrix values </td></tr>
    <tr><td class="paramname">IndexType</td><td>type of matrix indexes</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>output stream where the data is to be written </td></tr>
    <tr><td class="paramname">data</td><td>the matrix data to write </td></tr>
    <tr><td class="paramname">layout</td><td>the layout used in the output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is an advanced routine that writes the raw matrix data structure. If you are trying to write an existing matrix, consider using <a class="el" href="namespacegko.html#aa24837da3770b3dddf981d9bfe0d3b52" title="Writes a matrix into an output stream in matrix market format.">gko::write</a> instead. </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespacegko.html#aa24837da3770b3dddf981d9bfe0d3b52">write()</a>.</p>

</div>
</div>
<a id="a70dbe01ff95c7b953d3d737424c6feb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70dbe01ff95c7b953d3d737424c6feb5">&#9670;&nbsp;</a></span>zero() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T gko::zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the additive identity for T. </p>
<dl class="section return"><dt>Returns</dt><dd>additive identity for T </dd></dl>

<p class="reference">Referenced by <a class="el" href="classgko_1_1matrix_1_1Hybrid_1_1strategy__type.html#a307425e7a1b925583cec9d6dd30be301">gko::matrix::Hybrid&lt; ValueType, IndexType &gt;::strategy_type::strategy_type()</a>.</p>

</div>
</div>
<a id="a9f1cd7be946b9a2c15b01b744cf3e732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f1cd7be946b9a2c15b01b744cf3e732">&#9670;&nbsp;</a></span>zero() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T gko::zero </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the additive identity for T. </p>
<dl class="section return"><dt>Returns</dt><dd>additive identity for T</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This version takes an unused reference argument to avoid complicated calls like <code>zero&lt;decltype(x)&gt;()</code>. Instead, it allows <code>zero(x)</code>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a75fb6095836eeaadd8ae9137b9d224c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75fb6095836eeaadd8ae9137b9d224c2">&#9670;&nbsp;</a></span>default_cuda_alloc_mode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacegko.html#afbed8e2cbd3ee4ca962e12f688858bdb">allocation_mode</a> gko::default_cuda_alloc_mode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    allocation_mode::unified_global</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6dc4eaf27900ef925725bf542d705351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dc4eaf27900ef925725bf542d705351">&#9670;&nbsp;</a></span>default_hip_alloc_mode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacegko.html#afbed8e2cbd3ee4ca962e12f688858bdb">allocation_mode</a> gko::default_hip_alloc_mode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    allocation_mode::unified_global</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
