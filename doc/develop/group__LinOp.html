<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Ginkgo: Linear Operators</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_doc.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Ginkgo
   &#160;<span id="projectnumber">Generated from pipelines/776798664 branch based on develop. Ginkgo version 1.5.0</span>
   </div>
   <div id="projectbrief">A numerical linear algebra library targeting many-core architectures</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Linear Operators</div>  </div>
</div><!--header-->
<div class="contents">

<p>A module dedicated to the implementation and usage of the Linear operators in Ginkgo.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Linear Operators:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="group__LinOp.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__factor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__factor.html">Factorizations</a></td></tr>
<tr class="memdesc:group__factor"><td class="mdescLeft">&#160;</td><td class="mdescRight">A module dedicated to the implementation and usage of the Factorizations in Ginkgo. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__mat__formats"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__formats.html">SpMV employing different Matrix formats</a></td></tr>
<tr class="memdesc:group__mat__formats"><td class="mdescLeft">&#160;</td><td class="mdescRight">A module dedicated to the implementation and usage of the various Matrix Formats in Ginkgo. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__precond"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__precond.html">Preconditioners</a></td></tr>
<tr class="memdesc:group__precond"><td class="mdescLeft">&#160;</td><td class="mdescRight">A module dedicated to the implementation and usage of the Preconditioners in Ginkgo. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__solvers"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__solvers.html">Solvers</a></td></tr>
<tr class="memdesc:group__solvers"><td class="mdescLeft">&#160;</td><td class="mdescRight">A module dedicated to the implementation and usage of the Solvers in Ginkgo. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1Combination.html">gko::Combination&lt; ValueType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classgko_1_1Combination.html" title="The Combination class can be used to construct a linear combination of multiple linear operators c1 *...">Combination</a> class can be used to construct a linear combination of multiple linear operators <code>c1 * op1 + c2 * op2 + ... </code> <a href="classgko_1_1Combination.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1Composition.html">gko::Composition&lt; ValueType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classgko_1_1Composition.html" title="The Composition class can be used to compose linear operators op1, op2, ..., opn and obtain the opera...">Composition</a> class can be used to compose linear operators <code>op1, op2, ..., opn</code> and obtain the operator <code>op1 * op2 * ... </code> <a href="classgko_1_1Composition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1LinOpFactory.html">gko::LinOpFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classgko_1_1LinOpFactory.html" title="A LinOpFactory represents a higher order mapping which transforms one linear operator into another.">LinOpFactory</a> represents a higher order mapping which transforms one linear operator into another.  <a href="classgko_1_1LinOpFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1ReadableFromMatrixData.html">gko::ReadableFromMatrixData&lt; ValueType, IndexType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classgko_1_1LinOp.html">LinOp</a> implementing this interface can read its data from a <a class="el" href="structgko_1_1matrix__data.html" title="This structure is used as an intermediate data type to store a sparse matrix.">matrix_data</a> structure.  <a href="classgko_1_1ReadableFromMatrixData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1WritableToMatrixData.html">gko::WritableToMatrixData&lt; ValueType, IndexType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classgko_1_1LinOp.html">LinOp</a> implementing this interface can write its data to a <a class="el" href="structgko_1_1matrix__data.html" title="This structure is used as an intermediate data type to store a sparse matrix.">matrix_data</a> structure.  <a href="classgko_1_1WritableToMatrixData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1Preconditionable.html">gko::Preconditionable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classgko_1_1LinOp.html">LinOp</a> implementing this interface can be preconditioned.  <a href="classgko_1_1Preconditionable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1DiagonalLinOpExtractable.html">gko::DiagonalLinOpExtractable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The diagonal of a <a class="el" href="classgko_1_1LinOp.html">LinOp</a> can be extracted.  <a href="classgko_1_1DiagonalLinOpExtractable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1DiagonalExtractable.html">gko::DiagonalExtractable&lt; ValueType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The diagonal of a <a class="el" href="classgko_1_1LinOp.html">LinOp</a> implementing this interface can be extracted.  <a href="classgko_1_1DiagonalExtractable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1EnableAbsoluteComputation.html">gko::EnableAbsoluteComputation&lt; AbsoluteLinOp &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classgko_1_1EnableAbsoluteComputation.html" title="The EnableAbsoluteComputation mixin provides the default implementations of compute_absolute_linop an...">EnableAbsoluteComputation</a> mixin provides the default implementations of <code>compute_absolute_linop</code> and the absolute interface.  <a href="classgko_1_1EnableAbsoluteComputation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1EnableLinOp.html">gko::EnableLinOp&lt; ConcreteLinOp, PolymorphicBase &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classgko_1_1EnableLinOp.html" title="The EnableLinOp mixin can be used to provide sensible default implementations of the majority of the ...">EnableLinOp</a> mixin can be used to provide sensible default implementations of the majority of the <a class="el" href="classgko_1_1LinOp.html">LinOp</a> and <a class="el" href="classgko_1_1PolymorphicObject.html" title="A PolymorphicObject is the abstract base for all &quot;heavy&quot; objects in Ginkgo that behave polymorphicall...">PolymorphicObject</a> interface.  <a href="classgko_1_1EnableLinOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1Perturbation.html">gko::Perturbation&lt; ValueType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classgko_1_1Perturbation.html" title="The Perturbation class can be used to construct a LinOp to represent the operation (identity + scalar...">Perturbation</a> class can be used to construct a <a class="el" href="classgko_1_1LinOp.html">LinOp</a> to represent the operation <code>(identity + scalar * basis * projector)</code>.  <a href="classgko_1_1Perturbation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1experimental_1_1EnableDistributedLinOp.html">gko::experimental::EnableDistributedLinOp&lt; ConcreteLinOp, PolymorphicBase &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This mixin does the same as <a class="el" href="classgko_1_1EnableLinOp.html" title="The EnableLinOp mixin can be used to provide sensible default implementations of the majority of the ...">EnableLinOp</a>, but for concrete types that are derived from <a class="el" href="classgko_1_1experimental_1_1distributed_1_1DistributedBase.html" title="A base class for distributed objects.">distributed::DistributedBase</a>.  <a href="classgko_1_1experimental_1_1EnableDistributedLinOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1experimental_1_1distributed_1_1preconditioner_1_1Schwarz.html">gko::experimental::distributed::preconditioner::Schwarz&lt; ValueType, LocalIndexType, GlobalIndexType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classgko_1_1experimental_1_1distributed_1_1preconditioner_1_1Schwarz.html" title="A Schwarz preconditioner is a simple domain decomposition preconditioner that generalizes the Block J...">Schwarz</a> preconditioner is a simple domain decomposition preconditioner that generalizes the Block Jacobi preconditioner, incorporating options for different local subdomain solvers and overlaps between the subdomains.  <a href="classgko_1_1experimental_1_1distributed_1_1preconditioner_1_1Schwarz.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1experimental_1_1distributed_1_1Vector.html">gko::experimental::distributed::Vector&lt; ValueType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1experimental_1_1distributed_1_1Vector.html" title="Vector is a format which explicitly stores (multiple) distributed column vectors in a dense storage f...">Vector</a> is a format which explicitly stores (multiple) distributed column vectors in a dense storage format.  <a href="classgko_1_1experimental_1_1distributed_1_1Vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1factorization_1_1Ic.html">gko::factorization::Ic&lt; ValueType, IndexType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an incomplete Cholesky factorization (IC(0)) of a sparse matrix.  <a href="classgko_1_1factorization_1_1Ic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1factorization_1_1Ilu.html">gko::factorization::Ilu&lt; ValueType, IndexType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an incomplete LU factorization &ndash; ILU(0) &ndash; of a sparse matrix.  <a href="classgko_1_1factorization_1_1Ilu.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1factorization_1_1ParIc.html">gko::factorization::ParIc&lt; ValueType, IndexType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ParIC is an incomplete Cholesky factorization which is computed in parallel.  <a href="classgko_1_1factorization_1_1ParIc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1factorization_1_1ParIct.html">gko::factorization::ParIct&lt; ValueType, IndexType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ParICT is an incomplete threshold-based Cholesky factorization which is computed in parallel.  <a href="classgko_1_1factorization_1_1ParIct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1factorization_1_1ParIlu.html">gko::factorization::ParIlu&lt; ValueType, IndexType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ParILU is an incomplete LU factorization which is computed in parallel.  <a href="classgko_1_1factorization_1_1ParIlu.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1factorization_1_1ParIlut.html">gko::factorization::ParIlut&lt; ValueType, IndexType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ParILUT is an incomplete threshold-based LU factorization which is computed in parallel.  <a href="classgko_1_1factorization_1_1ParIlut.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1matrix_1_1Coo.html">gko::matrix::Coo&lt; ValueType, IndexType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">COO stores a matrix in the coordinate matrix format.  <a href="classgko_1_1matrix_1_1Coo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1matrix_1_1Csr.html">gko::matrix::Csr&lt; ValueType, IndexType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSR is a matrix format which stores only the nonzero coefficients by compressing each row of the matrix (compressed sparse row format).  <a href="classgko_1_1matrix_1_1Csr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1matrix_1_1Dense.html">gko::matrix::Dense&lt; ValueType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1matrix_1_1Dense.html" title="Dense is a matrix format which explicitly stores all values of the matrix.">Dense</a> is a matrix format which explicitly stores all values of the matrix.  <a href="classgko_1_1matrix_1_1Dense.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1matrix_1_1Diagonal.html">gko::matrix::Diagonal&lt; ValueType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a utility which efficiently implements the diagonal matrix (a linear operator which scales a vector row wise).  <a href="classgko_1_1matrix_1_1Diagonal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1matrix_1_1Ell.html">gko::matrix::Ell&lt; ValueType, IndexType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ELL is a matrix format where stride with explicit zeros is used such that all rows have the same number of stored elements.  <a href="classgko_1_1matrix_1_1Ell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1matrix_1_1Fbcsr.html">gko::matrix::Fbcsr&lt; ValueType, IndexType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixed-block compressed sparse row storage matrix format.  <a href="classgko_1_1matrix_1_1Fbcsr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1matrix_1_1Fft.html">gko::matrix::Fft</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classgko_1_1LinOp.html">LinOp</a> implements a 1D Fourier matrix using the FFT algorithm.  <a href="classgko_1_1matrix_1_1Fft.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1matrix_1_1Fft2.html">gko::matrix::Fft2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classgko_1_1LinOp.html">LinOp</a> implements a 2D Fourier matrix using the FFT algorithm.  <a href="classgko_1_1matrix_1_1Fft2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1matrix_1_1Fft3.html">gko::matrix::Fft3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classgko_1_1LinOp.html">LinOp</a> implements a 3D Fourier matrix using the FFT algorithm.  <a href="classgko_1_1matrix_1_1Fft3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1matrix_1_1Hybrid.html">gko::matrix::Hybrid&lt; ValueType, IndexType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">HYBRID is a matrix format which splits the matrix into ELLPACK and COO format.  <a href="classgko_1_1matrix_1_1Hybrid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1matrix_1_1Identity.html">gko::matrix::Identity&lt; ValueType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a utility which efficiently implements the identity matrix (a linear operator which maps each vector to itself).  <a href="classgko_1_1matrix_1_1Identity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1matrix_1_1IdentityFactory.html">gko::matrix::IdentityFactory&lt; ValueType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This factory is a utility which can be used to generate <a class="el" href="classgko_1_1matrix_1_1Identity.html" title="This class is a utility which efficiently implements the identity matrix (a linear operator which map...">Identity</a> operators.  <a href="classgko_1_1matrix_1_1IdentityFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1matrix_1_1Permutation.html">gko::matrix::Permutation&lt; IndexType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1matrix_1_1Permutation.html" title="Permutation is a matrix &quot;format&quot; which stores the row and column permutation arrays which can be used...">Permutation</a> is a matrix "format" which stores the row and column permutation arrays which can be used for re-ordering the rows and columns a matrix.  <a href="classgko_1_1matrix_1_1Permutation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1matrix_1_1RowGatherer.html">gko::matrix::RowGatherer&lt; IndexType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1matrix_1_1RowGatherer.html" title="RowGatherer is a matrix &quot;format&quot; which stores the gather indices arrays which can be used to gather r...">RowGatherer</a> is a matrix "format" which stores the gather indices arrays which can be used to gather rows to another matrix.  <a href="classgko_1_1matrix_1_1RowGatherer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1matrix_1_1Sellp.html">gko::matrix::Sellp&lt; ValueType, IndexType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SELL-P is a matrix format similar to ELL format.  <a href="classgko_1_1matrix_1_1Sellp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1matrix_1_1SparsityCsr.html">gko::matrix::SparsityCsr&lt; ValueType, IndexType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1matrix_1_1SparsityCsr.html" title="SparsityCsr is a matrix format which stores only the sparsity pattern of a sparse matrix by compressi...">SparsityCsr</a> is a matrix format which stores only the sparsity pattern of a sparse matrix by compressing each row of the matrix (compressed sparse row format).  <a href="classgko_1_1matrix_1_1SparsityCsr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1multigrid_1_1FixedCoarsening.html">gko::multigrid::FixedCoarsening&lt; ValueType, IndexType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1multigrid_1_1FixedCoarsening.html" title="FixedCoarsening is a very simple coarse grid generation algorithm.">FixedCoarsening</a> is a very simple coarse grid generation algorithm.  <a href="classgko_1_1multigrid_1_1FixedCoarsening.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1multigrid_1_1Pgm.html">gko::multigrid::Pgm&lt; ValueType, IndexType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel graph match (<a class="el" href="classgko_1_1multigrid_1_1Pgm.html" title="Parallel graph match (Pgm) is the aggregate method introduced in the paper M.">Pgm</a>) is the aggregate method introduced in the paper M.  <a href="classgko_1_1multigrid_1_1Pgm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1preconditioner_1_1Ic.html">gko::preconditioner::Ic&lt; LSolverType, IndexType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Incomplete Cholesky (IC) preconditioner solves the equation <img class="formulaInl" alt="$LL^H*x = b$" src="form_47.png"/> for a given lower triangular matrix L and the right hand side b (can contain multiple right hand sides).  <a href="classgko_1_1preconditioner_1_1Ic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1preconditioner_1_1Ilu.html">gko::preconditioner::Ilu&lt; LSolverType, USolverType, ReverseApply, IndexType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Incomplete LU (ILU) preconditioner solves the equation <img class="formulaInl" alt="$LUx = b$" src="form_48.png"/> for a given lower triangular matrix L, an upper triangular matrix U and the right hand side b (can contain multiple right hand sides).  <a href="classgko_1_1preconditioner_1_1Ilu.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1preconditioner_1_1Isai.html">gko::preconditioner::Isai&lt; IsaiType, ValueType, IndexType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Incomplete Sparse Approximate Inverse (ISAI) Preconditioner generates an approximate inverse matrix for a given square matrix A, lower triangular matrix L, upper triangular matrix U or symmetric positive (spd) matrix B.  <a href="classgko_1_1preconditioner_1_1Isai.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1preconditioner_1_1Jacobi.html">gko::preconditioner::Jacobi&lt; ValueType, IndexType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A block-Jacobi preconditioner is a block-diagonal linear operator, obtained by inverting the diagonal blocks of the source operator.  <a href="classgko_1_1preconditioner_1_1Jacobi.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1solver_1_1Bicg.html">gko::solver::Bicg&lt; ValueType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">BICG or the Biconjugate gradient method is a Krylov subspace solver.  <a href="classgko_1_1solver_1_1Bicg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1solver_1_1Bicgstab.html">gko::solver::Bicgstab&lt; ValueType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">BiCGSTAB or the Bi-Conjugate Gradient-Stabilized is a Krylov subspace solver.  <a href="classgko_1_1solver_1_1Bicgstab.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1solver_1_1CbGmres.html">gko::solver::CbGmres&lt; ValueType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CB-GMRES or the compressed basis generalized minimal residual method is an iterative type Krylov subspace method which is suitable for nonsymmetric linear systems.  <a href="classgko_1_1solver_1_1CbGmres.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1solver_1_1Cg.html">gko::solver::Cg&lt; ValueType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CG or the conjugate gradient method is an iterative type Krylov subspace method which is suitable for symmetric positive definite methods.  <a href="classgko_1_1solver_1_1Cg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1solver_1_1Cgs.html">gko::solver::Cgs&lt; ValueType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGS or the conjugate gradient square method is an iterative type Krylov subspace method which is suitable for general systems.  <a href="classgko_1_1solver_1_1Cgs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1solver_1_1Fcg.html">gko::solver::Fcg&lt; ValueType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">FCG or the flexible conjugate gradient method is an iterative type Krylov subspace method which is suitable for symmetric positive definite methods.  <a href="classgko_1_1solver_1_1Fcg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1solver_1_1Gmres.html">gko::solver::Gmres&lt; ValueType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">GMRES or the generalized minimal residual method is an iterative type Krylov subspace method which is suitable for nonsymmetric linear systems.  <a href="classgko_1_1solver_1_1Gmres.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1solver_1_1Idr.html">gko::solver::Idr&lt; ValueType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">IDR(s) is an efficient method for solving large nonsymmetric systems of linear equations.  <a href="classgko_1_1solver_1_1Idr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1solver_1_1Ir.html">gko::solver::Ir&lt; ValueType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterative refinement (IR) is an iterative method that uses another coarse method to approximate the error of the current solution via the current residual.  <a href="classgko_1_1solver_1_1Ir.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1solver_1_1Multigrid.html">gko::solver::Multigrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1solver_1_1Multigrid.html" title="Multigrid methods have a hierarchy of many levels, whose corase level is a subset of the fine level,...">Multigrid</a> methods have a hierarchy of many levels, whose corase level is a subset of the fine level, of the problem.  <a href="classgko_1_1solver_1_1Multigrid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1solver_1_1SolverBase.html">gko::solver::SolverBase&lt; MatrixType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classgko_1_1LinOp.html">LinOp</a> implementing this interface stores a system matrix.  <a href="classgko_1_1solver_1_1SolverBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1solver_1_1EnableSolverBase.html">gko::solver::EnableSolverBase&lt; DerivedType, MatrixType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classgko_1_1LinOp.html">LinOp</a> deriving from this CRTP class stores a system matrix.  <a href="classgko_1_1solver_1_1EnableSolverBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1solver_1_1IterativeBase.html">gko::solver::IterativeBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classgko_1_1LinOp.html">LinOp</a> implementing this interface stores a stopping criterion factory.  <a href="classgko_1_1solver_1_1IterativeBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1solver_1_1EnableIterativeBase.html">gko::solver::EnableIterativeBase&lt; DerivedType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classgko_1_1LinOp.html">LinOp</a> deriving from this CRTP class stores a stopping criterion factory and allows applying with a guess.  <a href="classgko_1_1solver_1_1EnableIterativeBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1solver_1_1EnablePreconditionedIterativeSolver.html">gko::solver::EnablePreconditionedIterativeSolver&lt; ValueType, DerivedType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classgko_1_1LinOp.html">LinOp</a> implementing this interface stores a system matrix and stopping criterion factory.  <a href="classgko_1_1solver_1_1EnablePreconditionedIterativeSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1solver_1_1LowerTrs.html">gko::solver::LowerTrs&lt; ValueType, IndexType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1solver_1_1LowerTrs.html" title="LowerTrs is the triangular solver which solves the system L x = b, when L is a lower triangular matri...">LowerTrs</a> is the triangular solver which solves the system L x = b, when L is a lower triangular matrix.  <a href="classgko_1_1solver_1_1LowerTrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1solver_1_1UpperTrs.html">gko::solver::UpperTrs&lt; ValueType, IndexType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1solver_1_1UpperTrs.html" title="UpperTrs is the triangular solver which solves the system U x = b, when U is an upper triangular matr...">UpperTrs</a> is the triangular solver which solves the system U x = b, when U is an upper triangular matrix.  <a href="classgko_1_1solver_1_1UpperTrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga1fc8e9d8be0c9ad2d72bc1ddfc6d8358"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LinOp.html#ga1fc8e9d8be0c9ad2d72bc1ddfc6d8358">GKO_CREATE_FACTORY_PARAMETERS</a>(_parameters_name,  _factory_name)</td></tr>
<tr class="memdesc:ga1fc8e9d8be0c9ad2d72bc1ddfc6d8358"><td class="mdescLeft">&#160;</td><td class="mdescRight">This Macro will generate a new type containing the parameters for the factory <code>_factory_name</code>.  <a href="group__LinOp.html#ga1fc8e9d8be0c9ad2d72bc1ddfc6d8358">More...</a><br /></td></tr>
<tr class="separator:ga1fc8e9d8be0c9ad2d72bc1ddfc6d8358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e0af90ec2414b768266f77cedffc309"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LinOp.html#ga8e0af90ec2414b768266f77cedffc309">GKO_ENABLE_LIN_OP_FACTORY</a>(_lin_op,  _parameters_name,  _factory_name)</td></tr>
<tr class="memdesc:ga8e0af90ec2414b768266f77cedffc309"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro will generate a default implementation of a LinOpFactory for the LinOp subclass it is defined in.  <a href="group__LinOp.html#ga8e0af90ec2414b768266f77cedffc309">More...</a><br /></td></tr>
<tr class="separator:ga8e0af90ec2414b768266f77cedffc309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga521f65604cc4cf427dcb2ecfa49b757c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LinOp.html#ga521f65604cc4cf427dcb2ecfa49b757c">GKO_ENABLE_BUILD_METHOD</a>(_factory_name)</td></tr>
<tr class="memdesc:ga521f65604cc4cf427dcb2ecfa49b757c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a build method for the factory, simplifying its construction by removing the repetitive typing of factory's name.  <a href="group__LinOp.html#ga521f65604cc4cf427dcb2ecfa49b757c">More...</a><br /></td></tr>
<tr class="separator:ga521f65604cc4cf427dcb2ecfa49b757c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa037309884bbd0562b897cee95dd91c8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LinOp.html#gaa037309884bbd0562b897cee95dd91c8">GKO_FACTORY_PARAMETER</a>(_name, ...)</td></tr>
<tr class="memdesc:gaa037309884bbd0562b897cee95dd91c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a factory parameter in the factory parameters structure.  <a href="group__LinOp.html#gaa037309884bbd0562b897cee95dd91c8">More...</a><br /></td></tr>
<tr class="separator:gaa037309884bbd0562b897cee95dd91c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49d4c09c39f06b22bebbbfd1d8bfe450"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LinOp.html#ga49d4c09c39f06b22bebbbfd1d8bfe450">GKO_FACTORY_PARAMETER_SCALAR</a>(_name,  _default)&#160;&#160;&#160;<a class="el" href="group__LinOp.html#gaa037309884bbd0562b897cee95dd91c8">GKO_FACTORY_PARAMETER</a>(_name, _default)</td></tr>
<tr class="memdesc:ga49d4c09c39f06b22bebbbfd1d8bfe450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a scalar factory parameter in the factory parameters structure.  <a href="group__LinOp.html#ga49d4c09c39f06b22bebbbfd1d8bfe450">More...</a><br /></td></tr>
<tr class="separator:ga49d4c09c39f06b22bebbbfd1d8bfe450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa292314d27ec1fb7ad54debaa3606ea8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LinOp.html#gaa292314d27ec1fb7ad54debaa3606ea8">GKO_FACTORY_PARAMETER_VECTOR</a>(_name, ...)&#160;&#160;&#160;<a class="el" href="group__LinOp.html#gaa037309884bbd0562b897cee95dd91c8">GKO_FACTORY_PARAMETER</a>(_name, __VA_ARGS__)</td></tr>
<tr class="memdesc:gaa292314d27ec1fb7ad54debaa3606ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a vector factory parameter in the factory parameters structure.  <a href="group__LinOp.html#gaa292314d27ec1fb7ad54debaa3606ea8">More...</a><br /></td></tr>
<tr class="separator:gaa292314d27ec1fb7ad54debaa3606ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga24628d477cba68b31cea690572c51912"><td class="memTemplParams" colspan="2">template&lt;typename ConcreteFactory , typename ConcreteLinOp , typename ParametersType , typename PolymorphicBase  = LinOpFactory&gt; </td></tr>
<tr class="memitem:ga24628d477cba68b31cea690572c51912"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LinOp.html#ga24628d477cba68b31cea690572c51912">gko::EnableDefaultLinOpFactory</a> = <a class="el" href="classgko_1_1EnableDefaultFactory.html">EnableDefaultFactory</a>&lt; ConcreteFactory, ConcreteLinOp, ParametersType, PolymorphicBase &gt;</td></tr>
<tr class="memdesc:ga24628d477cba68b31cea690572c51912"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an alias for the <a class="el" href="classgko_1_1EnableDefaultFactory.html" title="This mixin provides a default implementation of a concrete factory.">EnableDefaultFactory</a> mixin, which correctly sets the template parameters to enable a subclass of <a class="el" href="classgko_1_1LinOpFactory.html" title="A LinOpFactory represents a higher order mapping which transforms one linear operator into another.">LinOpFactory</a>.  <a href="group__LinOp.html#ga24628d477cba68b31cea690572c51912">More...</a><br /></td></tr>
<tr class="separator:ga24628d477cba68b31cea690572c51912"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2f54bac1e95fb3ef03974fa9c9088491"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename... TArgs&gt; </td></tr>
<tr class="memitem:ga2f54bac1e95fb3ef03974fa9c9088491"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Matrix &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LinOp.html#ga2f54bac1e95fb3ef03974fa9c9088491">gko::initialize</a> (<a class="el" href="namespacegko.html#a6e5c95df0ae4e47aab2f604a22d98ee7">size_type</a> stride, std::initializer_list&lt; typename Matrix::value_type &gt; vals, std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt; exec, TArgs &amp;&amp;... create_args)</td></tr>
<tr class="memdesc:ga2f54bac1e95fb3ef03974fa9c9088491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and initializes a column-vector.  <a href="group__LinOp.html#ga2f54bac1e95fb3ef03974fa9c9088491">More...</a><br /></td></tr>
<tr class="separator:ga2f54bac1e95fb3ef03974fa9c9088491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac5f7b4ff3b43dbc6918c687dd7d2d2e"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename... TArgs&gt; </td></tr>
<tr class="memitem:gaac5f7b4ff3b43dbc6918c687dd7d2d2e"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Matrix &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LinOp.html#gaac5f7b4ff3b43dbc6918c687dd7d2d2e">gko::initialize</a> (std::initializer_list&lt; typename Matrix::value_type &gt; vals, std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt; exec, TArgs &amp;&amp;... create_args)</td></tr>
<tr class="memdesc:gaac5f7b4ff3b43dbc6918c687dd7d2d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and initializes a column-vector.  <a href="group__LinOp.html#gaac5f7b4ff3b43dbc6918c687dd7d2d2e">More...</a><br /></td></tr>
<tr class="separator:gaac5f7b4ff3b43dbc6918c687dd7d2d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf2520e5921e1bea00853c290f4fc28f"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename... TArgs&gt; </td></tr>
<tr class="memitem:gaaf2520e5921e1bea00853c290f4fc28f"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Matrix &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LinOp.html#gaaf2520e5921e1bea00853c290f4fc28f">gko::initialize</a> (<a class="el" href="namespacegko.html#a6e5c95df0ae4e47aab2f604a22d98ee7">size_type</a> stride, std::initializer_list&lt; std::initializer_list&lt; typename Matrix::value_type &gt;&gt; vals, std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt; exec, TArgs &amp;&amp;... create_args)</td></tr>
<tr class="memdesc:gaaf2520e5921e1bea00853c290f4fc28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and initializes a matrix.  <a href="group__LinOp.html#gaaf2520e5921e1bea00853c290f4fc28f">More...</a><br /></td></tr>
<tr class="separator:gaaf2520e5921e1bea00853c290f4fc28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe4ff67be5b3aae4e981b33ea9883385"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename... TArgs&gt; </td></tr>
<tr class="memitem:gabe4ff67be5b3aae4e981b33ea9883385"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Matrix &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LinOp.html#gabe4ff67be5b3aae4e981b33ea9883385">gko::initialize</a> (std::initializer_list&lt; std::initializer_list&lt; typename Matrix::value_type &gt;&gt; vals, std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt; exec, TArgs &amp;&amp;... create_args)</td></tr>
<tr class="memdesc:gabe4ff67be5b3aae4e981b33ea9883385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and initializes a matrix.  <a href="group__LinOp.html#gabe4ff67be5b3aae4e981b33ea9883385">More...</a><br /></td></tr>
<tr class="separator:gabe4ff67be5b3aae4e981b33ea9883385"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>A module dedicated to the implementation and usage of the Linear operators in Ginkgo. </p>
<p>Below we elaborate on one of the most important concepts of Ginkgo, the linear operator. The linear operator (<a class="el" href="classgko_1_1LinOp.html">LinOp</a>) is a base class for all linear algebra objects in Ginkgo. The main benefit of having a single base class for the entire collection of linear algebra objects (as opposed to having separate hierarchies for matrices, solvers and preconditioners) is the generality it provides.</p>
<h1><a class="anchor" id="linop_3"></a>
Advantages of this approach and usage</h1>
<p>A common interface often allows for writing more generic code. If a user's routine requires only operations provided by the <a class="el" href="classgko_1_1LinOp.html">LinOp</a> interface, the same code can be used for any kind of linear operators, independent of whether these are matrices, solvers or preconditioners. This feature is also extensively used in Ginkgo itself. For example, a preconditioner used inside a Krylov solver is a <a class="el" href="classgko_1_1LinOp.html">LinOp</a>. This allows the user to supply a wide variety of preconditioners: either the ones which were designed to be used in this scenario (like ILU or block-Jacobi), a user-supplied matrix which is known to be a good preconditioner for the specific problem, or even another solver (e.g., if constructing a flexible GMRES solver).</p>
<p>For example, a matrix free implementation would require the user to provide an apply implementation and instead of passing the generated matrix to the solver, they would have to provide their apply implementation for all the executors needed and no other code needs to be changed. See <a class="el" href="custom_matrix_format.html">The custom-matrix-format program</a> example for more details.</p>
<h1><a class="anchor" id="linop_concept"></a>
Linear operator as a concept</h1>
<p>The linear operator (<a class="el" href="classgko_1_1LinOp.html">LinOp</a>) is a base class for all linear algebra objects in Ginkgo. The main benefit of having a single base class for the entire collection of linear algebra objects (as opposed to having separate hierarchies for matrices, solvers and preconditioners) is the generality it provides.</p>
<p>First, since all subclasses provide a common interface, the library users are exposed to a smaller set of routines. For example, a matrix-vector product, a preconditioner application, or even a system solve are just different terms given to the operation of applying a certain linear operator to a vector. As such, Ginkgo uses the same routine name, <a class="el" href="classgko_1_1LinOp.html#a0449b2fc705d2f970855af23b5e2788e" title="Applies a linear operator to a vector (or a sequence of vectors).">LinOp::apply()</a> for each of these operations, where the actual operation performed depends on the type of linear operator involved in the operation.</p>
<p>Second, a common interface often allows for writing more generic code. If a user's routine requires only operations provided by the <a class="el" href="classgko_1_1LinOp.html">LinOp</a> interface, the same code can be used for any kind of linear operators, independent of whether these are matrices, solvers or preconditioners. This feature is also extensively used in Ginkgo itself. For example, a preconditioner used inside a Krylov solver is a <a class="el" href="classgko_1_1LinOp.html">LinOp</a>. This allows the user to supply a wide variety of preconditioners: either the ones which were designed to be used in this scenario (like ILU or block-Jacobi), a user-supplied matrix which is known to be a good preconditioner for the specific problem, or even another solver (e.g., if constructing a flexible GMRES solver).</p>
<p>A key observation for providing a unified interface for matrices, solvers, and preconditioners is that the most common operation performed on all of them can be expressed as an application of a linear operator to a vector:</p>
<ul>
<li>the sparse matrix-vector product with a matrix <img class="formulaInl" alt="$A$" src="form_0.png"/> is a linear operator application <img class="formulaInl" alt="$y = Ax$" src="form_1.png"/>;</li>
<li>the application of a preconditioner is a linear operator application <img class="formulaInl" alt="$y = M^{-1}x$" src="form_2.png"/>, where <img class="formulaInl" alt="$M$" src="form_3.png"/> is an approximation of the original system matrix <img class="formulaInl" alt="$A$" src="form_0.png"/> (thus a preconditioner represents an "approximate
    inverse" operator <img class="formulaInl" alt="$M^{-1}$" src="form_4.png"/>).</li>
<li>the system solve <img class="formulaInl" alt="$Ax = b$" src="form_5.png"/> can be viewed as linear operator application <img class="formulaInl" alt="$x = A^{-1}b$" src="form_6.png"/> (it goes without saying that the implementation of linear system solves does not follow this conceptual idea), so a linear system solver can be viewed as a representation of the operator <img class="formulaInl" alt="$A^{-1}$" src="form_7.png"/>.</li>
</ul>
<p>Finally, direct manipulation of <a class="el" href="classgko_1_1LinOp.html">LinOp</a> objects is rarely required in simple scenarios. As an illustrative example, one could construct a fixed-point iteration routine <img class="formulaInl" alt="$x_{k+1} = Lx_k + b$" src="form_8.png"/> as follows:</p>
<div class="fragment"><div class="line">std::unique_ptr&lt;matrix::Dense&lt;&gt;&gt; calculate_fixed_point(</div>
<div class="line">        <span class="keywordtype">int</span> iters, <span class="keyword">const</span> LinOp *L, <span class="keyword">const</span> matrix::Dense&lt;&gt; *x0</div>
<div class="line">        <span class="keyword">const</span> matrix::Dense&lt;&gt; *b)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> x = <a class="code" href="namespacegko.html#a1beb80750459e4201aa9d882d2d074c3">gko::clone</a>(x0);</div>
<div class="line">    <span class="keyword">auto</span> tmp = <a class="code" href="namespacegko.html#a1beb80750459e4201aa9d882d2d074c3">gko::clone</a>(x0);</div>
<div class="line">    <span class="keyword">auto</span> <a class="code" href="namespacegko.html#a0059e27f8f4bc348ff65c1e60caf47c8">one</a> = Dense&lt;&gt;::create(L-&gt;get_executor(), {1.0,});</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; iters; ++i) {</div>
<div class="line">        L-&gt;apply(<a class="code" href="namespacegko.html#a014ec51e675c425bb83908361f630450">gko::lend</a>(tmp), <a class="code" href="namespacegko.html#a014ec51e675c425bb83908361f630450">gko::lend</a>(x));</div>
<div class="line">        x-&gt;add_scaled(<a class="code" href="namespacegko.html#a014ec51e675c425bb83908361f630450">gko::lend</a>(<a class="code" href="namespacegko.html#a0059e27f8f4bc348ff65c1e60caf47c8">one</a>), <a class="code" href="namespacegko.html#a014ec51e675c425bb83908361f630450">gko::lend</a>(b));</div>
<div class="line">        tmp-&gt;copy_from(<a class="code" href="namespacegko.html#a014ec51e675c425bb83908361f630450">gko::lend</a>(x));</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> x;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Here, if <img class="formulaInl" alt="$L$" src="form_9.png"/> is a matrix, <a class="el" href="classgko_1_1LinOp.html#a0449b2fc705d2f970855af23b5e2788e" title="Applies a linear operator to a vector (or a sequence of vectors).">LinOp::apply()</a> refers to the matrix vector product, and <code>L-&gt;apply(a, b)</code> computes <img class="formulaInl" alt="$b = L \cdot a$" src="form_10.png"/>. <code>x-&gt;add_scaled(one.get(), b.get())</code> is the <code>axpy</code> vector update <img class="formulaInl" alt="$x:=x+b$" src="form_11.png"/>.</p>
<p>The interesting part of this example is the apply() routine at line 4 of the function body. Since this routine is part of the <a class="el" href="classgko_1_1LinOp.html">LinOp</a> base class, the fixed-point iteration routine can calculate a fixed point not only for matrices, but for any type of linear operator.</p>
<p><a class="el" href="group__LinOp.html">Linear Operators</a> </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga1fc8e9d8be0c9ad2d72bc1ddfc6d8358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fc8e9d8be0c9ad2d72bc1ddfc6d8358">&#9670;&nbsp;</a></span>GKO_CREATE_FACTORY_PARAMETERS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GKO_CREATE_FACTORY_PARAMETERS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_parameters_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_factory_name&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">public</span>:                                                                 \</div>
<div class="line">    class _factory_name;                                                \</div>
<div class="line">    struct _parameters_name##_type                                      \</div>
<div class="line">        : public ::gko::enable_parameters_type&lt;_parameters_name##_type, \</div>
<div class="line">                                               _factory_name&gt;</div>
</div><!-- fragment -->
<p>This Macro will generate a new type containing the parameters for the factory <code>_factory_name</code>. </p>
<p>For more details, see <a class="el" href="group__LinOp.html#ga8e0af90ec2414b768266f77cedffc309" title="This macro will generate a default implementation of a LinOpFactory for the LinOp subclass it is defi...">GKO_ENABLE_LIN_OP_FACTORY()</a>. It is required to use this macro <b>before</b> calling the macro <a class="el" href="group__LinOp.html#ga8e0af90ec2414b768266f77cedffc309" title="This macro will generate a default implementation of a LinOpFactory for the LinOp subclass it is defi...">GKO_ENABLE_LIN_OP_FACTORY()</a>. It is also required to use the same names for all parameters between both macros.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_parameters_name</td><td>name of the parameters member in the class </td></tr>
    <tr><td class="paramname">_factory_name</td><td>name of the generated factory type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga521f65604cc4cf427dcb2ecfa49b757c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga521f65604cc4cf427dcb2ecfa49b757c">&#9670;&nbsp;</a></span>GKO_ENABLE_BUILD_METHOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GKO_ENABLE_BUILD_METHOD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_factory_name</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">auto</span> build()-&gt;decltype(_factory_name::create())                   \</div>
<div class="line">    {                                                                        \</div>
<div class="line">        return _factory_name::create();                                      \</div>
<div class="line">    }                                                                        \</div>
<div class="line">    static_assert(<span class="keyword">true</span>,                                                      \</div>
<div class="line">                  <span class="stringliteral">&quot;This assert is used to counter the false positive extra &quot;</span> \</div>
<div class="line">                  <span class="stringliteral">&quot;semi-colon warnings&quot;</span>)</div>
</div><!-- fragment -->
<p>Defines a build method for the factory, simplifying its construction by removing the repetitive typing of factory's name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_factory_name</td><td>the factory for which to define the method </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8e0af90ec2414b768266f77cedffc309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e0af90ec2414b768266f77cedffc309">&#9670;&nbsp;</a></span>GKO_ENABLE_LIN_OP_FACTORY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GKO_ENABLE_LIN_OP_FACTORY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_lin_op, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_parameters_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_factory_name&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This macro will generate a default implementation of a LinOpFactory for the LinOp subclass it is defined in. </p>
<p>It is required to first call the macro <a class="el" href="group__LinOp.html#ga1fc8e9d8be0c9ad2d72bc1ddfc6d8358" title="This Macro will generate a new type containing the parameters for the factory _factory_name.">GKO_CREATE_FACTORY_PARAMETERS()</a> before this one in order to instantiate the parameters type first.</p>
<p>The list of parameters for the factory should be defined in a code block after the macro definition, and should contain a list of GKO_FACTORY_PARAMETER_* declarations. The class should provide a constructor with signature _lin_op(const _factory_name *, std::shared_ptr&lt;const LinOp&gt;) which the factory will use a callback to construct the object.</p>
<p>A minimal example of a linear operator is the following:</p>
<p>```c++ struct MyLinOp : public EnableLinOp&lt;MyLinOp&gt; { <a class="el" href="group__LinOp.html#ga8e0af90ec2414b768266f77cedffc309" title="This macro will generate a default implementation of a LinOpFactory for the LinOp subclass it is defi...">GKO_ENABLE_LIN_OP_FACTORY(MyLinOp, my_parameters, Factory)</a> { // a factory parameter named "my_value", of type int and default // value of 5 int <a class="el" href="group__LinOp.html#ga49d4c09c39f06b22bebbbfd1d8bfe450" title="Creates a scalar factory parameter in the factory parameters structure.">GKO_FACTORY_PARAMETER_SCALAR(my_value, 5)</a>; // a factory parameter named <code>my_pair</code> of type <code>std::pair&lt;int,int&gt;</code> // and default value {5, 5} std::pair&lt;int, int&gt; <a class="el" href="group__LinOp.html#gaa292314d27ec1fb7ad54debaa3606ea8" title="Creates a vector factory parameter in the factory parameters structure.">GKO_FACTORY_PARAMETER_VECTOR(my_pair, 5, 5)</a>; }; // constructor needed by EnableLinOp explicit MyLinOp(std::shared_ptr&lt;const Executor&gt; exec) { : EnableLinOp&lt;MyLinOp&gt;(exec) {} // constructor needed by the factory explicit MyLinOp(const Factory *factory, std::shared_ptr&lt;const LinOp&gt; matrix) : EnableLinOp&lt;MyLinOp&gt;(factory-&gt;get_executor()), matrix-&gt;get_size()), // store factory's parameters locally my_parameters_{factory-&gt;get_parameters()}, { int value = my_parameters_.my_value; // do something with value } </p><div class="fragment"><div class="line">MyLinOp can then be created <a class="code" href="namespacegko.html#a73ce7e87aec389b5210630bb617b4baa">as</a> follows:</div>
<div class="line"> </div>
<div class="line">```c++</div>
<div class="line"><span class="keyword">auto</span> exec = gko::ReferenceExecutor::create();</div>
<div class="line"><span class="comment">// create a factory with default `my_value` parameter</span></div>
<div class="line"><span class="keyword">auto</span> fact = MyLinOp::build().on(exec);</div>
<div class="line"><span class="comment">// create a operator using the factory:</span></div>
<div class="line"><span class="keyword">auto</span> my_op = fact-&gt;generate(gko::matrix::Identity::create(exec, 2));</div>
<div class="line">std::cout &lt;&lt; my_op-&gt;get_my_parameters().my_value;  <span class="comment">// prints 5</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// create a factory with custom `my_value` parameter</span></div>
<div class="line"><span class="keyword">auto</span> fact = MyLinOp::build().with_my_value(0).on(exec);</div>
<div class="line"><span class="comment">// create a operator using the factory:</span></div>
<div class="line"><span class="keyword">auto</span> my_op = fact-&gt;generate(gko::matrix::Identity::create(exec, 2));</div>
<div class="line">std::cout &lt;&lt; my_op-&gt;get_my_parameters().my_value;  <span class="comment">// prints 0</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>It is possible to combine both the #GKO_CREATE_FACTORY_PARAMETER_*() macros with this one in a unique macro for class <b>templates</b> (not with regular classes). Splitting this into two distinct macros allows to use them in all contexts. See <a href="https://stackoverflow.com/q/50202718/9385966">https://stackoverflow.com/q/50202718/9385966</a> for more details.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_lin_op</td><td>concrete operator for which the factory is to be created [CRTP parameter] </td></tr>
    <tr><td class="paramname">_parameters_name</td><td>name of the parameters member in the class (its type is <code>&lt;_parameters_name&gt;_type</code>, the protected member's name is <code>&lt;_parameters_name&gt;_</code>, and the public getter's name is <code>get_&lt;_parameters_name&gt;()</code>) </td></tr>
    <tr><td class="paramname">_factory_name</td><td>name of the generated factory type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa037309884bbd0562b897cee95dd91c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa037309884bbd0562b897cee95dd91c8">&#9670;&nbsp;</a></span>GKO_FACTORY_PARAMETER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GKO_FACTORY_PARAMETER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">mutable</span> _name{__VA_ARGS__};                                              \</div>
<div class="line">                                                                             \</div>
<div class="line">    template &lt;<span class="keyword">typename</span>... Args&gt;                                              \</div>
<div class="line">    auto with_##_name(Args&amp;&amp;... _value)                                      \</div>
<div class="line">        const-&gt;const std::decay_t&lt;decltype(*<span class="keyword">this</span>)&gt;&amp;                          \</div>
<div class="line">    {                                                                        \</div>
<div class="line">        using type = decltype(this-&gt;_name);                                  \</div>
<div class="line">        this-&gt;_name = type{std::forward&lt;Args&gt;(_value)...};                   \</div>
<div class="line">        return *<span class="keyword">this</span>;                                                        \</div>
<div class="line">    }                                                                        \</div>
<div class="line">    static_assert(<span class="keyword">true</span>,                                                      \</div>
<div class="line">                  <span class="stringliteral">&quot;This assert is used to counter the false positive extra &quot;</span> \</div>
<div class="line">                  <span class="stringliteral">&quot;semi-colon warnings&quot;</span>)</div>
</div><!-- fragment -->
<p>Creates a factory parameter in the factory parameters structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_name</td><td>name of the parameter </td></tr>
    <tr><td class="paramname">&lt;strong&gt;VA_ARGS&lt;/strong&gt;</td><td>default value of the parameter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__LinOp.html#ga8e0af90ec2414b768266f77cedffc309" title="This macro will generate a default implementation of a LinOpFactory for the LinOp subclass it is defi...">GKO_ENABLE_LIN_OP_FACTORY</a> for more details, and usage example</dd></dl>

</div>
</div>
<a id="ga49d4c09c39f06b22bebbbfd1d8bfe450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49d4c09c39f06b22bebbbfd1d8bfe450">&#9670;&nbsp;</a></span>GKO_FACTORY_PARAMETER_SCALAR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GKO_FACTORY_PARAMETER_SCALAR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_default&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__LinOp.html#gaa037309884bbd0562b897cee95dd91c8">GKO_FACTORY_PARAMETER</a>(_name, _default)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a scalar factory parameter in the factory parameters structure. </p>
<p>Scalar in this context means that the constructor for this type only takes a single parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_name</td><td>name of the parameter </td></tr>
    <tr><td class="paramname">_default</td><td>default value of the parameter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__LinOp.html#ga8e0af90ec2414b768266f77cedffc309" title="This macro will generate a default implementation of a LinOpFactory for the LinOp subclass it is defi...">GKO_ENABLE_LIN_OP_FACTORY</a> for more details, and usage example </dd></dl>

</div>
</div>
<a id="gaa292314d27ec1fb7ad54debaa3606ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa292314d27ec1fb7ad54debaa3606ea8">&#9670;&nbsp;</a></span>GKO_FACTORY_PARAMETER_VECTOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GKO_FACTORY_PARAMETER_VECTOR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__LinOp.html#gaa037309884bbd0562b897cee95dd91c8">GKO_FACTORY_PARAMETER</a>(_name, __VA_ARGS__)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a vector factory parameter in the factory parameters structure. </p>
<p>Vector in this context means that the constructor for this type takes multiple parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_name</td><td>name of the parameter </td></tr>
    <tr><td class="paramname">_default</td><td>default value of the parameter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__LinOp.html#ga8e0af90ec2414b768266f77cedffc309" title="This macro will generate a default implementation of a LinOpFactory for the LinOp subclass it is defi...">GKO_ENABLE_LIN_OP_FACTORY</a> for more details, and usage example </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga24628d477cba68b31cea690572c51912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24628d477cba68b31cea690572c51912">&#9670;&nbsp;</a></span>EnableDefaultLinOpFactory</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteFactory , typename ConcreteLinOp , typename ParametersType , typename PolymorphicBase  = LinOpFactory&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__LinOp.html#ga24628d477cba68b31cea690572c51912">gko::EnableDefaultLinOpFactory</a> = typedef <a class="el" href="classgko_1_1EnableDefaultFactory.html">EnableDefaultFactory</a>&lt;ConcreteFactory, ConcreteLinOp, ParametersType, PolymorphicBase&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an alias for the <a class="el" href="classgko_1_1EnableDefaultFactory.html" title="This mixin provides a default implementation of a concrete factory.">EnableDefaultFactory</a> mixin, which correctly sets the template parameters to enable a subclass of <a class="el" href="classgko_1_1LinOpFactory.html" title="A LinOpFactory represents a higher order mapping which transforms one linear operator into another.">LinOpFactory</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ConcreteFactory</td><td>the concrete factory which is being implemented [CRTP parmeter] </td></tr>
    <tr><td class="paramname">ConcreteLinOp</td><td>the concrete <a class="el" href="classgko_1_1LinOp.html">LinOp</a> type which this factory produces, needs to have a constructor which takes a const ConcreteFactory *, and an std::shared_ptr&lt;const LinOp&gt; as parameters. </td></tr>
    <tr><td class="paramname">ParametersType</td><td>a subclass of <a class="el" href="classgko_1_1enable__parameters__type.html" title="The enable_parameters_type mixin is used to create a base implementation of the factory parameters st...">enable_parameters_type</a> template which defines all of the parameters of the factory </td></tr>
    <tr><td class="paramname">PolymorphicBase</td><td>parent of ConcreteFactory in the polymorphic hierarchy, has to be a subclass of <a class="el" href="classgko_1_1LinOpFactory.html" title="A LinOpFactory represents a higher order mapping which transforms one linear operator into another.">LinOpFactory</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaaf2520e5921e1bea00853c290f4fc28f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf2520e5921e1bea00853c290f4fc28f">&#9670;&nbsp;</a></span>initialize() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename... TArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;Matrix&gt; gko::initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegko.html#a6e5c95df0ae4e47aab2f604a22d98ee7">size_type</a>&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; std::initializer_list&lt; typename Matrix::value_type &gt;&gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>create_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and initializes a matrix. </p>
<p>This function first creates a temporary Dense matrix, fills it with passed in values, and then converts the matrix to the requested type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Matrix</td><td>matrix type to initialize (Dense has to implement the ConvertibleTo&lt;Matrix&gt; interface) </td></tr>
    <tr><td class="paramname">TArgs</td><td>argument types for Matrix::create method (not including the implied <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a> as the first argument)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stride</td><td>row stride for the temporary Dense matrix </td></tr>
    <tr><td class="paramname">vals</td><td>values used to initialize the matrix </td></tr>
    <tr><td class="paramname">exec</td><td><a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a> associated to the matrix </td></tr>
    <tr><td class="paramname">create_args</td><td>additional arguments passed to Matrix::create, not including the <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a>, which is passed as the first argument </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classgko_1_1matrix_1_1Dense.html#af0f1af68853537807ca271a296de3cd0">gko::matrix::Dense&lt; ValueType &gt;::at()</a>.</p>

</div>
</div>
<a id="ga2f54bac1e95fb3ef03974fa9c9088491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f54bac1e95fb3ef03974fa9c9088491">&#9670;&nbsp;</a></span>initialize() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename... TArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;Matrix&gt; gko::initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegko.html#a6e5c95df0ae4e47aab2f604a22d98ee7">size_type</a>&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; typename Matrix::value_type &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>create_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and initializes a column-vector. </p>
<p>This function first creates a temporary Dense matrix, fills it with passed in values, and then converts the matrix to the requested type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Matrix</td><td>matrix type to initialize (Dense has to implement the ConvertibleTo&lt;Matrix&gt; interface) </td></tr>
    <tr><td class="paramname">TArgs</td><td>argument types for Matrix::create method (not including the implied <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a> as the first argument)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stride</td><td>row stride for the temporary Dense matrix </td></tr>
    <tr><td class="paramname">vals</td><td>values used to initialize the vector </td></tr>
    <tr><td class="paramname">exec</td><td><a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a> associated to the vector </td></tr>
    <tr><td class="paramname">create_args</td><td>additional arguments passed to Matrix::create, not including the <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a>, which is passed as the first argument </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classgko_1_1matrix_1_1Dense.html#af0f1af68853537807ca271a296de3cd0">gko::matrix::Dense&lt; ValueType &gt;::at()</a>.</p>

</div>
</div>
<a id="gabe4ff67be5b3aae4e981b33ea9883385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe4ff67be5b3aae4e981b33ea9883385">&#9670;&nbsp;</a></span>initialize() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename... TArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;Matrix&gt; gko::initialize </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; std::initializer_list&lt; typename Matrix::value_type &gt;&gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>create_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and initializes a matrix. </p>
<p>This function first creates a temporary Dense matrix, fills it with passed in values, and then converts the matrix to the requested type. The stride of the intermediate Dense matrix is set to the number of columns of the initializer list.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Matrix</td><td>matrix type to initialize (Dense has to implement the ConvertibleTo&lt;Matrix&gt; interface) </td></tr>
    <tr><td class="paramname">TArgs</td><td>argument types for Matrix::create method (not including the implied <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a> as the first argument)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vals</td><td>values used to initialize the matrix </td></tr>
    <tr><td class="paramname">exec</td><td><a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a> associated to the matrix </td></tr>
    <tr><td class="paramname">create_args</td><td>additional arguments passed to Matrix::create, not including the <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a>, which is passed as the first argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaac5f7b4ff3b43dbc6918c687dd7d2d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac5f7b4ff3b43dbc6918c687dd7d2d2e">&#9670;&nbsp;</a></span>initialize() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename... TArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;Matrix&gt; gko::initialize </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; typename Matrix::value_type &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>create_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and initializes a column-vector. </p>
<p>This function first creates a temporary Dense matrix, fills it with passed in values, and then converts the matrix to the requested type. The stride of the intermediate Dense matrix is set to 1.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Matrix</td><td>matrix type to initialize (Dense has to implement the ConvertibleTo&lt;Matrix&gt; interface) </td></tr>
    <tr><td class="paramname">TArgs</td><td>argument types for Matrix::create method (not including the implied <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a> as the first argument)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vals</td><td>values used to initialize the vector </td></tr>
    <tr><td class="paramname">exec</td><td><a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a> associated to the vector </td></tr>
    <tr><td class="paramname">create_args</td><td>additional arguments passed to Matrix::create, not including the <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a>, which is passed as the first argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="anamespacegko_html_a1beb80750459e4201aa9d882d2d074c3"><div class="ttname"><a href="namespacegko.html#a1beb80750459e4201aa9d882d2d074c3">gko::clone</a></div><div class="ttdeci">detail::cloned_type&lt; Pointer &gt; clone(const Pointer &amp;p)</div><div class="ttdoc">Creates a unique clone of the object pointed to by p.</div><div class="ttdef"><b>Definition:</b> utils_helper.hpp:160</div></div>
<div class="ttc" id="anamespacegko_html_a73ce7e87aec389b5210630bb617b4baa"><div class="ttname"><a href="namespacegko.html#a73ce7e87aec389b5210630bb617b4baa">gko::as</a></div><div class="ttdeci">std::decay&lt; T &gt;::type * as(U *obj)</div><div class="ttdoc">Performs polymorphic type conversion.</div><div class="ttdef"><b>Definition:</b> utils_helper.hpp:292</div></div>
<div class="ttc" id="anamespacegko_html_a014ec51e675c425bb83908361f630450"><div class="ttname"><a href="namespacegko.html#a014ec51e675c425bb83908361f630450">gko::lend</a></div><div class="ttdeci">std::enable_if&lt; detail::have_ownership_s&lt; Pointer &gt;::value, detail::pointee&lt; Pointer &gt; * &gt;::type lend(const Pointer &amp;p)</div><div class="ttdoc">Returns a non-owning (plain) pointer to the object pointed to by p.</div><div class="ttdef"><b>Definition:</b> utils_helper.hpp:256</div></div>
<div class="ttc" id="anamespacegko_html_a0059e27f8f4bc348ff65c1e60caf47c8"><div class="ttname"><a href="namespacegko.html#a0059e27f8f4bc348ff65c1e60caf47c8">gko::one</a></div><div class="ttdeci">constexpr T one()</div><div class="ttdoc">Returns the multiplicative identity for T.</div><div class="ttdef"><b>Definition:</b> math.hpp:808</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
