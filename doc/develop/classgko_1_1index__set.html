<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Ginkgo: gko::index_set&lt; IndexType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_doc.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Ginkgo
   &#160;<span id="projectnumber">Generated from pipelines/976981192 branch based on develop. Ginkgo version 1.7.0</span>
   </div>
   <div id="projectbrief">A numerical linear algebra library targeting many-core architectures</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegko.html">gko</a></li><li class="navelem"><a class="el" href="classgko_1_1index__set.html">index_set</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classgko_1_1index__set-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">gko::index_set&lt; IndexType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An index set class represents an ordered set of intervals.  
 <a href="classgko_1_1index__set.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="index__set_8hpp_source.html">ginkgo/core/base/index_set.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a41f5311ce2e9fb07ddb618123413bab7"><td class="memItemLeft" align="right" valign="top"><a id="a41f5311ce2e9fb07ddb618123413bab7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1index__set.html#a41f5311ce2e9fb07ddb618123413bab7">index_type</a> = IndexType</td></tr>
<tr class="memdesc:a41f5311ce2e9fb07ddb618123413bab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of elements stored in the index set. <br /></td></tr>
<tr class="separator:a41f5311ce2e9fb07ddb618123413bab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6383409f771d79550aacaafc81a5f805"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1index__set.html#a6383409f771d79550aacaafc81a5f805">index_set</a> (std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt; exec) noexcept</td></tr>
<tr class="memdesc:a6383409f771d79550aacaafc81a5f805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty <a class="el" href="classgko_1_1index__set.html" title="An index set class represents an ordered set of intervals.">index_set</a> tied to the specified <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a>.  <a href="classgko_1_1index__set.html#a6383409f771d79550aacaafc81a5f805">More...</a><br /></td></tr>
<tr class="separator:a6383409f771d79550aacaafc81a5f805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07de100efebfe572fe54e8a062a804f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1index__set.html#aa07de100efebfe572fe54e8a062a804f">index_set</a> (std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">gko::Executor</a> &gt; exec, std::initializer_list&lt; IndexType &gt; init_list, const bool is_sorted=false)</td></tr>
<tr class="memdesc:aa07de100efebfe572fe54e8a062a804f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an index set on the specified executor from the initializer list.  <a href="classgko_1_1index__set.html#aa07de100efebfe572fe54e8a062a804f">More...</a><br /></td></tr>
<tr class="separator:aa07de100efebfe572fe54e8a062a804f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea38519c712e560b25b765649c42ea1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1index__set.html#acea38519c712e560b25b765649c42ea1">index_set</a> (std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">gko::Executor</a> &gt; exec, const <a class="el" href="classgko_1_1index__set.html#a41f5311ce2e9fb07ddb618123413bab7">index_type</a> size, const <a class="el" href="classgko_1_1array.html">gko::array</a>&lt; <a class="el" href="classgko_1_1index__set.html#a41f5311ce2e9fb07ddb618123413bab7">index_type</a> &gt; &amp;indices, const bool is_sorted=false)</td></tr>
<tr class="memdesc:acea38519c712e560b25b765649c42ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an index set on the specified executor and the given size.  <a href="classgko_1_1index__set.html#acea38519c712e560b25b765649c42ea1">More...</a><br /></td></tr>
<tr class="separator:acea38519c712e560b25b765649c42ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2f14574eed7c641b7bfffbba4f99aa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1index__set.html#aed2f14574eed7c641b7bfffbba4f99aa">index_set</a> (std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt; exec, const <a class="el" href="classgko_1_1index__set.html">index_set</a> &amp;other)</td></tr>
<tr class="memdesc:aed2f14574eed7c641b7bfffbba4f99aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a copy of the input <a class="el" href="classgko_1_1index__set.html" title="An index set class represents an ordered set of intervals.">index_set</a> on a different executor.  <a href="classgko_1_1index__set.html#aed2f14574eed7c641b7bfffbba4f99aa">More...</a><br /></td></tr>
<tr class="separator:aed2f14574eed7c641b7bfffbba4f99aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a091b7afcf15de1d01446251717e198e8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1index__set.html#a091b7afcf15de1d01446251717e198e8">index_set</a> (const <a class="el" href="classgko_1_1index__set.html">index_set</a> &amp;other)</td></tr>
<tr class="memdesc:a091b7afcf15de1d01446251717e198e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a copy of the input <a class="el" href="classgko_1_1index__set.html" title="An index set class represents an ordered set of intervals.">index_set</a>.  <a href="classgko_1_1index__set.html#a091b7afcf15de1d01446251717e198e8">More...</a><br /></td></tr>
<tr class="separator:a091b7afcf15de1d01446251717e198e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4ef83780066ef0dfa12d5f60ac5977"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1index__set.html#abd4ef83780066ef0dfa12d5f60ac5977">index_set</a> (std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt; exec, <a class="el" href="classgko_1_1index__set.html">index_set</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:abd4ef83780066ef0dfa12d5f60ac5977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the input <a class="el" href="classgko_1_1index__set.html" title="An index set class represents an ordered set of intervals.">index_set</a> to a different executor.  <a href="classgko_1_1index__set.html#abd4ef83780066ef0dfa12d5f60ac5977">More...</a><br /></td></tr>
<tr class="separator:abd4ef83780066ef0dfa12d5f60ac5977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a882cb2e0e9ba975255bda9e117643520"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1index__set.html#a882cb2e0e9ba975255bda9e117643520">index_set</a> (<a class="el" href="classgko_1_1index__set.html">index_set</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a882cb2e0e9ba975255bda9e117643520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the input <a class="el" href="classgko_1_1index__set.html" title="An index set class represents an ordered set of intervals.">index_set</a>.  <a href="classgko_1_1index__set.html#a882cb2e0e9ba975255bda9e117643520">More...</a><br /></td></tr>
<tr class="separator:a882cb2e0e9ba975255bda9e117643520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83f3b482c10affbf9d6fc170e6865e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgko_1_1index__set.html">index_set</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1index__set.html#ac83f3b482c10affbf9d6fc170e6865e7">operator=</a> (const <a class="el" href="classgko_1_1index__set.html">index_set</a> &amp;other)</td></tr>
<tr class="memdesc:ac83f3b482c10affbf9d6fc170e6865e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from another <a class="el" href="classgko_1_1index__set.html" title="An index set class represents an ordered set of intervals.">index_set</a>.  <a href="classgko_1_1index__set.html#ac83f3b482c10affbf9d6fc170e6865e7">More...</a><br /></td></tr>
<tr class="separator:ac83f3b482c10affbf9d6fc170e6865e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e7993dd1e51e6509267851222f5dea0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgko_1_1index__set.html">index_set</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1index__set.html#a1e7993dd1e51e6509267851222f5dea0">operator=</a> (<a class="el" href="classgko_1_1index__set.html">index_set</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a1e7993dd1e51e6509267851222f5dea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves data from another <a class="el" href="classgko_1_1index__set.html" title="An index set class represents an ordered set of intervals.">index_set</a>.  <a href="classgko_1_1index__set.html#a1e7993dd1e51e6509267851222f5dea0">More...</a><br /></td></tr>
<tr class="separator:a1e7993dd1e51e6509267851222f5dea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53df61fd93487ab81379091e3d985337"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1index__set.html#a53df61fd93487ab81379091e3d985337">clear</a> () noexcept</td></tr>
<tr class="memdesc:a53df61fd93487ab81379091e3d985337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates all data used by the <a class="el" href="classgko_1_1index__set.html" title="An index set class represents an ordered set of intervals.">index_set</a>.  <a href="classgko_1_1index__set.html#a53df61fd93487ab81379091e3d985337">More...</a><br /></td></tr>
<tr class="separator:a53df61fd93487ab81379091e3d985337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e5f6ba5faaf75fee8b5415584be9ad"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1index__set.html#a37e5f6ba5faaf75fee8b5415584be9ad">get_executor</a> () const</td></tr>
<tr class="memdesc:a37e5f6ba5faaf75fee8b5415584be9ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the executor of the <a class="el" href="classgko_1_1index__set.html" title="An index set class represents an ordered set of intervals.">index_set</a>.  <a href="classgko_1_1index__set.html#a37e5f6ba5faaf75fee8b5415584be9ad">More...</a><br /></td></tr>
<tr class="separator:a37e5f6ba5faaf75fee8b5415584be9ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee50346d39861298d22e886f849a05d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgko_1_1index__set.html#a41f5311ce2e9fb07ddb618123413bab7">index_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1index__set.html#aee50346d39861298d22e886f849a05d5">get_size</a> () const</td></tr>
<tr class="memdesc:aee50346d39861298d22e886f849a05d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the index set space.  <a href="classgko_1_1index__set.html#aee50346d39861298d22e886f849a05d5">More...</a><br /></td></tr>
<tr class="separator:aee50346d39861298d22e886f849a05d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4a1e96758b704d89ca101815110f7f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1index__set.html#acc4a1e96758b704d89ca101815110f7f">is_contiguous</a> () const</td></tr>
<tr class="memdesc:acc4a1e96758b704d89ca101815110f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the index set is contiguous.  <a href="classgko_1_1index__set.html#acc4a1e96758b704d89ca101815110f7f">More...</a><br /></td></tr>
<tr class="separator:acc4a1e96758b704d89ca101815110f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4c41ed2f1e634143a117fac6fcebb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgko_1_1index__set.html#a41f5311ce2e9fb07ddb618123413bab7">index_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1index__set.html#a2e4c41ed2f1e634143a117fac6fcebb6">get_num_elems</a> () const</td></tr>
<tr class="memdesc:a2e4c41ed2f1e634143a117fac6fcebb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the actual number of indices stored in the index set.  <a href="classgko_1_1index__set.html#a2e4c41ed2f1e634143a117fac6fcebb6">More...</a><br /></td></tr>
<tr class="separator:a2e4c41ed2f1e634143a117fac6fcebb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363bf8e031a2fe0be1b5bee3ede1f5a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgko_1_1index__set.html#a41f5311ce2e9fb07ddb618123413bab7">index_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1index__set.html#a363bf8e031a2fe0be1b5bee3ede1f5a0">get_global_index</a> (<a class="el" href="classgko_1_1index__set.html#a41f5311ce2e9fb07ddb618123413bab7">index_type</a> local_index) const</td></tr>
<tr class="memdesc:a363bf8e031a2fe0be1b5bee3ede1f5a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the global index given a local index.  <a href="classgko_1_1index__set.html#a363bf8e031a2fe0be1b5bee3ede1f5a0">More...</a><br /></td></tr>
<tr class="separator:a363bf8e031a2fe0be1b5bee3ede1f5a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b60c4666b52d0c17897f10462e99790"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgko_1_1index__set.html#a41f5311ce2e9fb07ddb618123413bab7">index_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1index__set.html#a6b60c4666b52d0c17897f10462e99790">get_local_index</a> (<a class="el" href="classgko_1_1index__set.html#a41f5311ce2e9fb07ddb618123413bab7">index_type</a> global_index) const</td></tr>
<tr class="memdesc:a6b60c4666b52d0c17897f10462e99790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the local index given a global index.  <a href="classgko_1_1index__set.html#a6b60c4666b52d0c17897f10462e99790">More...</a><br /></td></tr>
<tr class="separator:a6b60c4666b52d0c17897f10462e99790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db8f5398e9816d7080fc57c8aa34e27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgko_1_1array.html">array</a>&lt; <a class="el" href="classgko_1_1index__set.html#a41f5311ce2e9fb07ddb618123413bab7">index_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1index__set.html#a0db8f5398e9816d7080fc57c8aa34e27">map_local_to_global</a> (const <a class="el" href="classgko_1_1array.html">array</a>&lt; <a class="el" href="classgko_1_1index__set.html#a41f5311ce2e9fb07ddb618123413bab7">index_type</a> &gt; &amp;local_indices, const bool is_sorted=false) const</td></tr>
<tr class="memdesc:a0db8f5398e9816d7080fc57c8aa34e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an array version of the scalar function above.  <a href="classgko_1_1index__set.html#a0db8f5398e9816d7080fc57c8aa34e27">More...</a><br /></td></tr>
<tr class="separator:a0db8f5398e9816d7080fc57c8aa34e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace75723b328e2df7d3bd8004f539455a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgko_1_1array.html">array</a>&lt; <a class="el" href="classgko_1_1index__set.html#a41f5311ce2e9fb07ddb618123413bab7">index_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1index__set.html#ace75723b328e2df7d3bd8004f539455a">map_global_to_local</a> (const <a class="el" href="classgko_1_1array.html">array</a>&lt; <a class="el" href="classgko_1_1index__set.html#a41f5311ce2e9fb07ddb618123413bab7">index_type</a> &gt; &amp;global_indices, const bool is_sorted=false) const</td></tr>
<tr class="memdesc:ace75723b328e2df7d3bd8004f539455a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an array version of the scalar function above.  <a href="classgko_1_1index__set.html#ace75723b328e2df7d3bd8004f539455a">More...</a><br /></td></tr>
<tr class="separator:ace75723b328e2df7d3bd8004f539455a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7cabebd27f616df5e06a26072a48d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgko_1_1array.html">array</a>&lt; <a class="el" href="classgko_1_1index__set.html#a41f5311ce2e9fb07ddb618123413bab7">index_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1index__set.html#a5a7cabebd27f616df5e06a26072a48d0">to_global_indices</a> () const</td></tr>
<tr class="memdesc:a5a7cabebd27f616df5e06a26072a48d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allows the user obtain a decompressed global_indices array from the indices stored in the index set.  <a href="classgko_1_1index__set.html#a5a7cabebd27f616df5e06a26072a48d0">More...</a><br /></td></tr>
<tr class="separator:a5a7cabebd27f616df5e06a26072a48d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67edb4325ead08994449c67b40fcb401"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgko_1_1array.html">array</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1index__set.html#a67edb4325ead08994449c67b40fcb401">contains</a> (const <a class="el" href="classgko_1_1array.html">array</a>&lt; <a class="el" href="classgko_1_1index__set.html#a41f5311ce2e9fb07ddb618123413bab7">index_type</a> &gt; &amp;global_indices, const bool is_sorted=false) const</td></tr>
<tr class="memdesc:a67edb4325ead08994449c67b40fcb401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the individual global indeices exist in the index set.  <a href="classgko_1_1index__set.html#a67edb4325ead08994449c67b40fcb401">More...</a><br /></td></tr>
<tr class="separator:a67edb4325ead08994449c67b40fcb401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e92beeb23525dec8474c3342aca1c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1index__set.html#ac0e92beeb23525dec8474c3342aca1c1">contains</a> (const <a class="el" href="classgko_1_1index__set.html#a41f5311ce2e9fb07ddb618123413bab7">index_type</a> global_index) const</td></tr>
<tr class="memdesc:ac0e92beeb23525dec8474c3342aca1c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the global index exists in the index set.  <a href="classgko_1_1index__set.html#ac0e92beeb23525dec8474c3342aca1c1">More...</a><br /></td></tr>
<tr class="separator:ac0e92beeb23525dec8474c3342aca1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9dbcb5d70fa42c47a5c02abf46637af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgko_1_1index__set.html#a41f5311ce2e9fb07ddb618123413bab7">index_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1index__set.html#ab9dbcb5d70fa42c47a5c02abf46637af">get_num_subsets</a> () const</td></tr>
<tr class="memdesc:ab9dbcb5d70fa42c47a5c02abf46637af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of subsets stored in the index set.  <a href="classgko_1_1index__set.html#ab9dbcb5d70fa42c47a5c02abf46637af">More...</a><br /></td></tr>
<tr class="separator:ab9dbcb5d70fa42c47a5c02abf46637af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610e9270753ae956a2e2020850daee79"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classgko_1_1index__set.html#a41f5311ce2e9fb07ddb618123413bab7">index_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1index__set.html#a610e9270753ae956a2e2020850daee79">get_subsets_begin</a> () const</td></tr>
<tr class="memdesc:a610e9270753ae956a2e2020850daee79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the beginning indices of the subsets.  <a href="classgko_1_1index__set.html#a610e9270753ae956a2e2020850daee79">More...</a><br /></td></tr>
<tr class="separator:a610e9270753ae956a2e2020850daee79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7110b7360f7d88ae5d9b59391462bbca"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classgko_1_1index__set.html#a41f5311ce2e9fb07ddb618123413bab7">index_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1index__set.html#a7110b7360f7d88ae5d9b59391462bbca">get_subsets_end</a> () const</td></tr>
<tr class="memdesc:a7110b7360f7d88ae5d9b59391462bbca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the end indices of the subsets.  <a href="classgko_1_1index__set.html#a7110b7360f7d88ae5d9b59391462bbca">More...</a><br /></td></tr>
<tr class="separator:a7110b7360f7d88ae5d9b59391462bbca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e01b02e7ff87af6e606bf0a4634cb5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classgko_1_1index__set.html#a41f5311ce2e9fb07ddb618123413bab7">index_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1index__set.html#a55e01b02e7ff87af6e606bf0a4634cb5">get_superset_indices</a> () const</td></tr>
<tr class="memdesc:a55e01b02e7ff87af6e606bf0a4634cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the cumulative indices of the superset of the subsets.  <a href="classgko_1_1index__set.html#a55e01b02e7ff87af6e606bf0a4634cb5">More...</a><br /></td></tr>
<tr class="separator:a55e01b02e7ff87af6e606bf0a4634cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename IndexType = int32&gt;<br />
class gko::index_set&lt; IndexType &gt;</h3>

<p>An index set class represents an ordered set of intervals. </p>
<p>The index set contains subsets which store the starting and end points of a range, [a,b), storing the first index and one past the last index. As the index set only stores the end-points of ranges, it can be quite efficient in terms of storage.</p>
<p>This class is particularly useful in storing continuous ranges. For example, consider the index set (1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 18, 19, 20, 21, 42). Instead of storing the entire array of indices, one can store intervals ([1,9), [10,13), [18,22), [42,43)), thereby only using half the storage.</p>
<p>We store three arrays, one (subsets_begin) with the starting indices of the subsets in the index set, another (subsets_end) storing one index beyond the end indices of the subsets and the last (superset_cumulative_indices) storing the cumulative number of indices in the subsequent subsets with an initial zero which speeds up the querying. Additionally, the arrays conataining the range boundaries (subsets_begin, subsets_end) are stored in a sorted fashion.</p>
<p>Therefore the storage would look as follows</p>
<blockquote class="doxtable">
<p><a class="el" href="classgko_1_1index__set.html" title="An index set class represents an ordered set of intervals.">index_set</a> = (1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 18, 19, 20, 21, 42) subsets_begin = {1, 10, 18, 42} subsets_end = {9, 13, 22, 43} superset_cumulative_indices = {0, 8, 11, 15, 16} </p>
</blockquote>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">index_type</td><td>type of the indices being stored in the index set. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6383409f771d79550aacaafc81a5f805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6383409f771d79550aacaafc81a5f805">&#9670;&nbsp;</a></span>index_set() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType = int32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgko_1_1index__set.html">gko::index_set</a>&lt; IndexType &gt;::<a class="el" href="classgko_1_1index__set.html">index_set</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt;&#160;</td>
          <td class="paramname"><em>exec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an empty <a class="el" href="classgko_1_1index__set.html" title="An index set class represents an ordered set of intervals.">index_set</a> tied to the specified <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>the <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a> where the <a class="el" href="classgko_1_1index__set.html" title="An index set class represents an ordered set of intervals.">index_set</a> data is allocated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa07de100efebfe572fe54e8a062a804f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa07de100efebfe572fe54e8a062a804f">&#9670;&nbsp;</a></span>index_set() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType = int32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgko_1_1index__set.html">gko::index_set</a>&lt; IndexType &gt;::<a class="el" href="classgko_1_1index__set.html">index_set</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">gko::Executor</a> &gt;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; IndexType &gt;&#160;</td>
          <td class="paramname"><em>init_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_sorted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an index set on the specified executor from the initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>the <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a> where the index set data will be allocated </td></tr>
    <tr><td class="paramname">init_list</td><td>the indices that the index set should hold in an initializer_list. </td></tr>
    <tr><td class="paramname">is_sorted</td><td>a parameter that specifies if the indices array is sorted or not. <code>true</code> if sorted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acea38519c712e560b25b765649c42ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea38519c712e560b25b765649c42ea1">&#9670;&nbsp;</a></span>index_set() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType = int32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgko_1_1index__set.html">gko::index_set</a>&lt; IndexType &gt;::<a class="el" href="classgko_1_1index__set.html">index_set</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">gko::Executor</a> &gt;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgko_1_1index__set.html#a41f5311ce2e9fb07ddb618123413bab7">index_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgko_1_1array.html">gko::array</a>&lt; <a class="el" href="classgko_1_1index__set.html#a41f5311ce2e9fb07ddb618123413bab7">index_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_sorted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an index set on the specified executor and the given size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>the <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a> where the index set data will be allocated </td></tr>
    <tr><td class="paramname">size</td><td>the maximum index the index set it allowed to hold. This is the size of the index space. </td></tr>
    <tr><td class="paramname">indices</td><td>the indices that the index set should hold. </td></tr>
    <tr><td class="paramname">is_sorted</td><td>a parameter that specifies if the indices array is sorted or not. <code>true</code> if sorted. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classgko_1_1array.html#a9c6a40a8a007af8c6e541fbc030d6291">gko::array&lt; ValueType &gt;::get_num_elems()</a>.</p>

</div>
</div>
<a id="aed2f14574eed7c641b7bfffbba4f99aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed2f14574eed7c641b7bfffbba4f99aa">&#9670;&nbsp;</a></span>index_set() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType = int32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgko_1_1index__set.html">gko::index_set</a>&lt; IndexType &gt;::<a class="el" href="classgko_1_1index__set.html">index_set</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgko_1_1index__set.html">index_set</a>&lt; IndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a copy of the input <a class="el" href="classgko_1_1index__set.html" title="An index set class represents an ordered set of intervals.">index_set</a> on a different executor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>the executor where the new <a class="el" href="classgko_1_1index__set.html" title="An index set class represents an ordered set of intervals.">index_set</a> will be created </td></tr>
    <tr><td class="paramname">other</td><td>the <a class="el" href="classgko_1_1index__set.html" title="An index set class represents an ordered set of intervals.">index_set</a> to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a091b7afcf15de1d01446251717e198e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a091b7afcf15de1d01446251717e198e8">&#9670;&nbsp;</a></span>index_set() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType = int32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgko_1_1index__set.html">gko::index_set</a>&lt; IndexType &gt;::<a class="el" href="classgko_1_1index__set.html">index_set</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgko_1_1index__set.html">index_set</a>&lt; IndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a copy of the input <a class="el" href="classgko_1_1index__set.html" title="An index set class represents an ordered set of intervals.">index_set</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the <a class="el" href="classgko_1_1index__set.html" title="An index set class represents an ordered set of intervals.">index_set</a> to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd4ef83780066ef0dfa12d5f60ac5977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4ef83780066ef0dfa12d5f60ac5977">&#9670;&nbsp;</a></span>index_set() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType = int32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgko_1_1index__set.html">gko::index_set</a>&lt; IndexType &gt;::<a class="el" href="classgko_1_1index__set.html">index_set</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgko_1_1index__set.html">index_set</a>&lt; IndexType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the input <a class="el" href="classgko_1_1index__set.html" title="An index set class represents an ordered set of intervals.">index_set</a> to a different executor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>the executor where the new <a class="el" href="classgko_1_1index__set.html" title="An index set class represents an ordered set of intervals.">index_set</a> will be moved to </td></tr>
    <tr><td class="paramname">other</td><td>the <a class="el" href="classgko_1_1index__set.html" title="An index set class represents an ordered set of intervals.">index_set</a> to move from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a882cb2e0e9ba975255bda9e117643520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a882cb2e0e9ba975255bda9e117643520">&#9670;&nbsp;</a></span>index_set() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType = int32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgko_1_1index__set.html">gko::index_set</a>&lt; IndexType &gt;::<a class="el" href="classgko_1_1index__set.html">index_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgko_1_1index__set.html">index_set</a>&lt; IndexType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the input <a class="el" href="classgko_1_1index__set.html" title="An index set class represents an ordered set of intervals.">index_set</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the <a class="el" href="classgko_1_1index__set.html" title="An index set class represents an ordered set of intervals.">index_set</a> to move from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a53df61fd93487ab81379091e3d985337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53df61fd93487ab81379091e3d985337">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType = int32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgko_1_1index__set.html">gko::index_set</a>&lt; IndexType &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocates all data used by the <a class="el" href="classgko_1_1index__set.html" title="An index set class represents an ordered set of intervals.">index_set</a>. </p>
<p>The <a class="el" href="classgko_1_1index__set.html" title="An index set class represents an ordered set of intervals.">index_set</a> is left in a valid, but empty state, so the same <a class="el" href="classgko_1_1index__set.html" title="An index set class represents an ordered set of intervals.">index_set</a> can be used to allocate new memory. Calls to <a class="el" href="classgko_1_1index__set.html#a610e9270753ae956a2e2020850daee79" title="Returns a pointer to the beginning indices of the subsets.">index_set::get_subsets_begin()</a> will return a <code>nullptr</code>. </p>

<p class="reference">References <a class="el" href="classgko_1_1array.html#a38fcf9307191a64064580fba0e32ef68">gko::array&lt; ValueType &gt;::clear()</a>.</p>

</div>
</div>
<a id="a67edb4325ead08994449c67b40fcb401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67edb4325ead08994449c67b40fcb401">&#9670;&nbsp;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType = int32&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgko_1_1array.html">array</a>&lt;bool&gt; <a class="el" href="classgko_1_1index__set.html">gko::index_set</a>&lt; IndexType &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgko_1_1array.html">array</a>&lt; <a class="el" href="classgko_1_1index__set.html#a41f5311ce2e9fb07ddb618123413bab7">index_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_sorted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the individual global indeices exist in the index set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_indices</td><td>the indices to check. </td></tr>
    <tr><td class="paramname">is_sorted</td><td>a parameter that specifies if the query array is sorted or not. <code>true</code> if sorted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the array that contains element wise whether the corresponding global index in the index set or not. </dd></dl>

</div>
</div>
<a id="ac0e92beeb23525dec8474c3342aca1c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e92beeb23525dec8474c3342aca1c1">&#9670;&nbsp;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType = int32&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgko_1_1index__set.html">gko::index_set</a>&lt; IndexType &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgko_1_1index__set.html#a41f5311ce2e9fb07ddb618123413bab7">index_type</a>&#160;</td>
          <td class="paramname"><em>global_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the global index exists in the index set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_index</td><td>the index to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the element exists in the index set.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This single entry query can have significant kernel launch overheads and should be avoided if possible. </dd></dl>

</div>
</div>
<a id="a37e5f6ba5faaf75fee8b5415584be9ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37e5f6ba5faaf75fee8b5415584be9ad">&#9670;&nbsp;</a></span>get_executor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType = int32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classgko_1_1Executor.html">Executor</a>&gt; <a class="el" href="classgko_1_1index__set.html">gko::index_set</a>&lt; IndexType &gt;::get_executor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the executor of the <a class="el" href="classgko_1_1index__set.html" title="An index set class represents an ordered set of intervals.">index_set</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the executor. </dd></dl>

</div>
</div>
<a id="a363bf8e031a2fe0be1b5bee3ede1f5a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a363bf8e031a2fe0be1b5bee3ede1f5a0">&#9670;&nbsp;</a></span>get_global_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType = int32&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgko_1_1index__set.html#a41f5311ce2e9fb07ddb618123413bab7">index_type</a> <a class="el" href="classgko_1_1index__set.html">gko::index_set</a>&lt; IndexType &gt;::get_global_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgko_1_1index__set.html#a41f5311ce2e9fb07ddb618123413bab7">index_type</a>&#160;</td>
          <td class="paramname"><em>local_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the global index given a local index. </p>
<p>Consider the set idx_set = (0, 1, 2, 4, 6, 7, 8, 9). This function returns the element at the global index k stored in the index set. For example, <code>idx_set.get_global_index(0) == 0</code> <code>idx_set.get_global_index(3) == 4</code> and <code>idx_set.get_global_index(7) == 9</code></p>
<dl class="section note"><dt>Note</dt><dd>This function returns a scalar value and needs a scalar value. For repeated queries, it is more efficient to use the array functions that take and return arrays which allow for more throughput.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">local_index</td><td>the local index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the global index from the index set.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This single entry query can have significant kernel launch overheads and should be avoided if possible. </dd></dl>

</div>
</div>
<a id="a6b60c4666b52d0c17897f10462e99790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b60c4666b52d0c17897f10462e99790">&#9670;&nbsp;</a></span>get_local_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType = int32&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgko_1_1index__set.html#a41f5311ce2e9fb07ddb618123413bab7">index_type</a> <a class="el" href="classgko_1_1index__set.html">gko::index_set</a>&lt; IndexType &gt;::get_local_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgko_1_1index__set.html#a41f5311ce2e9fb07ddb618123413bab7">index_type</a>&#160;</td>
          <td class="paramname"><em>global_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the local index given a global index. </p>
<p>Consider the set idx_set = (0, 1, 2, 4, 6, 7, 8, 9). This function returns the local index in the index set of the provided index set. For example, <code>idx_set.get_local_index(0) == 0</code> <code>idx_set.get_local_index(4) == 3</code> and <code>idx_set.get_local_index(6) == 4</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This function returns a scalar value and needs a scalar value. For repeated queries, it is more efficient to use the array functions that take and return arrays which allow for more throughput.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_index</td><td>the global index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the local index of the element in the index set.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This single entry query can have significant kernel launch overheads and should be avoided if possible. </dd></dl>

</div>
</div>
<a id="a2e4c41ed2f1e634143a117fac6fcebb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e4c41ed2f1e634143a117fac6fcebb6">&#9670;&nbsp;</a></span>get_num_elems()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType = int32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgko_1_1index__set.html#a41f5311ce2e9fb07ddb618123413bab7">index_type</a> <a class="el" href="classgko_1_1index__set.html">gko::index_set</a>&lt; IndexType &gt;::get_num_elems </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the actual number of indices stored in the index set. </p>
<dl class="section return"><dt>Returns</dt><dd>number of indices stored in the index set </dd></dl>

</div>
</div>
<a id="ab9dbcb5d70fa42c47a5c02abf46637af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9dbcb5d70fa42c47a5c02abf46637af">&#9670;&nbsp;</a></span>get_num_subsets()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType = int32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgko_1_1index__set.html#a41f5311ce2e9fb07ddb618123413bab7">index_type</a> <a class="el" href="classgko_1_1index__set.html">gko::index_set</a>&lt; IndexType &gt;::get_num_subsets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of subsets stored in the index set. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of stored subsets. </dd></dl>

<p class="reference">References <a class="el" href="classgko_1_1array.html#a9c6a40a8a007af8c6e541fbc030d6291">gko::array&lt; ValueType &gt;::get_num_elems()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classgko_1_1index__set.html#acc4a1e96758b704d89ca101815110f7f">gko::index_set&lt; IndexType &gt;::is_contiguous()</a>.</p>

</div>
</div>
<a id="aee50346d39861298d22e886f849a05d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee50346d39861298d22e886f849a05d5">&#9670;&nbsp;</a></span>get_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType = int32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgko_1_1index__set.html#a41f5311ce2e9fb07ddb618123413bab7">index_type</a> <a class="el" href="classgko_1_1index__set.html">gko::index_set</a>&lt; IndexType &gt;::get_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the index set space. </p>
<dl class="section return"><dt>Returns</dt><dd>the size of the index set space. </dd></dl>

</div>
</div>
<a id="a610e9270753ae956a2e2020850daee79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a610e9270753ae956a2e2020850daee79">&#9670;&nbsp;</a></span>get_subsets_begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType = int32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classgko_1_1index__set.html#a41f5311ce2e9fb07ddb618123413bab7">index_type</a>* <a class="el" href="classgko_1_1index__set.html">gko::index_set</a>&lt; IndexType &gt;::get_subsets_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the beginning indices of the subsets. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the beginning indices of the subsets. </dd></dl>

<p class="reference">References <a class="el" href="classgko_1_1array.html#a4bbd9f9a19077bd7cfff8659992e430e">gko::array&lt; ValueType &gt;::get_const_data()</a>.</p>

</div>
</div>
<a id="a7110b7360f7d88ae5d9b59391462bbca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7110b7360f7d88ae5d9b59391462bbca">&#9670;&nbsp;</a></span>get_subsets_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType = int32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classgko_1_1index__set.html#a41f5311ce2e9fb07ddb618123413bab7">index_type</a>* <a class="el" href="classgko_1_1index__set.html">gko::index_set</a>&lt; IndexType &gt;::get_subsets_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the end indices of the subsets. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the end indices of the subsets. </dd></dl>

<p class="reference">References <a class="el" href="classgko_1_1array.html#a4bbd9f9a19077bd7cfff8659992e430e">gko::array&lt; ValueType &gt;::get_const_data()</a>.</p>

</div>
</div>
<a id="a55e01b02e7ff87af6e606bf0a4634cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55e01b02e7ff87af6e606bf0a4634cb5">&#9670;&nbsp;</a></span>get_superset_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType = int32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classgko_1_1index__set.html#a41f5311ce2e9fb07ddb618123413bab7">index_type</a>* <a class="el" href="classgko_1_1index__set.html">gko::index_set</a>&lt; IndexType &gt;::get_superset_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the cumulative indices of the superset of the subsets. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the cumulative indices of the superset of the subsets. </dd></dl>

<p class="reference">References <a class="el" href="classgko_1_1array.html#a4bbd9f9a19077bd7cfff8659992e430e">gko::array&lt; ValueType &gt;::get_const_data()</a>.</p>

</div>
</div>
<a id="acc4a1e96758b704d89ca101815110f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc4a1e96758b704d89ca101815110f7f">&#9670;&nbsp;</a></span>is_contiguous()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType = int32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgko_1_1index__set.html">gko::index_set</a>&lt; IndexType &gt;::is_contiguous </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the index set is contiguous. </p>
<dl class="section return"><dt>Returns</dt><dd>if the index set is contiguous. </dd></dl>

<p class="reference">References <a class="el" href="classgko_1_1index__set.html#ab9dbcb5d70fa42c47a5c02abf46637af">gko::index_set&lt; IndexType &gt;::get_num_subsets()</a>.</p>

</div>
</div>
<a id="ace75723b328e2df7d3bd8004f539455a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace75723b328e2df7d3bd8004f539455a">&#9670;&nbsp;</a></span>map_global_to_local()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType = int32&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgko_1_1array.html">array</a>&lt;<a class="el" href="classgko_1_1index__set.html#a41f5311ce2e9fb07ddb618123413bab7">index_type</a>&gt; <a class="el" href="classgko_1_1index__set.html">gko::index_set</a>&lt; IndexType &gt;::map_global_to_local </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgko_1_1array.html">array</a>&lt; <a class="el" href="classgko_1_1index__set.html#a41f5311ce2e9fb07ddb618123413bab7">index_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_sorted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an array version of the scalar function above. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_indices</td><td>the global index array. </td></tr>
    <tr><td class="paramname">is_sorted</td><td>a parameter that specifies if the query array is sorted or not. <code>true</code> if sorted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the local index array from the index set.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Whenever possible, passing a sorted array is preferred as the queries can be significantly faster. </dd></dl>

</div>
</div>
<a id="a0db8f5398e9816d7080fc57c8aa34e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0db8f5398e9816d7080fc57c8aa34e27">&#9670;&nbsp;</a></span>map_local_to_global()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType = int32&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgko_1_1array.html">array</a>&lt;<a class="el" href="classgko_1_1index__set.html#a41f5311ce2e9fb07ddb618123413bab7">index_type</a>&gt; <a class="el" href="classgko_1_1index__set.html">gko::index_set</a>&lt; IndexType &gt;::map_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgko_1_1array.html">array</a>&lt; <a class="el" href="classgko_1_1index__set.html#a41f5311ce2e9fb07ddb618123413bab7">index_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_sorted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an array version of the scalar function above. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">local_indices</td><td>the local index array. </td></tr>
    <tr><td class="paramname">is_sorted</td><td>a parameter that specifies if the query array is sorted or not. <code>true</code> if sorted .</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the global index array from the index set.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Whenever possible, passing a sorted array is preferred as the queries can be significantly faster. </dd>
<dd>
Passing local indices from [0, size) is equivalent to using the @to_global_indices function. </dd></dl>

</div>
</div>
<a id="ac83f3b482c10affbf9d6fc170e6865e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac83f3b482c10affbf9d6fc170e6865e7">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType = int32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgko_1_1index__set.html">index_set</a>&amp; <a class="el" href="classgko_1_1index__set.html">gko::index_set</a>&lt; IndexType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgko_1_1index__set.html">index_set</a>&lt; IndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from another <a class="el" href="classgko_1_1index__set.html" title="An index set class represents an ordered set of intervals.">index_set</a>. </p>
<p>The executor of this is preserved. In case this does not have an assigned executor, it will inherit the executor of other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the <a class="el" href="classgko_1_1index__set.html" title="An index set class represents an ordered set of intervals.">index_set</a> to copy from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this </dd></dl>

</div>
</div>
<a id="a1e7993dd1e51e6509267851222f5dea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e7993dd1e51e6509267851222f5dea0">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType = int32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgko_1_1index__set.html">index_set</a>&amp; <a class="el" href="classgko_1_1index__set.html">gko::index_set</a>&lt; IndexType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgko_1_1index__set.html">index_set</a>&lt; IndexType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves data from another <a class="el" href="classgko_1_1index__set.html" title="An index set class represents an ordered set of intervals.">index_set</a>. </p>
<p>The executor of this is preserved. In case this does not have an assigned executor, it will inherit the executor of other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the <a class="el" href="classgko_1_1index__set.html" title="An index set class represents an ordered set of intervals.">index_set</a> to move from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this </dd></dl>

</div>
</div>
<a id="a5a7cabebd27f616df5e06a26072a48d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a7cabebd27f616df5e06a26072a48d0">&#9670;&nbsp;</a></span>to_global_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType = int32&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgko_1_1array.html">array</a>&lt;<a class="el" href="classgko_1_1index__set.html#a41f5311ce2e9fb07ddb618123413bab7">index_type</a>&gt; <a class="el" href="classgko_1_1index__set.html">gko::index_set</a>&lt; IndexType &gt;::to_global_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function allows the user obtain a decompressed global_indices array from the indices stored in the index set. </p>
<dl class="section return"><dt>Returns</dt><dd>the decompressed set of indices. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ginkgo/core/base/<a class="el" href="index__set_8hpp_source.html">index_set.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
