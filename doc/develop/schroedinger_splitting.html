<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Ginkgo: The schroedinger-splitting program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_doc.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Ginkgo
   &#160;<span id="projectnumber">Generated from pipelines/1176906561 branch based on develop. Ginkgo version 1.8.0</span>
   </div>
   <div id="projectbrief">A numerical linear algebra library targeting many-core architectures</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">The schroedinger-splitting program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The Schroedinger equation example..</p>
<p>This example depends on heat-equation.</p>
<p> 
<table class="example" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Abouttheexample"> About the example </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Commentsaboutprogramminganddebugging"> Comments about programming and debugging </a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>This example shows how to use the FFT and iFFT implementations in Ginkgo to solve the non-linear Schrödinger equation with a splitting method.</p>
<p>The non-linear Schrödinger equation (NLS) is given by</p>
<p><img class="formulaInl" alt="$ i \partial_t \theta = -\delta \theta + |\theta|^2 \theta $" src="form_118.png"/></p>
<p>Here <img class="formulaInl" alt="$\theta$" src="form_119.png"/> is the wave function of a single particle in two dimensions. Its magnitude <img class="formulaInl" alt="$|\theta|^2$" src="form_120.png"/> describes the probability distribution of the particle's position.</p>
<p>This equation can be split in to its linear (1) and non-linear (2) part</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} (1) \quad i \partial_t \theta &amp;= -\delta \theta\\ (2) \quad i \partial_t \theta &amp;= |\theta|^2 \theta \end{align*}" src="form_121.png"/>
</p>
<p>For both of these equations, we can compute exact solutions, assuming periodic boundary conditions and using the Fourier series expansion for (1) and using the fact that <img class="formulaInl" alt="$| \theta |^2$" src="form_122.png"/> is constant in (2):</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} (\hat 1) \quad \quad \partial_t \hat\theta_k &amp;= -i |k|^2 \theta \\ (2') \quad \partial_t |\theta|^2 &amp;= i |\theta|^2 (\theta - \theta) = 0 \end{align*}" src="form_123.png"/>
</p>
<p>The exact solutions are then given by</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} (\hat 1) \quad \hat\theta(t) &amp;= e^{-i |k|^2 t} \hat\theta(0)\\ (2') \quad \theta(t) &amp;= e^{-i |\theta|^2 t} \theta(0) \end{align*}" src="form_124.png"/>
</p>
<p>These partial solutions can be used to approximate a solution to the full NLS by alternating between small time steps for (1) and (2).</p>
<p>For nicer visual results, we add another constant potential term V(x) \theta to the non-linear part, which turns it into the Gross–Pitaevskii equation.</p>
<p><a class="anchor" id="Abouttheexample"></a></p><h3>About the example </h3>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<div class="fragment"><div class="line">\f}</div>
<div class="line"> </div>
<div class="line">The exact solutions are then given by</div>
<div class="line"> </div>
<div class="line">\f{align*}{</div>
<div class="line">    (\hat 1) \quad \hat\theta(t) &amp;= e^{-i |k|^2 t} \hat\theta(0)\\</div>
<div class="line">    (2<span class="stringliteral">&#39;) \quad \theta(t) &amp;= e^{-i |\theta|^2 t} \theta(0)</span></div>
<div class="line"><span class="stringliteral">\f}</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">These partial solutions can be used to approximate a solution to the full NLS</span></div>
<div class="line"><span class="stringliteral">by alternating between small time steps for (1) and (2).</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">For nicer visual results, we add another constant potential term V(x) \theta</span></div>
<div class="line"><span class="stringliteral">to the non-linear part, which turns it into the Gross–Pitaevskii equation.</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">*****************************&lt;DESCRIPTION&gt;********************************** /</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">#include &lt;ginkgo/ginkgo.hpp&gt;</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">#include &lt;algorithm&gt;</span></div>
<div class="line"><span class="stringliteral">#include &lt;chrono&gt;</span></div>
<div class="line"><span class="stringliteral">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="stringliteral">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="stringliteral">#include &lt;utility&gt;</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">#include &lt;opencv2/core.hpp&gt;</span></div>
<div class="line"><span class="stringliteral">#include &lt;opencv2/videoio.hpp&gt;</span></div>
</div><!-- fragment --><p>This function implements a simple Ginkgo-themed clamped color mapping for values in the range [0,5].</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> set_val(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* data, <span class="keywordtype">double</span> value)</div>
<div class="line">{</div>
</div><!-- fragment --><p>RGB values for the 6 colors used for values 0, 1, ..., 5 We will interpolate linearly between these values.</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> col_r[] = {255, 221, 129, 201, 249, 255};</div>
<div class="line"><span class="keywordtype">double</span> col_g[] = {255, 220, 130, 161, 158, 204};</div>
<div class="line"><span class="keywordtype">double</span> col_b[] = {255, 220, 133, 93, 24, 8};</div>
<div class="line">value = std::max(0.0, value);</div>
<div class="line"><span class="keyword">auto</span> i = std::max(0, std::min(4, <span class="keywordtype">int</span>(value)));</div>
<div class="line"><span class="keyword">auto</span> d = std::max(0.0, std::min(1.0, value - i));</div>
</div><!-- fragment --><p>OpenCV uses BGR instead of RGB by default, revert indices</p>
<div class="fragment"><div class="line">    data[2] = static_cast&lt;unsigned char&gt;(col_r[i + 1] * d + col_r[i] * (1 - d));</div>
<div class="line">    data[1] = static_cast&lt;unsigned char&gt;(col_g[i + 1] * d + col_g[i] * (1 - d));</div>
<div class="line">    data[0] = static_cast&lt;unsigned char&gt;(col_b[i + 1] * d + col_b[i] * (1 - d));</div>
<div class="line">}</div>
</div><!-- fragment --><p>Initialize video output with given dimension and FPS (frames per seconds)</p>
<div class="fragment"><div class="line">std::pair&lt;cv::VideoWriter, cv::Mat&gt; build_output(<span class="keywordtype">int</span> n, <span class="keywordtype">double</span> fps)</div>
<div class="line">{</div>
<div class="line">    cv::Size videosize{n, n};</div>
<div class="line">    <span class="keyword">auto</span> output =</div>
<div class="line">        std::make_pair(cv::VideoWriter{}, cv::Mat{videosize, CV_8UC3});</div>
<div class="line">    <span class="keyword">auto</span> fourcc = cv::VideoWriter::fourcc(<span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;v&#39;</span>, <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;1&#39;</span>);</div>
<div class="line">    output.first.open(<span class="stringliteral">&quot;nls.mp4&quot;</span>, fourcc, fps, videosize);</div>
<div class="line">    <span class="keywordflow">return</span> output;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Write the current frame to video output using the above color mapping</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> output_timestep(std::pair&lt;cv::VideoWriter, cv::Mat&gt;&amp; output, <span class="keywordtype">int</span> n,</div>
<div class="line">                     <span class="keyword">const</span> std::complex&lt;double&gt;* data)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++) {</div>
<div class="line">        <span class="keyword">auto</span> row = output.second.ptr(i);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; n; j++) {</div>
<div class="line">            set_val(&amp;row[3 * j], <a class="code" href="namespacegko.html#adeb470aaf293d7c5548392b2f451e8e4">abs</a>(data[i * n + j]));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    output.first.write(output.second);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> vec = <a class="code" href="classgko_1_1matrix_1_1Dense.html">gko::matrix::Dense&lt;std::complex&lt;double&gt;</a>&gt;;</div>
<div class="line">    <span class="keyword">using</span> real_vec = <a class="code" href="classgko_1_1matrix_1_1Dense.html">gko::matrix::Dense&lt;double&gt;</a>;</div>
<div class="line">    <span class="keyword">using</span> fft2 = <a class="code" href="classgko_1_1matrix_1_1Fft2.html">gko::matrix::Fft2</a>;</div>
</div><!-- fragment --><p>Problem parameters: simulation length</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> t0 = 15.0;</div>
</div><!-- fragment --><p>scaling factor for non-linearity</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> nonlinear_scale = 1.0;</div>
</div><!-- fragment --><p>scaling factor for potential</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> potential_scale = 3.0;</div>
</div><!-- fragment --><p>Simulation parameters: time scaling factor</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> time_scale = 0.25;</div>
</div><!-- fragment --><p>number of grid points in each dimension</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> n = 256;</div>
</div><!-- fragment --><p>number of simulation steps per second</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> steps_per_sec = 1000;</div>
</div><!-- fragment --><p>number of video frames per second</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> fps = 25;</div>
</div><!-- fragment --><p>number of grid points</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> n2 = n * n;</div>
</div><!-- fragment --><p>phase difference between neighboring grid points</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> h = 2.0 * gko::pi&lt;double&gt;() / n;</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> h2 = h * h;</div>
</div><!-- fragment --><p>time step size for the simulation</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> tau = 1.0 / steps_per_sec;</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> idx = [&amp;](<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j) { <span class="keywordflow">return</span> i * n + j; };</div>
</div><!-- fragment --><p>create an OpenMP executor</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> exec = <a class="code" href="classgko_1_1OmpExecutor.html#a8930142a1913bcbcac4fb6c917f930d9">gko::OmpExecutor::create</a>();</div>
</div><!-- fragment --><p>load initial state vector</p>
<div class="fragment"><div class="line">std::ifstream initial_stream(<span class="stringliteral">&quot;data/gko_logo_2d.mtx&quot;</span>);</div>
<div class="line">std::ifstream potential_stream(<span class="stringliteral">&quot;data/gko_text_2d.mtx&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> amplitude = gko::read&lt;vec&gt;(initial_stream, exec);</div>
<div class="line"><span class="keyword">auto</span> potential = gko::read&lt;real_vec&gt;(potential_stream, exec);</div>
</div><!-- fragment --><p>create vector for frequency space representation</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> frequency = vec::create(exec, amplitude-&gt;get_size());</div>
</div><!-- fragment --><p>create Fourier matrix</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> fft = fft2::create(exec, n, n);</div>
<div class="line"><span class="keyword">auto</span> ifft = fft-&gt;conj_transpose();</div>
</div><!-- fragment --><p>prepare video output</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> output = build_output(n, fps);</div>
</div><!-- fragment --><p>time stamp of the last output frame (sentinel value)</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> last_t = -t0;</div>
</div><!-- fragment --><p>execute splitting method: time step in linear part, then non-linear part</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">double</span> t = 0; t &lt; t0; t += tau) {</div>
</div><!-- fragment --><p>if enough time has passed, output the next frame</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (t - last_t &gt; 1.0 / fps) {</div>
<div class="line">    last_t = t;</div>
<div class="line">    std::cout &lt;&lt; t &lt;&lt; std::endl;</div>
<div class="line">    output_timestep(output, n, amplitude-&gt;get_const_values());</div>
<div class="line">}</div>
</div><!-- fragment --><p>time step in linear part</p>
<div class="fragment"><div class="line">fft-&gt;apply(amplitude, frequency);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; n; j++) {</div>
<div class="line">        frequency-&gt;at(idx(i, j)) *=</div>
<div class="line">            std::polar(1.0, -h2 * (i * i + j * j) * tau * time_scale);</div>
</div><!-- fragment --><p>scale by FFT*iFFT normalization factor</p>
<div class="fragment"><div class="line">        frequency-&gt;at(idx(i, j)) *= 1.0 / n2;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line">ifft-&gt;apply(frequency, amplitude);</div>
</div><!-- fragment --><p>time step in non-linear part</p>
<div class="fragment"><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; n; j++) {</div>
<div class="line">                amplitude-&gt;at(idx(i, j)) *= std::polar(</div>
<div class="line">                    1.0, -(nonlinear_scale *</div>
<div class="line">                               <a class="code" href="namespacegko.html#abbb55709b10d707b2cbef803832aa834">gko::squared_norm</a>(amplitude-&gt;at(idx(i, j))) +</div>
<div class="line">                           potential_scale * potential-&gt;at(idx(i, j))) *</div>
<div class="line">                             tau * time_scale);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The program will generate a video file named nls.mp4 and output the timestamp of each generated frame.</p>
<p><a class="anchor" id="Commentsaboutprogramminganddebugging"></a></p><h3>Comments about programming and debugging </h3>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="comment">/*****************************&lt;DESCRIPTION&gt;***********************************</span></div>
<div class="line"><span class="comment">This example shows how to use the FFT and iFFT implementations in Ginkgo</span></div>
<div class="line"><span class="comment">to solve the non-linear Schrödinger equation with a splitting method.</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">The non-linear Schrödinger equation (NLS) is given by</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">@f$</span></div>
<div class="line"><span class="comment">    i \partial_t \theta = -\delta \theta + |\theta|^2 \theta</span></div>
<div class="line"><span class="comment">@f$</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">Here @f$\theta@f$ is the wave function of a single particle in two dimensions.</span></div>
<div class="line"><span class="comment">Its magnitude @f$|\theta|^2@f$ describes the probability distribution of the</span></div>
<div class="line"><span class="comment">particle&#39;s position.</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">This equation can be split in to its linear (1) and non-linear (2) part</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">\f{align*}{</span></div>
<div class="line"><span class="comment">    (1) \quad i \partial_t \theta &amp;= -\delta \theta\\</span></div>
<div class="line"><span class="comment">    (2) \quad i \partial_t \theta &amp;= |\theta|^2 \theta</span></div>
<div class="line"><span class="comment">\f}</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">For both of these equations, we can compute exact solutions, assuming periodic</span></div>
<div class="line"><span class="comment">boundary conditions and using the Fourier series expansion for (1) and using the</span></div>
<div class="line"><span class="comment">fact that @f$| \theta |^2@f$ is constant in (2):</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">\f{align*}{</span></div>
<div class="line"><span class="comment">    (\hat 1) \quad \quad \partial_t \hat\theta_k &amp;= -i |k|^2 \theta \\</span></div>
<div class="line"><span class="comment">    (2&#39;) \quad \partial_t |\theta|^2 &amp;= i |\theta|^2 (\theta - \theta) = 0</span></div>
<div class="line"><span class="comment">\f}</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">The exact solutions are then given by</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">\f{align*}{</span></div>
<div class="line"><span class="comment">    (\hat 1) \quad \hat\theta(t) &amp;= e^{-i |k|^2 t} \hat\theta(0)\\</span></div>
<div class="line"><span class="comment">    (2&#39;) \quad \theta(t) &amp;= e^{-i |\theta|^2 t} \theta(0)</span></div>
<div class="line"><span class="comment">\f}</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">These partial solutions can be used to approximate a solution to the full NLS</span></div>
<div class="line"><span class="comment">by alternating between small time steps for (1) and (2).</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">For nicer visual results, we add another constant potential term V(x) \theta</span></div>
<div class="line"><span class="comment">to the non-linear part, which turns it into the Gross–Pitaevskii equation.</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">*****************************&lt;DESCRIPTION&gt;**********************************/</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;ginkgo/ginkgo.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;opencv2/core.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;opencv2/videoio.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> set_val(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* data, <span class="keywordtype">double</span> value)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">double</span> col_r[] = {255, 221, 129, 201, 249, 255};</div>
<div class="line">    <span class="keywordtype">double</span> col_g[] = {255, 220, 130, 161, 158, 204};</div>
<div class="line">    <span class="keywordtype">double</span> col_b[] = {255, 220, 133, 93, 24, 8};</div>
<div class="line">    value = std::max(0.0, value);</div>
<div class="line">    <span class="keyword">auto</span> i = std::max(0, std::min(4, <span class="keywordtype">int</span>(value)));</div>
<div class="line">    <span class="keyword">auto</span> d = std::max(0.0, std::min(1.0, value - i));</div>
<div class="line">    data[2] = static_cast&lt;unsigned char&gt;(col_r[i + 1] * d + col_r[i] * (1 - d));</div>
<div class="line">    data[1] = static_cast&lt;unsigned char&gt;(col_g[i + 1] * d + col_g[i] * (1 - d));</div>
<div class="line">    data[0] = static_cast&lt;unsigned char&gt;(col_b[i + 1] * d + col_b[i] * (1 - d));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">std::pair&lt;cv::VideoWriter, cv::Mat&gt; build_output(<span class="keywordtype">int</span> n, <span class="keywordtype">double</span> fps)</div>
<div class="line">{</div>
<div class="line">    cv::Size videosize{n, n};</div>
<div class="line">    <span class="keyword">auto</span> output =</div>
<div class="line">        std::make_pair(cv::VideoWriter{}, cv::Mat{videosize, CV_8UC3});</div>
<div class="line">    <span class="keyword">auto</span> fourcc = cv::VideoWriter::fourcc(<span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;v&#39;</span>, <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;1&#39;</span>);</div>
<div class="line">    output.first.open(<span class="stringliteral">&quot;nls.mp4&quot;</span>, fourcc, fps, videosize);</div>
<div class="line">    <span class="keywordflow">return</span> output;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> output_timestep(std::pair&lt;cv::VideoWriter, cv::Mat&gt;&amp; output, <span class="keywordtype">int</span> n,</div>
<div class="line">                     <span class="keyword">const</span> std::complex&lt;double&gt;* data)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++) {</div>
<div class="line">        <span class="keyword">auto</span> row = output.second.ptr(i);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; n; j++) {</div>
<div class="line">            set_val(&amp;row[3 * j], <a class="code" href="namespacegko.html#adeb470aaf293d7c5548392b2f451e8e4">abs</a>(data[i * n + j]));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    output.first.write(output.second);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> vec = <a class="code" href="classgko_1_1matrix_1_1Dense.html">gko::matrix::Dense&lt;std::complex&lt;double&gt;</a>&gt;;</div>
<div class="line">    <span class="keyword">using</span> real_vec = <a class="code" href="classgko_1_1matrix_1_1Dense.html">gko::matrix::Dense&lt;double&gt;</a>;</div>
<div class="line">    <span class="keyword">using</span> fft2 = <a class="code" href="classgko_1_1matrix_1_1Fft2.html">gko::matrix::Fft2</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> t0 = 15.0;</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> nonlinear_scale = 1.0;</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> potential_scale = 3.0;</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> time_scale = 0.25;</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> n = 256;</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> steps_per_sec = 1000;</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> fps = 25;</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> n2 = n * n;</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> h = 2.0 * gko::pi&lt;double&gt;() / n;</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> h2 = h * h;</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> tau = 1.0 / steps_per_sec;</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> idx = [&amp;](<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j) { <span class="keywordflow">return</span> i * n + j; };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> exec = <a class="code" href="classgko_1_1OmpExecutor.html#a8930142a1913bcbcac4fb6c917f930d9">gko::OmpExecutor::create</a>();</div>
<div class="line">    std::ifstream initial_stream(<span class="stringliteral">&quot;data/gko_logo_2d.mtx&quot;</span>);</div>
<div class="line">    std::ifstream potential_stream(<span class="stringliteral">&quot;data/gko_text_2d.mtx&quot;</span>);</div>
<div class="line">    <span class="keyword">auto</span> amplitude = gko::read&lt;vec&gt;(initial_stream, exec);</div>
<div class="line">    <span class="keyword">auto</span> potential = gko::read&lt;real_vec&gt;(potential_stream, exec);</div>
<div class="line">    <span class="keyword">auto</span> frequency = vec::create(exec, amplitude-&gt;get_size());</div>
<div class="line">    <span class="keyword">auto</span> fft = fft2::create(exec, n, n);</div>
<div class="line">    <span class="keyword">auto</span> ifft = fft-&gt;conj_transpose();</div>
<div class="line">    <span class="keyword">auto</span> output = build_output(n, fps);</div>
<div class="line">    <span class="keywordtype">double</span> last_t = -t0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">double</span> t = 0; t &lt; t0; t += tau) {</div>
<div class="line">        <span class="keywordflow">if</span> (t - last_t &gt; 1.0 / fps) {</div>
<div class="line">            last_t = t;</div>
<div class="line">            std::cout &lt;&lt; t &lt;&lt; std::endl;</div>
<div class="line">            output_timestep(output, n, amplitude-&gt;get_const_values());</div>
<div class="line">        }</div>
<div class="line">        fft-&gt;apply(amplitude, frequency);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; n; j++) {</div>
<div class="line">                frequency-&gt;at(idx(i, j)) *=</div>
<div class="line">                    std::polar(1.0, -h2 * (i * i + j * j) * tau * time_scale);</div>
<div class="line">                frequency-&gt;at(idx(i, j)) *= 1.0 / n2;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        ifft-&gt;apply(frequency, amplitude);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; n; j++) {</div>
<div class="line">                amplitude-&gt;at(idx(i, j)) *= std::polar(</div>
<div class="line">                    1.0, -(nonlinear_scale *</div>
<div class="line">                               <a class="code" href="namespacegko.html#abbb55709b10d707b2cbef803832aa834">gko::squared_norm</a>(amplitude-&gt;at(idx(i, j))) +</div>
<div class="line">                           potential_scale * potential-&gt;at(idx(i, j))) *</div>
<div class="line">                             tau * time_scale);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="aclassgko_1_1matrix_1_1Dense_html"><div class="ttname"><a href="classgko_1_1matrix_1_1Dense.html">gko::matrix::Dense</a></div><div class="ttdoc">Dense is a matrix format which explicitly stores all values of the matrix.</div><div class="ttdef"><b>Definition:</b> dense_cache.hpp:20</div></div>
<div class="ttc" id="anamespacegko_html_adeb470aaf293d7c5548392b2f451e8e4"><div class="ttname"><a href="namespacegko.html#adeb470aaf293d7c5548392b2f451e8e4">gko::abs</a></div><div class="ttdeci">constexpr xstd::enable_if_t&lt;!is_complex_s&lt; T &gt;::value, T &gt; abs(const T &amp;x)</div><div class="ttdoc">Returns the absolute value of the object.</div><div class="ttdef"><b>Definition:</b> math.hpp:1076</div></div>
<div class="ttc" id="anamespacegko_html_abbb55709b10d707b2cbef803832aa834"><div class="ttname"><a href="namespacegko.html#abbb55709b10d707b2cbef803832aa834">gko::squared_norm</a></div><div class="ttdeci">constexpr auto squared_norm(const T &amp;x) -&gt; decltype(real(conj(x) *x))</div><div class="ttdoc">Returns the squared norm of the object.</div><div class="ttdef"><b>Definition:</b> math.hpp:1057</div></div>
<div class="ttc" id="aclassgko_1_1OmpExecutor_html_a8930142a1913bcbcac4fb6c917f930d9"><div class="ttname"><a href="classgko_1_1OmpExecutor.html#a8930142a1913bcbcac4fb6c917f930d9">gko::OmpExecutor::create</a></div><div class="ttdeci">static std::shared_ptr&lt; OmpExecutor &gt; create(std::shared_ptr&lt; CpuAllocatorBase &gt; alloc=std::make_shared&lt; CpuAllocator &gt;())</div><div class="ttdoc">Creates a new OmpExecutor.</div><div class="ttdef"><b>Definition:</b> executor.hpp:1345</div></div>
<div class="ttc" id="aclassgko_1_1matrix_1_1Fft2_html"><div class="ttname"><a href="classgko_1_1matrix_1_1Fft2.html">gko::matrix::Fft2</a></div><div class="ttdoc">This LinOp implements a 2D Fourier matrix using the FFT algorithm.</div><div class="ttdef"><b>Definition:</b> fft.hpp:141</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
