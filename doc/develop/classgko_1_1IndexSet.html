<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Ginkgo: gko::IndexSet&lt; IndexType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_doc.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Ginkgo
   &#160;<span id="projectnumber">Generated from pipelines/407618847 branch based on develop. Ginkgo version 1.5.0</span>
   </div>
   <div id="projectbrief">A numerical linear algebra library targeting many-core architectures</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegko.html">gko</a></li><li class="navelem"><a class="el" href="classgko_1_1IndexSet.html">IndexSet</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classgko_1_1IndexSet-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">gko::IndexSet&lt; IndexType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An index set class represents an ordered set of intervals.  
 <a href="classgko_1_1IndexSet.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="index__set_8hpp_source.html">ginkgo/core/base/index_set.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for gko::IndexSet&lt; IndexType &gt;:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classgko_1_1IndexSet__coll__graph.svg" width="100%" height="476"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2b293a8e6cbd476732e86bee7c5bc000"><td class="memItemLeft" align="right" valign="top"><a id="a2b293a8e6cbd476732e86bee7c5bc000"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1IndexSet.html#a2b293a8e6cbd476732e86bee7c5bc000">index_type</a> = IndexType</td></tr>
<tr class="memdesc:a2b293a8e6cbd476732e86bee7c5bc000"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of elements stored in the index set. <br /></td></tr>
<tr class="separator:a2b293a8e6cbd476732e86bee7c5bc000"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae5193c5d696cf66872af8e529956d9fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1IndexSet.html#ae5193c5d696cf66872af8e529956d9fb">IndexSet</a> (std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt; exec)</td></tr>
<tr class="memdesc:ae5193c5d696cf66872af8e529956d9fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty <a class="el" href="classgko_1_1IndexSet.html" title="An index set class represents an ordered set of intervals.">IndexSet</a> tied to the specified <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a>.  <a href="classgko_1_1IndexSet.html#ae5193c5d696cf66872af8e529956d9fb">More...</a><br /></td></tr>
<tr class="separator:ae5193c5d696cf66872af8e529956d9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7e5bf2f364877d09fd7700dd6aa3d4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1IndexSet.html#a4a7e5bf2f364877d09fd7700dd6aa3d4">IndexSet</a> (std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">gko::Executor</a> &gt; executor, const <a class="el" href="classgko_1_1IndexSet.html#a2b293a8e6cbd476732e86bee7c5bc000">index_type</a> size, const <a class="el" href="classgko_1_1Array.html">gko::Array</a>&lt; <a class="el" href="classgko_1_1IndexSet.html#a2b293a8e6cbd476732e86bee7c5bc000">index_type</a> &gt; &amp;indices, const bool is_sorted=false)</td></tr>
<tr class="memdesc:a4a7e5bf2f364877d09fd7700dd6aa3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an index set on the specified executor and the given size.  <a href="classgko_1_1IndexSet.html#a4a7e5bf2f364877d09fd7700dd6aa3d4">More...</a><br /></td></tr>
<tr class="separator:a4a7e5bf2f364877d09fd7700dd6aa3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158fd46f4660d2e2b00941296ac996d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1IndexSet.html#a158fd46f4660d2e2b00941296ac996d9">IndexSet</a> (std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt; exec, const <a class="el" href="classgko_1_1IndexSet.html">IndexSet</a> &amp;other)</td></tr>
<tr class="memdesc:a158fd46f4660d2e2b00941296ac996d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a copy of another <a class="el" href="classgko_1_1IndexSet.html" title="An index set class represents an ordered set of intervals.">IndexSet</a> on a different executor.  <a href="classgko_1_1IndexSet.html#a158fd46f4660d2e2b00941296ac996d9">More...</a><br /></td></tr>
<tr class="separator:a158fd46f4660d2e2b00941296ac996d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6369b1ebdc53713eab7a6790c8ee1a00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgko_1_1IndexSet.html#a2b293a8e6cbd476732e86bee7c5bc000">index_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1IndexSet.html#a6369b1ebdc53713eab7a6790c8ee1a00">get_size</a> () const</td></tr>
<tr class="memdesc:a6369b1ebdc53713eab7a6790c8ee1a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the index set space.  <a href="classgko_1_1IndexSet.html#a6369b1ebdc53713eab7a6790c8ee1a00">More...</a><br /></td></tr>
<tr class="separator:a6369b1ebdc53713eab7a6790c8ee1a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b753925eaf5cb382514bcebaf8d5941"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1IndexSet.html#a4b753925eaf5cb382514bcebaf8d5941">is_contiguous</a> () const</td></tr>
<tr class="memdesc:a4b753925eaf5cb382514bcebaf8d5941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the index set is contiguous.  <a href="classgko_1_1IndexSet.html#a4b753925eaf5cb382514bcebaf8d5941">More...</a><br /></td></tr>
<tr class="separator:a4b753925eaf5cb382514bcebaf8d5941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea0a9e4f38678524344cc9c4b73db3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgko_1_1IndexSet.html#a2b293a8e6cbd476732e86bee7c5bc000">index_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1IndexSet.html#afea0a9e4f38678524344cc9c4b73db3b">get_num_elems</a> () const</td></tr>
<tr class="memdesc:afea0a9e4f38678524344cc9c4b73db3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the actual number of indices stored in the index set.  <a href="classgko_1_1IndexSet.html#afea0a9e4f38678524344cc9c4b73db3b">More...</a><br /></td></tr>
<tr class="separator:afea0a9e4f38678524344cc9c4b73db3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682d3560a996f20daa7aea489c8c87a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgko_1_1IndexSet.html#a2b293a8e6cbd476732e86bee7c5bc000">index_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1IndexSet.html#a682d3560a996f20daa7aea489c8c87a8">get_global_index</a> (<a class="el" href="classgko_1_1IndexSet.html#a2b293a8e6cbd476732e86bee7c5bc000">index_type</a> local_index) const</td></tr>
<tr class="memdesc:a682d3560a996f20daa7aea489c8c87a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the global index given a local index.  <a href="classgko_1_1IndexSet.html#a682d3560a996f20daa7aea489c8c87a8">More...</a><br /></td></tr>
<tr class="separator:a682d3560a996f20daa7aea489c8c87a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a211b6f07cf0823154a64ccae02c564ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgko_1_1IndexSet.html#a2b293a8e6cbd476732e86bee7c5bc000">index_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1IndexSet.html#a211b6f07cf0823154a64ccae02c564ef">get_local_index</a> (<a class="el" href="classgko_1_1IndexSet.html#a2b293a8e6cbd476732e86bee7c5bc000">index_type</a> global_index) const</td></tr>
<tr class="memdesc:a211b6f07cf0823154a64ccae02c564ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the local index given a global index.  <a href="classgko_1_1IndexSet.html#a211b6f07cf0823154a64ccae02c564ef">More...</a><br /></td></tr>
<tr class="separator:a211b6f07cf0823154a64ccae02c564ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2aa53a0f3f0dde5a8fc3838d04e2574"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgko_1_1Array.html">Array</a>&lt; <a class="el" href="classgko_1_1IndexSet.html#a2b293a8e6cbd476732e86bee7c5bc000">index_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1IndexSet.html#ae2aa53a0f3f0dde5a8fc3838d04e2574">map_local_to_global</a> (const <a class="el" href="classgko_1_1Array.html">Array</a>&lt; <a class="el" href="classgko_1_1IndexSet.html#a2b293a8e6cbd476732e86bee7c5bc000">index_type</a> &gt; &amp;local_indices, const bool is_sorted=false) const</td></tr>
<tr class="memdesc:ae2aa53a0f3f0dde5a8fc3838d04e2574"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an array version of the scalar function above.  <a href="classgko_1_1IndexSet.html#ae2aa53a0f3f0dde5a8fc3838d04e2574">More...</a><br /></td></tr>
<tr class="separator:ae2aa53a0f3f0dde5a8fc3838d04e2574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeae4bfb80d65185e8142cce57751563"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgko_1_1Array.html">Array</a>&lt; <a class="el" href="classgko_1_1IndexSet.html#a2b293a8e6cbd476732e86bee7c5bc000">index_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1IndexSet.html#abeae4bfb80d65185e8142cce57751563">map_global_to_local</a> (const <a class="el" href="classgko_1_1Array.html">Array</a>&lt; <a class="el" href="classgko_1_1IndexSet.html#a2b293a8e6cbd476732e86bee7c5bc000">index_type</a> &gt; &amp;global_indices, const bool is_sorted=false) const</td></tr>
<tr class="memdesc:abeae4bfb80d65185e8142cce57751563"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an array version of the scalar function above.  <a href="classgko_1_1IndexSet.html#abeae4bfb80d65185e8142cce57751563">More...</a><br /></td></tr>
<tr class="separator:abeae4bfb80d65185e8142cce57751563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a3501f2752f588933e35b6bb10b8cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgko_1_1Array.html">Array</a>&lt; <a class="el" href="classgko_1_1IndexSet.html#a2b293a8e6cbd476732e86bee7c5bc000">index_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1IndexSet.html#ae6a3501f2752f588933e35b6bb10b8cd">to_global_indices</a> () const</td></tr>
<tr class="memdesc:ae6a3501f2752f588933e35b6bb10b8cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allows the user obtain a decompresed global_indices <a class="el" href="classgko_1_1Array.html" title="An Array is a container which encapsulates fixed-sized arrays, stored on the Executor tied to the Arr...">Array</a> from the indices stored in the index set.  <a href="classgko_1_1IndexSet.html#ae6a3501f2752f588933e35b6bb10b8cd">More...</a><br /></td></tr>
<tr class="separator:ae6a3501f2752f588933e35b6bb10b8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa643d804627a023ac4bbdb42fb42add2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgko_1_1Array.html">Array</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1IndexSet.html#aa643d804627a023ac4bbdb42fb42add2">contains</a> (const <a class="el" href="classgko_1_1Array.html">Array</a>&lt; <a class="el" href="classgko_1_1IndexSet.html#a2b293a8e6cbd476732e86bee7c5bc000">index_type</a> &gt; &amp;global_indices, const bool is_sorted=false) const</td></tr>
<tr class="memdesc:aa643d804627a023ac4bbdb42fb42add2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the individual global indeices exist in the index set.  <a href="classgko_1_1IndexSet.html#aa643d804627a023ac4bbdb42fb42add2">More...</a><br /></td></tr>
<tr class="separator:aa643d804627a023ac4bbdb42fb42add2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aee65b87e5b856f82d7a35df1bce9e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1IndexSet.html#a9aee65b87e5b856f82d7a35df1bce9e0">contains</a> (const <a class="el" href="classgko_1_1IndexSet.html#a2b293a8e6cbd476732e86bee7c5bc000">index_type</a> global_index) const</td></tr>
<tr class="memdesc:a9aee65b87e5b856f82d7a35df1bce9e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the global index exists in the index set.  <a href="classgko_1_1IndexSet.html#a9aee65b87e5b856f82d7a35df1bce9e0">More...</a><br /></td></tr>
<tr class="separator:a9aee65b87e5b856f82d7a35df1bce9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525ec8f651b7aaf5ecbf047697a4dba0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgko_1_1IndexSet.html#a2b293a8e6cbd476732e86bee7c5bc000">index_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1IndexSet.html#a525ec8f651b7aaf5ecbf047697a4dba0">get_num_subsets</a> () const</td></tr>
<tr class="memdesc:a525ec8f651b7aaf5ecbf047697a4dba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of subsets stored in the index set.  <a href="classgko_1_1IndexSet.html#a525ec8f651b7aaf5ecbf047697a4dba0">More...</a><br /></td></tr>
<tr class="separator:a525ec8f651b7aaf5ecbf047697a4dba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff3a7c9c9d72648f44db3ff0dcc970c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classgko_1_1IndexSet.html#a2b293a8e6cbd476732e86bee7c5bc000">index_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1IndexSet.html#a7ff3a7c9c9d72648f44db3ff0dcc970c">get_subsets_begin</a> () const</td></tr>
<tr class="memdesc:a7ff3a7c9c9d72648f44db3ff0dcc970c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the beginning indices of the subsets.  <a href="classgko_1_1IndexSet.html#a7ff3a7c9c9d72648f44db3ff0dcc970c">More...</a><br /></td></tr>
<tr class="separator:a7ff3a7c9c9d72648f44db3ff0dcc970c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d5befb6738b61580e335c531a114a0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classgko_1_1IndexSet.html#a2b293a8e6cbd476732e86bee7c5bc000">index_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1IndexSet.html#a13d5befb6738b61580e335c531a114a0">get_subsets_end</a> () const</td></tr>
<tr class="memdesc:a13d5befb6738b61580e335c531a114a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the end indices of the subsets.  <a href="classgko_1_1IndexSet.html#a13d5befb6738b61580e335c531a114a0">More...</a><br /></td></tr>
<tr class="separator:a13d5befb6738b61580e335c531a114a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e789e5aec948193783c143f5a8eb897"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classgko_1_1IndexSet.html#a2b293a8e6cbd476732e86bee7c5bc000">index_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1IndexSet.html#a0e789e5aec948193783c143f5a8eb897">get_superset_indices</a> () const</td></tr>
<tr class="memdesc:a0e789e5aec948193783c143f5a8eb897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the cumulative indices of the superset of the subsets.  <a href="classgko_1_1IndexSet.html#a0e789e5aec948193783c143f5a8eb897">More...</a><br /></td></tr>
<tr class="separator:a0e789e5aec948193783c143f5a8eb897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classgko_1_1EnableAbstractPolymorphicObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classgko_1_1EnableAbstractPolymorphicObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classgko_1_1EnableAbstractPolymorphicObject.html">gko::EnableAbstractPolymorphicObject&lt; IndexSet&lt; IndexType &gt;, PolymorphicObject &gt;</a></td></tr>
<tr class="memitem:ac84c5033523a8c59662287fa0541c18c inherit pub_methods_classgko_1_1EnableAbstractPolymorphicObject"><td class="memItemLeft" align="right" valign="top"><a id="ac84c5033523a8c59662287fa0541c18c"></a>
std::unique_ptr&lt; <a class="el" href="classgko_1_1IndexSet.html">IndexSet</a>&lt; IndexType &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>create_default</b> (std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt; exec) const</td></tr>
<tr class="separator:ac84c5033523a8c59662287fa0541c18c inherit pub_methods_classgko_1_1EnableAbstractPolymorphicObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5153f52a413e92a0477c0b99c5bc3b37 inherit pub_methods_classgko_1_1EnableAbstractPolymorphicObject"><td class="memItemLeft" align="right" valign="top"><a id="a5153f52a413e92a0477c0b99c5bc3b37"></a>
std::unique_ptr&lt; <a class="el" href="classgko_1_1IndexSet.html">IndexSet</a>&lt; IndexType &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>create_default</b> () const</td></tr>
<tr class="separator:a5153f52a413e92a0477c0b99c5bc3b37 inherit pub_methods_classgko_1_1EnableAbstractPolymorphicObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab580b1eed2674cd1eda5d18086bc1944 inherit pub_methods_classgko_1_1EnableAbstractPolymorphicObject"><td class="memItemLeft" align="right" valign="top"><a id="ab580b1eed2674cd1eda5d18086bc1944"></a>
std::unique_ptr&lt; <a class="el" href="classgko_1_1IndexSet.html">IndexSet</a>&lt; IndexType &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>clone</b> (std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt; exec) const</td></tr>
<tr class="separator:ab580b1eed2674cd1eda5d18086bc1944 inherit pub_methods_classgko_1_1EnableAbstractPolymorphicObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08485221c0ea27e9100069c65c40f5cb inherit pub_methods_classgko_1_1EnableAbstractPolymorphicObject"><td class="memItemLeft" align="right" valign="top"><a id="a08485221c0ea27e9100069c65c40f5cb"></a>
std::unique_ptr&lt; <a class="el" href="classgko_1_1IndexSet.html">IndexSet</a>&lt; IndexType &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>clone</b> () const</td></tr>
<tr class="separator:a08485221c0ea27e9100069c65c40f5cb inherit pub_methods_classgko_1_1EnableAbstractPolymorphicObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9588dfdd287538548e513c79793d5e inherit pub_methods_classgko_1_1EnableAbstractPolymorphicObject"><td class="memItemLeft" align="right" valign="top"><a id="a6a9588dfdd287538548e513c79793d5e"></a>
<a class="el" href="classgko_1_1IndexSet.html">IndexSet</a>&lt; IndexType &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>copy_from</b> (const <a class="el" href="classgko_1_1PolymorphicObject.html">PolymorphicObject</a> *other)</td></tr>
<tr class="separator:a6a9588dfdd287538548e513c79793d5e inherit pub_methods_classgko_1_1EnableAbstractPolymorphicObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a690b36626761167b3fa51bd8ea06a inherit pub_methods_classgko_1_1EnableAbstractPolymorphicObject"><td class="memItemLeft" align="right" valign="top"><a id="ab1a690b36626761167b3fa51bd8ea06a"></a>
<a class="el" href="classgko_1_1IndexSet.html">IndexSet</a>&lt; IndexType &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>copy_from</b> (std::unique_ptr&lt; <a class="el" href="classgko_1_1PolymorphicObject.html">PolymorphicObject</a> &gt; other)</td></tr>
<tr class="separator:ab1a690b36626761167b3fa51bd8ea06a inherit pub_methods_classgko_1_1EnableAbstractPolymorphicObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74d41178d0f0e6bfcada520ea3e3099 inherit pub_methods_classgko_1_1EnableAbstractPolymorphicObject"><td class="memItemLeft" align="right" valign="top"><a id="ae74d41178d0f0e6bfcada520ea3e3099"></a>
<a class="el" href="classgko_1_1IndexSet.html">IndexSet</a>&lt; IndexType &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="separator:ae74d41178d0f0e6bfcada520ea3e3099 inherit pub_methods_classgko_1_1EnableAbstractPolymorphicObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classgko_1_1PolymorphicObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classgko_1_1PolymorphicObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classgko_1_1PolymorphicObject.html">gko::PolymorphicObject</a></td></tr>
<tr class="memitem:ab9abbed8b77c7b4b2feb2ec30dc65e47 inherit pub_methods_classgko_1_1PolymorphicObject"><td class="memItemLeft" align="right" valign="top"><a id="ab9abbed8b77c7b4b2feb2ec30dc65e47"></a>
<a class="el" href="classgko_1_1PolymorphicObject.html">PolymorphicObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classgko_1_1PolymorphicObject.html">PolymorphicObject</a> &amp;)</td></tr>
<tr class="separator:ab9abbed8b77c7b4b2feb2ec30dc65e47 inherit pub_methods_classgko_1_1PolymorphicObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2ad91eee15e667cc0e7d1444a6de47 inherit pub_methods_classgko_1_1PolymorphicObject"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classgko_1_1PolymorphicObject.html">PolymorphicObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1PolymorphicObject.html#aca2ad91eee15e667cc0e7d1444a6de47">create_default</a> (std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt; exec) const</td></tr>
<tr class="memdesc:aca2ad91eee15e667cc0e7d1444a6de47 inherit pub_methods_classgko_1_1PolymorphicObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new "default" object of the same dynamic type as this object.  <a href="classgko_1_1PolymorphicObject.html#aca2ad91eee15e667cc0e7d1444a6de47">More...</a><br /></td></tr>
<tr class="separator:aca2ad91eee15e667cc0e7d1444a6de47 inherit pub_methods_classgko_1_1PolymorphicObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f39c32375e3887fd4d7a9f02af42ca7 inherit pub_methods_classgko_1_1PolymorphicObject"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classgko_1_1PolymorphicObject.html">PolymorphicObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1PolymorphicObject.html#a4f39c32375e3887fd4d7a9f02af42ca7">create_default</a> () const</td></tr>
<tr class="memdesc:a4f39c32375e3887fd4d7a9f02af42ca7 inherit pub_methods_classgko_1_1PolymorphicObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new "default" object of the same dynamic type as this object.  <a href="classgko_1_1PolymorphicObject.html#a4f39c32375e3887fd4d7a9f02af42ca7">More...</a><br /></td></tr>
<tr class="separator:a4f39c32375e3887fd4d7a9f02af42ca7 inherit pub_methods_classgko_1_1PolymorphicObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada90b9acf2e6b3201a9b2e09ac56217f inherit pub_methods_classgko_1_1PolymorphicObject"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classgko_1_1PolymorphicObject.html">PolymorphicObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1PolymorphicObject.html#ada90b9acf2e6b3201a9b2e09ac56217f">clone</a> (std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt; exec) const</td></tr>
<tr class="memdesc:ada90b9acf2e6b3201a9b2e09ac56217f inherit pub_methods_classgko_1_1PolymorphicObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the object.  <a href="classgko_1_1PolymorphicObject.html#ada90b9acf2e6b3201a9b2e09ac56217f">More...</a><br /></td></tr>
<tr class="separator:ada90b9acf2e6b3201a9b2e09ac56217f inherit pub_methods_classgko_1_1PolymorphicObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298c488bcb1906877a3584d88713ba81 inherit pub_methods_classgko_1_1PolymorphicObject"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classgko_1_1PolymorphicObject.html">PolymorphicObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1PolymorphicObject.html#a298c488bcb1906877a3584d88713ba81">clone</a> () const</td></tr>
<tr class="memdesc:a298c488bcb1906877a3584d88713ba81 inherit pub_methods_classgko_1_1PolymorphicObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the object.  <a href="classgko_1_1PolymorphicObject.html#a298c488bcb1906877a3584d88713ba81">More...</a><br /></td></tr>
<tr class="separator:a298c488bcb1906877a3584d88713ba81 inherit pub_methods_classgko_1_1PolymorphicObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6f713938293cfbe788d00480eb4d81 inherit pub_methods_classgko_1_1PolymorphicObject"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgko_1_1PolymorphicObject.html">PolymorphicObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1PolymorphicObject.html#a5e6f713938293cfbe788d00480eb4d81">copy_from</a> (const <a class="el" href="classgko_1_1PolymorphicObject.html">PolymorphicObject</a> *other)</td></tr>
<tr class="memdesc:a5e6f713938293cfbe788d00480eb4d81 inherit pub_methods_classgko_1_1PolymorphicObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies another object into this object.  <a href="classgko_1_1PolymorphicObject.html#a5e6f713938293cfbe788d00480eb4d81">More...</a><br /></td></tr>
<tr class="separator:a5e6f713938293cfbe788d00480eb4d81 inherit pub_methods_classgko_1_1PolymorphicObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ba40d3fb5e1e73cd92f4830a34c999 inherit pub_methods_classgko_1_1PolymorphicObject"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgko_1_1PolymorphicObject.html">PolymorphicObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1PolymorphicObject.html#ae6ba40d3fb5e1e73cd92f4830a34c999">copy_from</a> (std::unique_ptr&lt; <a class="el" href="classgko_1_1PolymorphicObject.html">PolymorphicObject</a> &gt; other)</td></tr>
<tr class="memdesc:ae6ba40d3fb5e1e73cd92f4830a34c999 inherit pub_methods_classgko_1_1PolymorphicObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves another object into this object.  <a href="classgko_1_1PolymorphicObject.html#ae6ba40d3fb5e1e73cd92f4830a34c999">More...</a><br /></td></tr>
<tr class="separator:ae6ba40d3fb5e1e73cd92f4830a34c999 inherit pub_methods_classgko_1_1PolymorphicObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb6f9995e8166099ca3ecab51d98df5 inherit pub_methods_classgko_1_1PolymorphicObject"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgko_1_1PolymorphicObject.html">PolymorphicObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1PolymorphicObject.html#a8bb6f9995e8166099ca3ecab51d98df5">clear</a> ()</td></tr>
<tr class="memdesc:a8bb6f9995e8166099ca3ecab51d98df5 inherit pub_methods_classgko_1_1PolymorphicObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the object into its default state.  <a href="classgko_1_1PolymorphicObject.html#a8bb6f9995e8166099ca3ecab51d98df5">More...</a><br /></td></tr>
<tr class="separator:a8bb6f9995e8166099ca3ecab51d98df5 inherit pub_methods_classgko_1_1PolymorphicObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40586bff071b7f11c2cf6b5cbf598eb inherit pub_methods_classgko_1_1PolymorphicObject"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1PolymorphicObject.html#ab40586bff071b7f11c2cf6b5cbf598eb">get_executor</a> () const noexcept</td></tr>
<tr class="memdesc:ab40586bff071b7f11c2cf6b5cbf598eb inherit pub_methods_classgko_1_1PolymorphicObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a> of the object.  <a href="classgko_1_1PolymorphicObject.html#ab40586bff071b7f11c2cf6b5cbf598eb">More...</a><br /></td></tr>
<tr class="separator:ab40586bff071b7f11c2cf6b5cbf598eb inherit pub_methods_classgko_1_1PolymorphicObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classgko_1_1log_1_1EnableLogging"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classgko_1_1log_1_1EnableLogging')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classgko_1_1log_1_1EnableLogging.html">gko::log::EnableLogging&lt; PolymorphicObject &gt;</a></td></tr>
<tr class="memitem:a7b3493c14a37b4d46487d9c636d784f2 inherit pub_methods_classgko_1_1log_1_1EnableLogging"><td class="memItemLeft" align="right" valign="top"><a id="a7b3493c14a37b4d46487d9c636d784f2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>add_logger</b> (std::shared_ptr&lt; const <a class="el" href="classgko_1_1log_1_1Logger.html">Logger</a> &gt; logger) override</td></tr>
<tr class="separator:a7b3493c14a37b4d46487d9c636d784f2 inherit pub_methods_classgko_1_1log_1_1EnableLogging"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5317f8a03956a61d770e9b07fc65cc inherit pub_methods_classgko_1_1log_1_1EnableLogging"><td class="memItemLeft" align="right" valign="top"><a id="aba5317f8a03956a61d770e9b07fc65cc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>remove_logger</b> (const <a class="el" href="classgko_1_1log_1_1Logger.html">Logger</a> *logger) override</td></tr>
<tr class="separator:aba5317f8a03956a61d770e9b07fc65cc inherit pub_methods_classgko_1_1log_1_1EnableLogging"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d6f4eac629ab724f5971fc10827602 inherit pub_methods_classgko_1_1log_1_1EnableLogging"><td class="memItemLeft" align="right" valign="top"><a id="a64d6f4eac629ab724f5971fc10827602"></a>
const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="classgko_1_1log_1_1Logger.html">Logger</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_loggers</b> () const override</td></tr>
<tr class="separator:a64d6f4eac629ab724f5971fc10827602 inherit pub_methods_classgko_1_1log_1_1EnableLogging"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d9630d014e4bb094b9e4f7b7bdc5ee inherit pub_methods_classgko_1_1log_1_1EnableLogging"><td class="memItemLeft" align="right" valign="top"><a id="a46d9630d014e4bb094b9e4f7b7bdc5ee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear_loggers</b> () override</td></tr>
<tr class="separator:a46d9630d014e4bb094b9e4f7b7bdc5ee inherit pub_methods_classgko_1_1log_1_1EnableLogging"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a533800cdf2ae031aab24f4acff1b3cf9"><td class="memItemLeft" align="right" valign="top"><a id="a533800cdf2ae031aab24f4acff1b3cf9"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>EnablePolymorphicObject&lt; IndexSet &gt;</b></td></tr>
<tr class="separator:a533800cdf2ae031aab24f4acff1b3cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename IndexType = int32&gt;<br />
class gko::IndexSet&lt; IndexType &gt;</h3>

<p>An index set class represents an ordered set of intervals. </p>
<p>The index set contains subsets which store the starting and end points of a range, [a,b), storing the first index and one past the last index. As the index set only stores the end-points of ranges, it can be quite efficient in terms of storage.</p>
<p>This class is particularly useful in storing continuous ranges. For example, consider the index set (1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 18, 19, 20, 21, 42). Instead of storing the entire array of indices, one can store intervals ([1,9), [10,13), [18,22), [42,43)), thereby only using half the storage.</p>
<p>We store three arrays, one (subsets_begin) with the starting indices of the subsets in the index set, another (subsets_end) storing one index beyond the end indices of the subsets and the last (superset_cumulative_indices) storing the cumulative number of indices in the subsequent subsets with an initial zero which speeds up the querying. Additionally, the arrays conataining the range boundaries (subsets_begin, subsets_end) are stored in a sorted fashion.</p>
<p>Therefore the storage would look as follows</p>
<blockquote class="doxtable">
<p>index_set = (1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 18, 19, 20, 21, 42) subsets_begin = {1, 10, 18, 42} subsets_end = {9, 13, 22, 43} superset_cumulative_indices = {0, 8, 11, 15, 16} </p>
</blockquote>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">index_type</td><td>type of the indices being stored in the index set. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae5193c5d696cf66872af8e529956d9fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5193c5d696cf66872af8e529956d9fb">&#9670;&nbsp;</a></span>IndexSet() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType  = int32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgko_1_1IndexSet.html">gko::IndexSet</a>&lt; IndexType &gt;::<a class="el" href="classgko_1_1IndexSet.html">IndexSet</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt;&#160;</td>
          <td class="paramname"><em>exec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an empty <a class="el" href="classgko_1_1IndexSet.html" title="An index set class represents an ordered set of intervals.">IndexSet</a> tied to the specified <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>the <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a> where the <a class="el" href="classgko_1_1IndexSet.html" title="An index set class represents an ordered set of intervals.">IndexSet</a> data is allocated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a7e5bf2f364877d09fd7700dd6aa3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a7e5bf2f364877d09fd7700dd6aa3d4">&#9670;&nbsp;</a></span>IndexSet() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType  = int32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgko_1_1IndexSet.html">gko::IndexSet</a>&lt; IndexType &gt;::<a class="el" href="classgko_1_1IndexSet.html">IndexSet</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">gko::Executor</a> &gt;&#160;</td>
          <td class="paramname"><em>executor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgko_1_1IndexSet.html#a2b293a8e6cbd476732e86bee7c5bc000">index_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgko_1_1Array.html">gko::Array</a>&lt; <a class="el" href="classgko_1_1IndexSet.html#a2b293a8e6cbd476732e86bee7c5bc000">index_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_sorted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an index set on the specified executor and the given size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>the <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a> where the index set data will be allocated </td></tr>
    <tr><td class="paramname">size</td><td>the maximum index the index set it allowed to hold. This is the size of the index space. </td></tr>
    <tr><td class="paramname">indices</td><td>the indices that the index set should hold. </td></tr>
    <tr><td class="paramname">is_sorted</td><td>a parameter that specifies if the indices array is sorted or not. <code>true</code> if sorted. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classgko_1_1Array.html#ad4a2aa179d350634e6579f144b6b2cf0">gko::Array&lt; ValueType &gt;::get_num_elems()</a>.</p>

</div>
</div>
<a id="a158fd46f4660d2e2b00941296ac996d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a158fd46f4660d2e2b00941296ac996d9">&#9670;&nbsp;</a></span>IndexSet() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType  = int32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgko_1_1IndexSet.html">gko::IndexSet</a>&lt; IndexType &gt;::<a class="el" href="classgko_1_1IndexSet.html">IndexSet</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgko_1_1IndexSet.html">IndexSet</a>&lt; IndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a copy of another <a class="el" href="classgko_1_1IndexSet.html" title="An index set class represents an ordered set of intervals.">IndexSet</a> on a different executor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>the executor where the new <a class="el" href="classgko_1_1IndexSet.html" title="An index set class represents an ordered set of intervals.">IndexSet</a> will be created </td></tr>
    <tr><td class="paramname">other</td><td>the <a class="el" href="classgko_1_1IndexSet.html" title="An index set class represents an ordered set of intervals.">IndexSet</a> to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa643d804627a023ac4bbdb42fb42add2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa643d804627a023ac4bbdb42fb42add2">&#9670;&nbsp;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType  = int32&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgko_1_1Array.html">Array</a>&lt;bool&gt; <a class="el" href="classgko_1_1IndexSet.html">gko::IndexSet</a>&lt; IndexType &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgko_1_1Array.html">Array</a>&lt; <a class="el" href="classgko_1_1IndexSet.html#a2b293a8e6cbd476732e86bee7c5bc000">index_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_sorted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the individual global indeices exist in the index set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_indices</td><td>the indices to check. </td></tr>
    <tr><td class="paramname">is_sorted</td><td>a parameter that specifies if the query array is sorted or not. <code>true</code> if sorted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classgko_1_1Array.html" title="An Array is a container which encapsulates fixed-sized arrays, stored on the Executor tied to the Arr...">Array</a> that contains element wise whether the corresponding global index in the index set or not. </dd></dl>

</div>
</div>
<a id="a9aee65b87e5b856f82d7a35df1bce9e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aee65b87e5b856f82d7a35df1bce9e0">&#9670;&nbsp;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType  = int32&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgko_1_1IndexSet.html">gko::IndexSet</a>&lt; IndexType &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgko_1_1IndexSet.html#a2b293a8e6cbd476732e86bee7c5bc000">index_type</a>&#160;</td>
          <td class="paramname"><em>global_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the global index exists in the index set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_index</td><td>the index to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the element exists in the index set.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This single entry query can have significant kernel lauch overheads and should be avoided if possible. </dd></dl>

</div>
</div>
<a id="a682d3560a996f20daa7aea489c8c87a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a682d3560a996f20daa7aea489c8c87a8">&#9670;&nbsp;</a></span>get_global_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType  = int32&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgko_1_1IndexSet.html#a2b293a8e6cbd476732e86bee7c5bc000">index_type</a> <a class="el" href="classgko_1_1IndexSet.html">gko::IndexSet</a>&lt; IndexType &gt;::get_global_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgko_1_1IndexSet.html#a2b293a8e6cbd476732e86bee7c5bc000">index_type</a>&#160;</td>
          <td class="paramname"><em>local_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the global index given a local index. </p>
<p>Consider the set idx_set = (0, 1, 2, 4, 6, 7, 8, 9). This function returns the element at the global index k stored in the index set. For example, <code>idx_set.get_global_index(0) == 0</code> <code>idx_set.get_global_index(3) == 4</code> and <code>idx_set.get_global_index(7) == 9</code></p>
<dl class="section note"><dt>Note</dt><dd>This function returns a scalar value and needs a scalar value. For repeated queries, it is more efficient to use the <a class="el" href="classgko_1_1Array.html" title="An Array is a container which encapsulates fixed-sized arrays, stored on the Executor tied to the Arr...">Array</a> functions that take and return arrays which allow for more throughput.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">local_index</td><td>the local index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the global index from the index set.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This single entry query can have significant kernel lauch overheads and should be avoided if possible. </dd></dl>

</div>
</div>
<a id="a211b6f07cf0823154a64ccae02c564ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a211b6f07cf0823154a64ccae02c564ef">&#9670;&nbsp;</a></span>get_local_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType  = int32&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgko_1_1IndexSet.html#a2b293a8e6cbd476732e86bee7c5bc000">index_type</a> <a class="el" href="classgko_1_1IndexSet.html">gko::IndexSet</a>&lt; IndexType &gt;::get_local_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgko_1_1IndexSet.html#a2b293a8e6cbd476732e86bee7c5bc000">index_type</a>&#160;</td>
          <td class="paramname"><em>global_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the local index given a global index. </p>
<p>Consider the set idx_set = (0, 1, 2, 4, 6, 7, 8, 9). This function returns the local index in the index set of the provided index set. For example, <code>idx_set.get_local_index(0) == 0</code> <code>idx_set.get_local_index(4) == 3</code> and <code>idx_set.get_local_index(6) == 4</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This function returns a scalar value and needs a scalar value. For repeated queries, it is more efficient to use the <a class="el" href="classgko_1_1Array.html" title="An Array is a container which encapsulates fixed-sized arrays, stored on the Executor tied to the Arr...">Array</a> functions that take and return arrays which allow for more throughput.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_index</td><td>the global index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the local index of the element in the index set.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This single entry query can have significant kernel lauch overheads and should be avoided if possible. </dd></dl>

</div>
</div>
<a id="afea0a9e4f38678524344cc9c4b73db3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afea0a9e4f38678524344cc9c4b73db3b">&#9670;&nbsp;</a></span>get_num_elems()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType  = int32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgko_1_1IndexSet.html#a2b293a8e6cbd476732e86bee7c5bc000">index_type</a> <a class="el" href="classgko_1_1IndexSet.html">gko::IndexSet</a>&lt; IndexType &gt;::get_num_elems </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the actual number of indices stored in the index set. </p>
<dl class="section return"><dt>Returns</dt><dd>number of indices stored in the index set </dd></dl>

</div>
</div>
<a id="a525ec8f651b7aaf5ecbf047697a4dba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a525ec8f651b7aaf5ecbf047697a4dba0">&#9670;&nbsp;</a></span>get_num_subsets()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType  = int32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgko_1_1IndexSet.html#a2b293a8e6cbd476732e86bee7c5bc000">index_type</a> <a class="el" href="classgko_1_1IndexSet.html">gko::IndexSet</a>&lt; IndexType &gt;::get_num_subsets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of subsets stored in the index set. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of stored subsets. </dd></dl>

<p class="reference">References <a class="el" href="classgko_1_1Array.html#ad4a2aa179d350634e6579f144b6b2cf0">gko::Array&lt; ValueType &gt;::get_num_elems()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classgko_1_1IndexSet.html#a4b753925eaf5cb382514bcebaf8d5941">gko::IndexSet&lt; IndexType &gt;::is_contiguous()</a>.</p>

</div>
</div>
<a id="a6369b1ebdc53713eab7a6790c8ee1a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6369b1ebdc53713eab7a6790c8ee1a00">&#9670;&nbsp;</a></span>get_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType  = int32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgko_1_1IndexSet.html#a2b293a8e6cbd476732e86bee7c5bc000">index_type</a> <a class="el" href="classgko_1_1IndexSet.html">gko::IndexSet</a>&lt; IndexType &gt;::get_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the index set space. </p>
<dl class="section return"><dt>Returns</dt><dd>the size of the index set space. </dd></dl>

</div>
</div>
<a id="a7ff3a7c9c9d72648f44db3ff0dcc970c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ff3a7c9c9d72648f44db3ff0dcc970c">&#9670;&nbsp;</a></span>get_subsets_begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType  = int32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classgko_1_1IndexSet.html#a2b293a8e6cbd476732e86bee7c5bc000">index_type</a>* <a class="el" href="classgko_1_1IndexSet.html">gko::IndexSet</a>&lt; IndexType &gt;::get_subsets_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the beginning indices of the subsets. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the beginning indices of the subsets. </dd></dl>

<p class="reference">References <a class="el" href="classgko_1_1Array.html#a5a46e0920b649cdb062f5e415922d1aa">gko::Array&lt; ValueType &gt;::get_const_data()</a>.</p>

</div>
</div>
<a id="a13d5befb6738b61580e335c531a114a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13d5befb6738b61580e335c531a114a0">&#9670;&nbsp;</a></span>get_subsets_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType  = int32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classgko_1_1IndexSet.html#a2b293a8e6cbd476732e86bee7c5bc000">index_type</a>* <a class="el" href="classgko_1_1IndexSet.html">gko::IndexSet</a>&lt; IndexType &gt;::get_subsets_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the end indices of the subsets. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the end indices of the subsets. </dd></dl>

<p class="reference">References <a class="el" href="classgko_1_1Array.html#a5a46e0920b649cdb062f5e415922d1aa">gko::Array&lt; ValueType &gt;::get_const_data()</a>.</p>

</div>
</div>
<a id="a0e789e5aec948193783c143f5a8eb897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e789e5aec948193783c143f5a8eb897">&#9670;&nbsp;</a></span>get_superset_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType  = int32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classgko_1_1IndexSet.html#a2b293a8e6cbd476732e86bee7c5bc000">index_type</a>* <a class="el" href="classgko_1_1IndexSet.html">gko::IndexSet</a>&lt; IndexType &gt;::get_superset_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the cumulative indices of the superset of the subsets. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the cumulative indices of the superset of the subsets. </dd></dl>

<p class="reference">References <a class="el" href="classgko_1_1Array.html#a5a46e0920b649cdb062f5e415922d1aa">gko::Array&lt; ValueType &gt;::get_const_data()</a>.</p>

</div>
</div>
<a id="a4b753925eaf5cb382514bcebaf8d5941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b753925eaf5cb382514bcebaf8d5941">&#9670;&nbsp;</a></span>is_contiguous()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType  = int32&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classgko_1_1IndexSet.html">gko::IndexSet</a>&lt; IndexType &gt;::is_contiguous </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the index set is contiguous. </p>
<dl class="section return"><dt>Returns</dt><dd>if the index set is contiguous. </dd></dl>

<p class="reference">References <a class="el" href="classgko_1_1IndexSet.html#a525ec8f651b7aaf5ecbf047697a4dba0">gko::IndexSet&lt; IndexType &gt;::get_num_subsets()</a>.</p>

</div>
</div>
<a id="abeae4bfb80d65185e8142cce57751563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeae4bfb80d65185e8142cce57751563">&#9670;&nbsp;</a></span>map_global_to_local()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType  = int32&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgko_1_1Array.html">Array</a>&lt;<a class="el" href="classgko_1_1IndexSet.html#a2b293a8e6cbd476732e86bee7c5bc000">index_type</a>&gt; <a class="el" href="classgko_1_1IndexSet.html">gko::IndexSet</a>&lt; IndexType &gt;::map_global_to_local </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgko_1_1Array.html">Array</a>&lt; <a class="el" href="classgko_1_1IndexSet.html#a2b293a8e6cbd476732e86bee7c5bc000">index_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_sorted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an array version of the scalar function above. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_indices</td><td>the global index array. </td></tr>
    <tr><td class="paramname">is_sorted</td><td>a parameter that specifies if the query array is sorted or not. <code>true</code> if sorted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the local index array from the index set.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Whenever possible, passing a sorted array is preferred as the queries can be significantly faster. </dd></dl>

</div>
</div>
<a id="ae2aa53a0f3f0dde5a8fc3838d04e2574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2aa53a0f3f0dde5a8fc3838d04e2574">&#9670;&nbsp;</a></span>map_local_to_global()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType  = int32&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgko_1_1Array.html">Array</a>&lt;<a class="el" href="classgko_1_1IndexSet.html#a2b293a8e6cbd476732e86bee7c5bc000">index_type</a>&gt; <a class="el" href="classgko_1_1IndexSet.html">gko::IndexSet</a>&lt; IndexType &gt;::map_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgko_1_1Array.html">Array</a>&lt; <a class="el" href="classgko_1_1IndexSet.html#a2b293a8e6cbd476732e86bee7c5bc000">index_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_sorted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an array version of the scalar function above. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">local_indices</td><td>the local index array. </td></tr>
    <tr><td class="paramname">is_sorted</td><td>a parameter that specifies if the query array is sorted or not. <code>true</code> if sorted .</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the global index array from the index set.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Whenever possible, passing a sorted array is preferred as the queries can be significantly faster. </dd>
<dd>
Passing local indices from [0, size) is equivalent to using the @to_global_indices function. </dd></dl>

</div>
</div>
<a id="ae6a3501f2752f588933e35b6bb10b8cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a3501f2752f588933e35b6bb10b8cd">&#9670;&nbsp;</a></span>to_global_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType  = int32&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgko_1_1Array.html">Array</a>&lt;<a class="el" href="classgko_1_1IndexSet.html#a2b293a8e6cbd476732e86bee7c5bc000">index_type</a>&gt; <a class="el" href="classgko_1_1IndexSet.html">gko::IndexSet</a>&lt; IndexType &gt;::to_global_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function allows the user obtain a decompresed global_indices <a class="el" href="classgko_1_1Array.html" title="An Array is a container which encapsulates fixed-sized arrays, stored on the Executor tied to the Arr...">Array</a> from the indices stored in the index set. </p>
<dl class="section return"><dt>Returns</dt><dd>the decompressed set of indices. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ginkgo/core/base/<a class="el" href="index__set_8hpp_source.html">index_set.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
