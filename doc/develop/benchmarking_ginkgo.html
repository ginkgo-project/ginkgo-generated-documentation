<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Ginkgo: Running the benchmarks</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_doc.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Ginkgo
   &#160;<span id="projectnumber">Generated from pipelines/537250335 branch based on develop. Ginkgo version 1.5.0</span>
   </div>
   <div id="projectbrief">A numerical linear algebra library targeting many-core architectures</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Running the benchmarks </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In addition to the unit tests designed to verify correctness, Ginkgo also includes an extensive benchmark suite for checking its performance on all Ginkgo supported systems. The purpose of Ginkgo's benchmarking suite is to allow easy and complete reproduction of Ginkgo's performance, and to facilitate performance debugging as well. Most results published in Ginkgo papers are generated thanks to this benchmarking suite and are accessible online under the <a href="https://github.com/ginkgo-project/ginkgo-data/">ginkgo-data repository</a>. These results can also be used for performance comparison in order to ensure that you get similar performance as what is published on this repository.</p>
<p>To compile the benchmarks, the flag <code>-GINKGO_BUILD_BENCHMARKS=ON</code> has to be set during the <code>cmake</code> step. In addition, the <a href="https://github.com/ginkgo-project/ssget"><code>ssget</code> command-line utility</a> has to be installed on the system. The purpose of this file is to explain in detail the capacities of this benchmarking suite as well as how to properly setup everything.</p>
<p>Here is a short description of the content of this file:</p><ol type="1">
<li>Ginkgo setup and best practice guidelines</li>
<li>Installing and using the <code>ssget</code> tool to fetch the <a href="https://sparse.tamu.edu/">SuiteSparse matrices</a>.</li>
<li>Benchmarking overview and how to run them in a simple way.</li>
<li>How to publish the benchmark results online and use the <a href="https://ginkgo-project.github.io/gpe/">Ginkgo Performance Explorer (GPE)</a> for performance analysis (optional).</li>
<li>Using the benchmark suite for performance debugging thanks to the loggers.</li>
<li>All available benchmark customization options.</li>
</ol>
<h2><a class="anchor" id="autotoc_md12"></a>
1: Ginkgo setup and best practice guidelines</h2>
<p>Before benchmarking Ginkgo, make sure that you follow the general guidelines in order to ensure best performance.</p>
<ol type="1">
<li>The code should be compiled in <code>Release</code> mode.</li>
<li>Make sure the machine has no competing jobs. On a Linux machine multiple commands can be used, <code>last</code> shows the currently opened sessions, <code>top</code> or <code>htop</code> allows to show the current machine load, and if considering using specific GPUs, <code>nvidia-smi</code> or <code>rocm-smi</code> can be used to check their load.</li>
<li>By default, Ginkgo's benchmarks will always do at least one warm-up run. For better accuracy, every benchmark is also averaged over 10 runs, except for the solver benchmark which are usually fairly long. These parameters can be tuned at the command line to either shorten benchmarking time or improve benchmarking accuracy.</li>
</ol>
<p>In addition, the following specific options can be considered:</p><ol type="1">
<li>When specifically using the adaptive block jacobi preconditioner, enable the <code>GINKGO_JACOBI_FULL_OPTIMIZATIONS</code> CMake flag. Be careful that this will use much more memory and time for the compilation due to compiler performance issues with register optimizations, in particular.</li>
<li>The current benchmarking setup also allows to benchmark only the overhead by using as either (or for all) preconditioner/spmv/solver, the special <code>overhead</code> LinOp. If your purpose is to check Ginkgo's overhead, make sure to try this mode.</li>
</ol>
<h2><a class="anchor" id="autotoc_md13"></a>
2: Using ssget to fetch the matrices</h2>
<p>The benchmark suite tests Ginkgo's performance using the <a href="https://sparse.tamu.edu/">SuiteSparse matrix collection</a> and artificially generated matrices. The suite sparse collection will be downloaded automatically when the benchmarks are run. This is done thanks to the <a href="https://github.com/ginkgo-project/ssget"><code>ssget</code> command-line utility</a>.</p>
<p>To install <code>ssget</code>, access the repository and copy the file <code>ssget</code> into a directory present in your <code>PATH</code> variable as per the tool's <code>README.md</code> instructions. The tool can be installed either in a global system path or a local directory such as <code>$HOME/.local/bin</code>. After installing the tool, it is important to review the <code>ssget</code> script and configure as needed the variable <code>ARCHIVE_LOCATION</code> on line 39. This is where the matrices will be stored into.</p>
<p>The Ginkgo benchmark can be set to run on only a portion of the SuiteSparse matrix collection as we will see in the following section. Please note that the entire collection requires roughly 100GB of disk storage in its compressed format, and roughly 25GB of additional disk space for intermediate data (such us uncompressing the archive). Additionally, the benchmark runs usually take a long time (SpMV benchmarks on the complete collection take roughly 24h using the K20 GPU), and will stress the system.</p>
<p>Before proceeding, it can be useful in order to save time to download the matrices as preparation. This can be done by using the <code>ssget -f -i i</code> command where <code>i</code> is the ID of the matrix to be downloaded. The following loop allows to download the full SuiteSparse matrix collection:</p>
<div class="fragment"><div class="line">for i in $(seq 0 $(ssget -n)); do</div>
<div class="line">    ssget -f -i ${i}</div>
<div class="line">done</div>
</div><!-- fragment --><p>Note that <code>ssget</code> can also be used to query properties of the matrix and filter the matrices which are downloaded. For example, the following will download only positive definite matrices with less than 500M non zero elements and 10M columns. Please refer to the <a href="https://github.com/ginkgo-project/ssget/blob/master/README.md"><code>ssget</code> documentation</a> for more information.</p>
<div class="fragment"><div class="line">for i in $(seq 0 $(ssget -n)); do</div>
<div class="line">    posdef=$(ssget -p posdef -i ${i})</div>
<div class="line">    cols=$(ssget -p cols -i ${i})</div>
<div class="line">    nnz=$(ssget -p nonzeros -i ${i})</div>
<div class="line">    if [ &quot;$posdef&quot; -eq 1 -a &quot;$cols&quot; -lt 10000000 -a &quot;$nnz&quot; -lt 500000000 ]; then</div>
<div class="line">        ssget -f -i ${i}</div>
<div class="line">    fi</div>
<div class="line">done</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md14"></a>
3: Benchmarking overview</h2>
<p>The benchmark suite is invoked using the <code>make benchmark</code> command in the build directory. Under the hood, this command simply calls the script <code>benchmark/run_all_benchmarks.sh</code> so it is possible to manually launch this script as well. The behavior of the suite can be modified using environment variables. Assuming the <code>bash</code> shell is used, these can either be specified via the <code>export</code> command to persist between multiple runs:</p>
<div class="fragment"><div class="line">export VARIABLE=&quot;value&quot;</div>
<div class="line">...</div>
<div class="line">make benchmark</div>
</div><!-- fragment --><p>or specified on the fly, on the same line as the <code>make benchmark</code> command:</p>
<div class="fragment"><div class="line">VARIABLE=&quot;value&quot; ... make benchmark</div>
</div><!-- fragment --><p>Since <code>make</code> sets any variables passed to it as temporary environment variables, the following shorthand can also be used:</p>
<div class="fragment"><div class="line">make benchmark VARIABLE=&quot;value&quot; ...</div>
</div><!-- fragment --><p>A combination of the above approaches is also possible (e.g. it may be useful to <code>export</code> the <code>SYSTEM_NAME</code> variable, and specify the others at every benchmark run).</p>
<p>The benchmark suite can take a number of configuration parameters. Benchmarks can be run only for <code>sparse matrix vector products (spmv)</code>, for full solvers (with or without preconditioners), or for preconditioners only when supported. The benchmark suite also allows to target a sub-part of the SuiteSparse matrix collection. For details, see the <a href="### 6: Available
benchmark options">available benchmark options</a>. Here are the most important options:</p><ul>
<li><code>BENCHMARK={spmv, solver, preconditioner}</code> - allows to select the type of benchmark to be ran.</li>
<li><code>EXECUTOR={reference,cuda,hip,omp,dpcpp}</code> - select the executor and platform the benchmarks should be ran on.</li>
<li><code>SYSTEM_NAME=&lt;name&gt;</code> - a name which will be used to designate this platform (e.g. V100, RadeonVII, ...).</li>
<li><code>SEGMENTS=&lt;N&gt;</code> - Split the benchmarked matrix space into <code>&lt;N&gt;</code> segments. If specified, <code>SEGMENT_ID</code> also has to be set.</li>
<li><code>SEGMENT_ID=&lt;I&gt;</code> - used in combination with the <code>SEGMENTS</code> variable. <code>&lt;I&gt;</code> should be an integer between 1 and <code>&lt;N&gt;</code>, the number of <code>SEGMENTS</code>. If specified, only the <code>&lt;I&gt;</code>-th segment of the benchmark suite will be run.</li>
<li><code>BENCHMARK_PRECISION</code> - defines the precision the benchmarks are run in. Supported values are: "double" (default), "single", "dcomplex" and "scomplex"</li>
<li><p class="startli"><code>MATRIX_LIST_FILE=/path/to/matrix_list.file</code> - allows to list SuiteSparse matrix id or name to benchmark. As an example, a matrix list file containing the following will ensure that benchmarks are ran for only those three matrices:</p>
<p class="startli">``` 1903 Freescale/circuit5M thermal2 ```</p>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md15"></a>
4: Publishing the results on Github and analyze the results with the GPE (optional)</h2>
<p>The previous experiments generated json files for each matrices, each containing timing, iteration count, achieved precision, ... depending on the type of benchmark run. These files are available in the directory <code>${ginkgo_build_dir}/benchmark/results/</code>. These files can be analyzed and processed through any tool (e.g. python). In this section, we describe how to generate the plots by using Ginkgo's <a href="https://ginkgo-project.github.io/gpe/">GPE</a> tool. First, we need to publish the experiments into a Github repository which will be then linked as source input to the GPE. For this, we can simply fork the ginkgo-data repository. To do so, we can go to the github repository and use the forking interface: <a href="https://github.com/ginkgo-project/ginkgo-data/">https://github.com/ginkgo-project/ginkgo-data/</a></p>
<p>Once it's done, we want to clone the repository locally, put all results online and access the GPE for plotting the results. Here are the detailed steps:</p>
<div class="fragment"><div class="line">git clone https://github.com/&lt;username&gt;/ginkgo-data.git $HOME/ginkgo_benchmark/ginkgo-data</div>
<div class="line"># send the benchmarked data to the ginkgo-data repository</div>
<div class="line"># If needed, remove the old data so that no previous data is left.</div>
<div class="line"># rm -r ${HOME}/ginkgo_benchmark/ginkgo-data/data/${SYSTEM_NAME}</div>
<div class="line">rsync -rtv ${ginkgo_build_dir}/benchmark/results/ $HOME/ginkgo_benchmark/ginkgo-data/data/</div>
<div class="line">cd ${HOME}/ginkgo_benchmark/ginkgo-data/data/</div>
<div class="line"># The following updates the main `.json` files with the list of data.</div>
<div class="line"># Ensure a python 3 installation is available.</div>
<div class="line">./build-list . &gt; list.json</div>
<div class="line">./agregate &lt; list.json &gt; agregate.json</div>
<div class="line">./represent . &gt; represent.json</div>
<div class="line">git config --local user.name &quot;&lt;Name&gt;&quot;</div>
<div class="line">git config --local user.email &quot;&lt;email&gt;&quot;</div>
<div class="line">git commit -am &quot;Ginkgo benchmark ${BENCHMARK} of ${SYSTEM_NAME}...&quot;</div>
<div class="line">git push</div>
</div><!-- fragment --><p>Note that depending on what data is of interest, you may need to update the scripts <code>build-list</code> or <code>agregate</code> to change which files you want to agglomerate and summarize (depending on the system name), or which data you want to select (solver results, spmv results, ...).</p>
<p>For the generating the plots in the GPE, here are the steps to go through:</p><ol type="1">
<li>Access the GPE: <a href="https://ginkgo-project.github.io/gpe/">https://ginkgo-project.github.io/gpe/</a></li>
<li>Update data root URL, from <code><a href="https://raw.githubusercontent.com/ginkgo-project/ginkgo-data/master/data">https://raw.githubusercontent.com/ginkgo-project/ginkgo-data/master/data</a></code> to <code><a href="https://raw.githubusercontent.com/">https://raw.githubusercontent.com/</a>&lt;username&gt;/ginkgo-data/&lt;branch&gt;/data</code></li>
<li>Click on the arrow to load the data, select the <code>Result Summary</code> entry above.</li>
<li>Click on <code>select an example</code> to choose a plotting script. Multiple scripts are available by default in different branches. You can use the <code>jsonata</code> and <code>chartjs</code> languages to develop your own as well.</li>
<li>The results should be available in the tab "plot" on the right side. Other tabs allow to access the result of the processed data after invoking the processing script.</li>
</ol>
<h2><a class="anchor" id="autotoc_md16"></a>
5: Detailed performance analysis and debugging</h2>
<p>Detailed performance analysis can be ran by passing the environment variable <code>DETAILED=1</code> to the benchmarking script. This detailed run is available for solvers and allows to log the internal residual after every iteration as well as log the time taken by all operations. These features are also available in the <code>performance-debugging</code> example which can be used instead and modified as needed to analyze Ginkgo's performance.</p>
<p>These features are implemented thanks to the loggers located in the file <code>${ginkgo_src_dir}/benchmark/utils/loggers.hpp</code>. Ginkgo possesses hooks at all important code location points which can be inspected thanks to the logger. In this fashion, it is easy to use these loggers also for tracking memory allocation sizes and other important library aspects.</p>
<h2><a class="anchor" id="autotoc_md17"></a>
6: Available benchmark options</h2>
<p>There are a set amount of options available for benchmarking. Most important options can be configured through the benchmarking script itself thanks to environment variables. Otherwise, some specific options are not available through the benchmarking scripts but can be directly configured when running the benchmarking program itself. For a list of all options, run for example <code>${ginkgo_build_dir}/benchmark/solver/solver --help</code>.</p>
<p>The supported environment variables are described in the following list:</p><ul>
<li><code>BENCHMARK={spmv, solver, preconditioner}</code> - allows to select the type of benchmark to be ran. Default is <code>spmv</code>.<ul>
<li><code>spmv</code> - Runs the sparse matrix-vector product benchmarks on the SuiteSparse collection.</li>
<li><code>solver</code> - Runs the solver benchmarks on the SuiteSparse collection. The matrix format is determined by running the <code>spmv</code> benchmarks first, and using the fastest format determined by that benchmark.</li>
<li><code>preconditioner</code> - Runs the preconditioner benchmarks on artificially generated block-diagonal matrices.</li>
</ul>
</li>
<li><code>EXECUTOR={reference,cuda,hip,omp,dpcpp}</code> - select the executor and platform the benchmarks should be ran on. Default is <code>cuda</code>.</li>
<li><code>SYSTEM_NAME=&lt;name&gt;</code> - a name which will be used to designate this platform (e.g. V100, RadeonVII, ...) and not overwrite previous results. Default is <code>unknown</code>.</li>
<li><code>SEGMENTS=&lt;N&gt;</code> - Split the benchmarked matrix space into <code>&lt;N&gt;</code> segments. If specified, <code>SEGMENT_ID</code> also has to be set. Default is <code>1</code>.</li>
<li><code>SEGMENT_ID=&lt;I&gt;</code> - used in combination with the <code>SEGMENTS</code> variable. <code>&lt;I&gt;</code> should be an integer between 1 and <code>&lt;N&gt;</code>, the number of <code>SEGMENTS</code>. If specified, only the <code>&lt;I&gt;</code>-th segment of the benchmark suite will be run. Default is <code>1</code>.</li>
<li><code>MATRIX_LIST_FILE=/path/to/matrix_list.file</code> - allows to list SuiteSparse matrix id or name to benchmark. As an example, a matrix list file containing the following will ensure that benchmarks are ran for only those three matrices: ``` 1903 Freescale/circuit5M thermal2 ``<code> *</code>DEVICE_ID<code>- the accelerator device ID to target for the benchmark. The default is</code>0<code>. *</code>DRY_RUN={true, false}<code>- If set to</code>true`, prepares the system for the benchmark runs (downloads the collections, creates the result structure, etc.) and outputs the list of commands that would normally be run, but does not run the benchmarks themselves. Default is <code>false</code>.</li>
<li><code>PRECONDS={jacobi,ic,ilu,paric,parict,parilu,parilut,ic-isai,ilu-isai,paric-isai,parict-isai,parilu-isai,parilut-isai,none}</code> the preconditioners to use for either <code>solver</code> or <code>preconditioner</code> benchmarks. Multiple options can be passed to this variable. Default is <code>none</code>.</li>
<li><code>FORMATS={csr,coo,ell,hybrid,sellp,hybridxx,cusparse_xx,hipsparse_xx}</code> the matrix formats to benchmark for the <code>spmv</code> phase of the benchmark. Run <code>${ginkgo_build_dir}/benchmark/spmv/spmv --help</code> for a full list. If needed, multiple options for hybrid with different optimization parameters are available. Depending on the libraries available at build time, vendor library formats (cuSPARSE with <code>cusparse_</code> prefix or hipSPARSE with <code>hipsparse_</code> prefix) can be used as well. Multiple options can be passed. The default is <code>csr,coo,ell,hybrid,sellp</code>.</li>
<li><code>SOLVERS={bicgstab,bicg,cg,cgs,fcg,gmres,cb_gmres_{keep,reduce1,reduce2,integer,ireduce1,ireduce2},lower_trs,upper_trs}</code><ul>
<li>the solvers which should be benchmarked. Multiple options can be passed. The default is <code>bicgstab,cg,cgs,fcg,gmres,idr</code>. Note that <code>lower/upper_trs</code> by default don't use a preconditioner, as they are by default exact direct solvers.</li>
</ul>
</li>
<li><code>SOLVERS_PRECISION=&lt;precision&gt;</code> - the minimal residual reduction before which the solver should stop. The default is <code>1e-6</code>.</li>
<li><code>SOLVERS_MAX_ITERATION=&lt;number&gt;</code> - the maximum number of iterations with which a solver should be ran. The default is <code>10000</code>.</li>
<li><code>SOLVERS_RHS={1, random, sinus}</code> - whether to use a vector of all ones, random values or b = A * (s / |s|)$ with s(idx) = sin(idx) (for complex numbers, s(idx) = sin(2*idx) + i * sin(2*idx+1)) as the right-hand side in solver benchmarks. Default is <code>1</code>.</li>
<li><code>SOLVERS_INITIAL_GUESS={rhs,0,random}</code> - the initial guess generation of the solvers. <code>rhs</code> uses the right-hand side, <code>0</code> uses a zero vector and <code>random</code> generates a random vector as the initial guess.</li>
<li><code>DETAILED={0,1}</code> - selects whether detailed benchmarks should be ran for the solver benchmarks, can be either <code>0</code> (off) or <code>1</code> (on). The default is <code>0</code>.</li>
<li><code>GPU_TIMER={true, false}</code> - If set to <code>true</code>, use the gpu timer, which is valid for cuda/hip executor, to measure the timing. Default is <code>false</code>.</li>
<li><code>SOLVERS_JACOBI_MAX_BS</code> - sets the maximum block size for the Jacobi preconditioner (if used, otherwise, it does nothing) in the solvers benchmark. The default is '32'.</li>
<li><code>SOLVERS_GMRES_RESTART</code> - the maximum dimension of the Krylov space to use in GMRES. The default is <code>100</code>. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
